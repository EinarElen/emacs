#+TITLE: Emacs Configuration
#+AUTHOR: Einar Elén
#+EMAIL: einar.elen@gmail.com
#+OPTIONS: toc:3 html5-fancy org-html-preamble:nil
#+HTML_DOCTYPE_HTML5: t
* Emacs Setup
** Package Installation
   This sets up everything necerssary to install new packages and adds
   two package archives, Melpa and Org, in addition to the default packages.
*** Package List
    This is a list of packages that will be installed automatically if
    they are not already installed. They are used by the function (install-packages).
    #+BEGIN_SRC emacs-lisp
(defconst demo-packages
  '(magit
    multiple-cursors
    pp-c-l
    paredit
    paredit-everywhere
    redshank
    eldoc
    eldoc-extension
    ert
    elint
    highlight-cl
    testcover
                                        ;          info-lookmore
    elisp-slime-nav
    paredit-menu
    f
    auto-complete-clang
    meson-mode
    org-plus-contrib
    expand-region
    persp-mode
    persp-projectile
    winum
    eyebrowse
    spacemacs-theme
    spaceline
    all-the-icons
    spaceline-all-the-icons
    info+
    dumb-jump
    blackboard-theme
    cmake-ide
    cmake-mode
    counsel
    cpputils-cmake
    helm-themes
    xelb
    exwm
    ox-twbs
    org-gcal
    cmake-project
    cmake-font-lock
    org-beautify-theme
    use-package
    rtags
    company-rtags
    helm-rtags
    flycheck-rtags
    srefactor
    macrostep
    calfw
    pdf-tools
    web-mode
    winner
    bind-key
                                        ;          switch-window
    clipmon
    htmlize
    sr-speedbar
    multi-term
    exec-path-from-shell
    powerline
    nlinum
    flycheck-irony
    solarized-theme
    company-c-headers
    flycheck
    flycheck-pos-tip
    avy
    avy-zap
    anzu
    company
    duplicate-thing
    helm
    helm-descbinds
    helm-gtags
    helm-dash
    clang-format
    helm-projectile
    helm-swoop
    function-args
    clean-aindent-mode
    comment-dwim-2
    dtrt-indent
    ws-butler
    color-identifiers-mode
    iedit
    smartparens
    projectile
    irony
    company-irony
    company-irony-c-headers
    volatile-highlights
    undo-tree
    diminish
    auctex
    company-auctex
    latex-preview-pane
    helm-c-yasnippet
    monokai-theme
    zygospore
    helm-swoop
    zoom-frm
    gnuplot
    hyperbole
    fold-dwim
    ))
    #+END_SRC
    This sets up some slightly more sane default values and adds a better
    pdf reader (which requires manual installation through the
    (pdf-tools-install) function, which is run automatically if possible)
*** Initialization
    #+BEGIN_SRC emacs-lisp
(require 'package)
(add-to-list 'package-archives
             '("melpa" . "http://melpa.org/packages/") t)
(add-to-list 'package-archives
             '("org" . "http://orgmode.org/elpa/") t)
(package-initialize)
(defun install-packages ()
  "Install all required packages."
  (interactive)
  (unless package-archive-contents
    (package-refresh-contents))
  (dolist (package demo-packages)
    (unless (package-installed-p package)
      (package-install package))))
(install-packages)
(require 'use-package)
(defvar use-package-verbose t)
(require 'diminish)
    #+END_SRC
** Personal
   #+BEGIN_SRC emacs-lisp
(setq user-full-name "Einar Elén"
      user-mail-address "einar.elen@gmail.com")
   #+END_SRC
** Improve Basic Emacs Experience
*** Configuration file
    Creates a function which returns you to this file and binds
    it to f8
    #+BEGIN_SRC emacs-lisp 
(defun configuration-file() 
  (interactive)
  (find-file "~/.emacs.d/configuration.org"))
(global-set-key (kbd "<f8>") 'configuration-file)
    #+END_SRC
*** PDF-Handling
    The basic emacs pdf viewing utility, docview, is kind of
    wonky. This installs a different utility, pdf-tools which is
    wonderful! It does require some things installed on your
    system to work (development version of all of them)
    - libpng
    - libpoppler-glib, libpoppler-private
    - imagemagick
    - libz
    - gcc, g++
    - make
    - automake
    - autoconf
    It is currently only enabled on linux and cygwin.
    #+BEGIN_SRC emacs-lisp 
(use-package pdf-tools
  :when (or (eq system-type 'gnu/linux) 
            (eq system-type 'cygwin))
  :init
  (pdf-tools-install)
  :config
  (add-hook 'pdf-view-mode-hook 'auto-revert-mode)
  (setq TeX-view-program-selection '((output-pdf "pdf-tools"))
        TeX-view-program-list '(("pdf-tools" "TeX-pdf-tools-sync-view"))))
    #+END_SRC
*** Additional Settings
    Change the window-title to Emacs
    #+BEGIN_SRC emacs-lisp
(setq frame-title-format "Emacs")
    #+END_SRC
    Disable scrollbar, menubar and toolbar, disable the keys
    that hide emacs (they are easy to hit on accident which is
    annoying). Also, show column and line number of the cursor
    in the modeline.
    #+BEGIN_SRC emacs-lisp 
(menu-bar-mode -1)
(when (display-graphic-p)
  (tool-bar-mode -1)
  (scroll-bar-mode -1))
(global-unset-key (kbd "C-x C-z"))
(global-unset-key (kbd "C-z"))
(setq column-number-mode t
      line-number-mode t)
    #+END_SRC
    Flash the screen rather than making noise when complaining. 
    #+BEGIN_SRC emacs-lisp 
(setq visible-bell t)
    #+END_SRC
    Show a clock!
    #+BEGIN_SRC emacs-lisp 
(display-time)
    #+END_SRC
    Always answer yes or no questions with just y or n, yes or
    no is annoying to type...
    #+BEGIN_SRC emacs-lisp 
(defalias 'yes-or-no-p 'y-or-n-p)
    #+END_SRC
    Enable syntax highlighting in all modes where it is possible!
    #+BEGIN_SRC emacs-lisp 
(global-font-lock-mode t)
    #+END_SRC
    Other stuff which may or may not work...
    #+BEGIN_SRC emacs-lisp 
(setq gc-cons-threshold 100000000
      inhibit-startup-message t
      backup-by-copying t
      backup-directory-alist
      '(("." . "~/.saves"))
      delete-old-versions -1
      vc-make-backup-files t
      auto-save-file-name-transform '((".*" "~/.saves/auto-save-list/" t))
      history-length t
      history-delete-duplicates t
      savehist-save-minibuffer-history 1
      savehist-additional-variables '(kill-ring
                                      search-ring
                                      regexp-search-ring)
      version-control t
      tramp-default-method "ssh"
      x-stretch-cursor 1)
(setq-default
 fill-column 80
 cursor-type 'bar)
    #+END_SRC
*** Window Management
    Winner allows you to restore previous window configurations
    and jump around in the window configuration history using
    C-c <left> and C-c <right> (the arrowkeys).

    Try it out by typing C-x 3, C-x o, C-x b (choose some
    buffer) and then C-c <left> twice to get back! Then try C-c
    <right> once and C-c <left again to return!

    Windmove keybindings allows you to switch between your
    windows with shift + arrowkeys which can be handy when
    you're tired. 

    Clipmon tries to help emacs synchronize copies and pastes
    between emacs and the rest of your operating system.
    #+BEGIN_SRC emacs-lisp
(use-package winner
  :defer 2
  :config
  (winner-mode t))
;; (use-package switch-window
;;   :defer 2
;;   :bind (("C-x o" . switch-window)))
;; 
(windmove-default-keybindings)
(use-package clipmon
  :defer 2
  :init (progn (setq
                clipmon-action 'kill-new
                clipmon-timeout nil
                clipmon-sound nil
                clipmon-cursor-color nil
                clipmon-suffix nil)
               (clipmon-mode)))
(use-package hyperbole
  :disabled t
  :defer 2)
    #+END_SRC
** Looks/Themes
*** Basic Configuration
    Adds line numbering to and a nice information bar below each buffer
    and some other neat things
    #+BEGIN_SRC emacs-lisp
(use-package powerline
  :disabled t
  :defer 1
  :init (powerline-vim-theme))
(use-package nlinum
  :init (global-nlinum-mode t))
(defcustom linum-disabled-modes-list '(eshell-mode wl-summary-mode compilation-mode org-mode text-mode dired-mode doc-view-mode)
  "* List of modes disabled when global linum mode is on"
  :type '(repeat (sexp :tag "Major mode"))
  :tag " Major modes where linum is disabled: "
  :group 'linum)
(defcustom linum-disable-starred-buffers 't
  "* Disable buffers that have stars in them like *Gnu Emacs*"
  :type 'boolean
  :group 'linum)
(defun linum-on ()
  "* When linum is running globally, disable line number in modes defined in
        `linum-disabled-modes-list'. Changed by linum-off. Also turns off numbering
       in starred modes like *scratch*"
  (unless (or (minibufferp) (member major-mode linum-disabled-modes-list)
              (and linum-disable-starred-buffers (string-match "*" (buffer-name))))
    (nlinum-mode 1)))

(use-package color-identifiers-mode
  :diminish color-identifiers-mode
  :defer 4
  :config
  (global-color-identifiers-mode t))
(global-set-key (kbd "C-x 1") 'zygospore-toggle-delete-other-windows)
    #+END_SRC
*** Random Themes
    I dont like using the same themes all the time so this little function
    switches between three different ones. Feel free to disable this by
    removing the call to the function (choose-random-theme).
    #+BEGIN_SRC emacs-lisp
(defvar themes-to-use (list "monokai" "solarized-dark" "solarized-light") "List of themes that will be loaded by choose-random-theme")
(defvar current-theme-used (list "monokai") "Current theme chosen by choose-random theme")
(defun choose-random-theme ()
  "Choose random theme from themes-to-use!"
  (interactive)
  (setq current-theme-number (random (length themes-to-use)))
  (when (= current-theme-number 0)
    (setq current-theme-used (list "monokai"))
    (load-theme 'monokai t))
  (when (= current-theme-number 1)
    (setq current-theme-used (list "solarized-dark"))
    (load-theme 'solarized-dark t))
  (when (= current-theme-number 2)
    (setq current-theme-used (list "solarized-light"))
    (load-theme 'solarized-light t)))
                                        ;   (choose-random-theme)
(use-package helm-themes
  :bind (("<f10>" . helm-themes)))

    #+END_SRC
** Text Editing
   Everything in here is essentially from [[http://tuhdo.github.io][tuhdo]] and most of it is sane by
   default. Check out the individual packages in his C/C++ tutorial!
*** Basic
    #+BEGIN_SRC emacs-lisp
(setq global-mark-ring-max 5000
      mark-ring-max 5000
      mode-require-final-newline t
      tab-width 4
      kill-ring-max 5000
      kill-whole-line t)
(setq-default indent-tabs-mode nil
              indent-tabs-mode nil
              tab-width 4)


(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-language-environment "UTF-8")
(prefer-coding-system 'utf-8)
(delete-selection-mode)
(add-hook 'sh-mode-hook (lambda ()
                          (setq tab-width 4)))
(add-hook 'diff-mode-hook (lambda () (setq-local whitespace-style
                                                 '(face
                                                   tabs
                                                   tab-mark
                                                   spaces
                                                   space-mark
                                                   trailing
                                                   indentation::space
                                                   indentation::tab
                                                   newline
                                                   newline-mark))
                            (whitespace-mode 1)))
(add-hook 'prog-mode-hook (lambda () (interactive) (setq show-trailing-whitespace 1)))
(add-hook 'text-mode-hook 'auto-fill-mode)
    #+END_SRC
*** Keybindings
    #+BEGIN_SRC emacs-lisp
(global-set-key (kbd "RET") 'newline-and-indent)
(global-set-key (kbd "RET") 'newline-and-indent)
(defun useless (&rest args)
  (interactive)
  "Does nothing ARGS."
  nil)
(global-set-key (kbd "C-<down-mouse-1>") 'useless)
(global-set-key (kbd "C-<down-mouse-2>") 'useless)
(global-set-key (kbd "C-<down-mouse-3>") 'useless)
(global-set-key (kbd "C-<mouse-1>") 'useless)
(global-set-key (kbd "C-<mouse-2>") 'useless)
(global-set-key (kbd "C-<mouse-3>") 'useless)
(global-set-key (kbd "C-c w") 'whitespace-mode)
(global-set-key (kbd "M-c") 'capitalize-dwim)
(global-set-key (kbd "<f5>") (lambda ()
                               (interactive)
                               (setq-local compilation-read-command nil)
                               (call-interactively 'compile)))
    #+END_SRC
*** Packages
**** Volatile Highlights
     #+BEGIN_SRC emacs-lisp
(use-package volatile-highlights

  :diminish volatile-highlights-mode
  :defer 2
  :init
  (volatile-highlights-mode t))
     #+END_SRC
**** Clean Aindent Mode
     #+BEGIN_SRC emacs-lisp
(use-package clean-aindent-mode

  :defer 2
  :config
  (add-hook 'prog-mode-hook 'clean-aindent-mode))
     #+END_SRC
**** Dtrt-Indent
     #+BEGIN_SRC emacs-lisp
(use-package dtrt-indent

  :defer 2
  :config
  (dtrt-indent-mode t)
  (setq dtrt-indent-verbosity 0)
  )
     #+END_SRC
**** Whitespace Butler
     #+BEGIN_SRC emacs-lisp
(use-package ws-butler

  :defer 2
  :diminish ws-butler-mode
  :config
  (add-hook 'c-mode-common-hook 'ws-butler-mode)
  (add-hook 'text-mode 'ws-butler-mode)
  (add-hook 'fundamental-mode 'ws-butler-mode)
  )
     #+END_SRC
**** Undo Tree
     #+BEGIN_SRC emacs-lisp
(use-package undo-tree

  :defer 2
  :diminish undo-tree-mode
  :init
  (global-undo-tree-mode)
  :config
  (setq undo-tree-visualizer-timestamps t
        undo-tree-visualizer-diff t)
  )
     #+END_SRC
**** Smartparens
     #+BEGIN_SRC emacs-lisp
(use-package smartparens

  :diminish smartparens-mode
  :defer 2
  :init
  (smartparens-global-mode t)
  :config
  (require 'smartparens-config)
  (sp-pair "\\[" "\\]")
  (setq sp-base-key-bindings 'paredit
        sp-autoskip-closing-pair 'always
        sp-hybrid-kill-entire-symbol nil)
  (sp-use-paredit-bindings)
  (show-smartparens-global-mode t)
  :bind (:map smartparens-mode-map (("M-<down>" . nil)
                                    ("M-<up>" . nil))))
     #+END_SRC
**** Comment-dwim-2
     #+BEGIN_SRC emacs-lisp
(global-set-key (kbd "M-;") 'comment-dwim-2)
     #+END_SRC
**** Anzu
     #+BEGIN_SRC emacs-lisp
(use-package anzu
  :diminish anzu-mode

  :defer 2
  :config
  (global-anzu-mode t)
  :bind (("M-%" . anzu-query-replace) 
         ("C-M-%" . anzy-query-replace-regexp)))
     #+END_SRC
**** Iedit
     This is really cool
     #+BEGIN_SRC emacs-lisp
(use-package iedit

  :defer 2
  :config
  (setq iedit-toggle-key-default nil)
  :bind (("C-M-;" . iedit-mode)))
     #+END_SRC
**** Duplicate Thing
     #+BEGIN_SRC emacs-lisp
(use-package duplicate-thing
  :defer 2
  :bind (("C-M-c" . duplicate-thing)))
     #+END_SRC
**** Customized Functions (Mainly From Prelude)
     #+BEGIN_SRC emacs-lisp
(defun prelude-move-beginning-of-line (arg)
  "Move point back to indentation of beginning of line.
       Move point to the first non-whitespace character on this line.
       If point is already there, move to the beginning of the line.
       Effectively toggle between the first non-whitespace character and
       the beginning of the line.
       If ARG is not nil or 1, move forward ARG - 1 lines first. If
       point reaches the beginning or end of the buffer, stop there."
  (interactive "^p")
  (setq arg (or arg 1))
  ;; Move lines first
  (when (/= arg 1)
    (let ((line-move-visual nil))
      (forward-line (1- arg))))
  (let ((orig-point (point)))
    (back-to-indentation)
    (when (= orig-point (point))
      (move-beginning-of-line 1))))
(global-set-key (kbd "C-a") 'prelude-move-beginning-of-line)
(defadvice kill-ring-save (before slick-copy activate compile)
  "When called interactively with no active region, copy a single
       line instead."
  (interactive
   (if mark-active (list (region-beginning) (region-end))
     (message "Copied line")
     (list (line-beginning-position)
           (line-beginning-position 2)))))
(defadvice kill-region (before slick-cut activate compile)
  "When called interactively with no active region, kill a single
         line instead."
  (interactive
   (if mark-active (list (region-beginning) (region-end))
     (list (line-beginning-position)
           (line-beginning-position 2)))))
;; kill a line, including whitespace characters until next non-whiepsace character
;; of next line
(defadvice kill-line (before check-position activate)
  (if (member major-mode
              '(emacs-lisp-mode scheme-mode lisp-mode
                                c-mode c++-mode objc-mode
                                latex-mode plain-tex-mode))
      (if (and (eolp) (not (bolp)))
          (progn (forward-char 1)
                 (just-one-space 0)
                 (backward-char 1)))))
;; taken from prelude-editor.el
;; automatically indenting yanked text if in programming-modes
(defvar yank-indent-modes
  '(LaTeX-mode TeX-mode)
  "Modes in which to indent regions that are yanked (or yank-popped).
       Only modes that don't derive from `prog-mode' should be listed here.")

(defvar yank-indent-blacklisted-modes
  '(python-mode slim-mode haml-mode)
  "Modes for which auto-indenting is suppressed.")

(defvar yank-advised-indent-threshold 1000
  "Threshold (# chars) over which indentation does not automatically occur.")

(defun yank-advised-indent-function (beg end)
  "Do indentation, as long as the region isn't too large."
  (if (<= (- end beg) yank-advised-indent-threshold)
      (indent-region beg end nil)))

(defadvice yank (after yank-indent activate)
  "If current mode is one of 'yank-indent-modes,
       indent yanked text (with prefix arg don't indent)."
  (if (and (not (ad-get-arg 0))
           (not (member major-mode yank-indent-blacklisted-modes))
           (or (derived-mode-p 'prog-mode)
               (member major-mode yank-indent-modes)))
      (let ((transient-mark-mode nil))
        (yank-advised-indent-function (region-beginning) (region-end)))))

(defadvice yank-pop (after yank-pop-indent activate)
  "If current mode is one of `yank-indent-modes',
       indent yanked text (with prefix arg don't indent)."
  (when (and (not (ad-get-arg 0))
             (not (member major-mode yank-indent-blacklisted-modes))
             (or (derived-mode-p 'prog-mode)
                 (member major-mode yank-indent-modes)))
    (let ((transient-mark-mode nil))
      (yank-advised-indent-function (region-beginning) (region-end)))))
;; prelude-core.el
(defun indent-buffer ()
  "Indent the currently visited buffer."
  (interactive)
  (indent-region (point-min) (point-max)))

;; prelude-editing.el
(defcustom prelude-indent-sensitive-modes
  '(coffee-mode python-mode slim-mode haml-mode yaml-mode)
  "Modes for which auto-indenting is suppressed."
  :type 'list)

(defun indent-region-or-buffer ()
  "Indent a region if selected, otherwise the whole buffer."
  (interactive)
  (unless (member major-mode prelude-indent-sensitive-modes)
    (save-excursion
      (if (region-active-p)
          (progn
            (indent-region (region-beginning) (region-end))
            (message "Indented selected region."))
        (progn
          (indent-buffer)
          (message "Indented buffer.")))
      (whitespace-cleanup))))

(global-set-key (kbd "C-c i") 'indent-region-or-buffer)

;; add duplicate line function from Prelude
;; taken from prelude-core.el
(defun prelude-get-positions-of-line-or-region ()
  "Return positions (beg . end) of the current line
       or region."
  (let (beg end)
    (if (and mark-active (> (point) (mark)))
        (exchange-point-and-mark))
    (setq beg (line-beginning-position))
    (if mark-active
        (exchange-point-and-mark))
    (setq end (line-end-position))
    (cons beg end)))

;; smart openline
(defun prelude-smart-open-line (arg)
  "Insert an empty line after the current line.
       Position the cursor at its beginning, according to the current mode.
       With a prefix ARG open line above the current line."
  (interactive "P")
  (if arg
      (prelude-smart-open-line-above)
    (progn
      (move-end-of-line nil)
      (newline-and-indent))))

(defun prelude-smart-open-line-above ()
  "Insert an empty line above the current line.
       Position the cursor at it's beginning, according to the current mode."
  (interactive)
  (move-beginning-of-line nil)
  (newline-and-indent)
  (forward-line -1)
  (indent-according-to-mode))
(global-set-key (kbd "M-o") 'prelude-smart-open-line)
     #+END_SRC
**** Avy
     #+BEGIN_SRC emacs-lisp
(use-package avy
  
  :defer 2
  :config
  (setq avy-all-windows nil)
  :bind (("C-:" . avy-goto-char) ("C-;" . avy-goto-word-1) ("M-;" . avy-goto-line)))
(use-package avy-zap
  
  :defer 2)
     #+END_SRC
**** Fold-dwim
     #+BEGIN_SRC emacs-lisp 
(use-package fold-dwim 
  :bind (("C-c C-M-f" . fold-dwim-toggle)))
     #+END_SRC
**** Dumb-Jump
     #+BEGIN_SRC emacs-lisp 
(use-package dumb-jump
  :defer 2
  :config
  (dumb-jump-mode t))
     #+END_SRC
** Auto-mode List
   #+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.pdf\\'" . pdf-view-mode))
(add-to-list 'auto-mode-alist '("\\.h\\'" . c++-mode))
   #+END_SRC
* Development/Writing
  Again, visit [[http://tuhdo.github.io][tuhdo]] but check out the stuff about helm specifically!
** Project Management
*** Projectile
    #+BEGIN_SRC emacs-lisp
(use-package projectile
  
  :init
  (progn
    (projectile-global-mode t)
    (setq projectile-enable-caching t)
    nil)
  :config
  (setq projectile-enable-caching t)
  :diminish projectile-mode)
    #+END_SRC
*** Magit
    #+BEGIN_SRC emacs-lisp
(when (not (string= system-type "windows-nt"))
  (use-package magit
    
    :bind ("C-x g" . magit-status)
    :config
    (setq magit-diff-options '("-b"))))
    #+END_SRC
** Helm
*** Helm Gtags
    #+BEGIN_SRC emacs-lisp
(use-package helm-gtags
  :init (setq
         helm-gtags-ignore-case t
         helm-gtags-auto-update t
         helm-gtags-use-input-at-cursor t
         helm-gtags-pulse-at-cursor t
         helm-gtags-prefix-key "\C-cg"
                                        ;helm-gtags-suggested-key-mapping t
         )
  ;; Enable helm-gtags-mode in Dired so you can jump to any tag
  ;; when navigate project tree with Dired
  (add-hook 'dired-mode-hook 'helm-gtags-mode)
  ;; Enable helm-gtags-mode in Eshell for the same reason as above
  (add-hook 'eshell-mode-hook 'helm-gtags-mode)
  ;; Enable helm-gtags-mode in languages that GNU Global supports
  (add-hook 'c-mode-hook 'helm-gtags-mode)
  (add-hook 'c++-mode-hook 'helm-gtags-mode)
  (add-hook 'java-mode-hook 'helm-gtags-mode)
  (add-hook 'asm-mode-hook 'helm-gtags-mode)
  :config
  :bind (:map helm-gtags-mode-map
                                        ;("C-c >" . helm-gtags-next-history)
                                        ;("C-c <" . helm-gtags-previous-history)
                                        ;("M-," . helm-gtags-pop-stack)
                                        ;("M-." . helm-gtags-dwim)
                                        ;("C-j" . helm-gtags-select)
                                        ;("C-c g a" . helm-gtags-tags-in-this-function)
              )
  (setq helm-gtags-prefix-key "\C-cg"))
    #+END_SRC
*** Basic Configuration
    #+BEGIN_SRC emacs-lisp
(use-package helm
  :diminish helm-mode
  :init
  (require 'helm-config)
  (require 'helm-grep)
  :config
  (when (executable-find "curl")
    (setq helm-google-suggest-use-curl-p t))
  (setq helm-scroll-amount 4
        helm-ff-search-library-in-sexp t
        helm-split-window-in-side-p t
        helm-idle-delay 0.0
        helm-input-idle-delay 0.01
        helm-yas-display-key-on-candidate t
        helm-quick-update t
        helm-candidate-number-limit 500
        helm-ff-file-name-history-use-recentf t
        helm-move-to-line-cycle-in-source t
        helm-buffers-fuzzy-matching t
        helm-locate-fuzzy-match t helm-apropos-fuzzy-match t
        helm-M-x-requires-pattern nil
        helm-ff-skip-boring-files t
        )
  (add-to-list 'helm-sources-using-default-as-input 'helm-source-man-pages)
  (add-hook 'eshell-mode-hook
            #'(lambda ()
                (define-key eshell-mode-map (kbd "M-l")  'helm-eshell-history)))
  (add-hook 'helm-goto-line-before-hook 'helm-save-current-pos-to-mark-ring)
  (helm-autoresize-mode t)
  (ido-mode -1)
  (helm-mode))
    #+END_SRC
*** Packages
**** Helm-descbinds
     #+BEGIN_SRC emacs-lisp
(use-package helm-descbinds
  
  :defer 2
  :init
  (helm-descbinds-mode t)
  )
     #+END_SRC
**** Helm-dash
     #+BEGIN_SRC emacs-lisp
(use-package helm-dash)

     #+END_SRC
**** Helm-swoop
     #+BEGIN_SRC emacs-lisp
(use-package helm-swoop
  
  :config
  (setq helm-multi-swoop-edit-save t
        helm-swoop-split-with-multiple-windows t
        helm-swoop-split-direction 'split-window-vertically
        helm-swoop-speed-or-color t
        ))
     #+END_SRC
**** Helm-projectile
     #+BEGIN_SRC emacs-lisp
(use-package helm-projectile
  
  :init
  (helm-projectile-on)
  :config
  (setq projectile-completion-system 'helm)
  (setq projectile-indexing-method 'alien))
     #+END_SRC
*** Helm Keybindings
    #+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c h") 'helm-command-prefix)
(global-unset-key (kbd "C-x c"))
(define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action) ; rebihnd tab to do persistent action
(define-key helm-map (kbd "C-i") 'helm-execute-persistent-action) ; make TAB works in terminal
(define-key helm-map (kbd "C-z")  'helm-select-action) ; list actions using C-z
(define-key helm-grep-mode-map (kbd "<return>")  'helm-grep-mode-jump-other-window)
(define-key helm-grep-mode-map (kbd "n")  'helm-grep-mode-jump-other-window-forward)
(define-key helm-grep-mode-map (kbd "p")  'helm-grep-mode-jump-other-window-backward)
(global-set-key (kbd "M-x") 'helm-M-x)
(global-set-key (kbd "M-y") 'helm-show-kill-ring)
(global-set-key (kbd "C-x b") 'helm-mini)
(global-set-key (kbd "C-x C-f") 'helm-find-files)
(global-set-key (kbd "C-h SPC") 'helm-all-mark-rings)
(global-set-key (kbd "C-c h o") 'helm-occur)
(global-set-key (kbd "C-c h C-c w") 'helm-wikipedia-suggest)
(global-set-key (kbd "C-c h x") 'helm-register)
;; (global-set-key (kbd "C-x r j") 'jump-to-register)
(define-key 'help-command (kbd "C-f") 'helm-apropos)
(define-key 'help-command (kbd "r") 'helm-info-emacs)
(define-key 'help-command (kbd "C-l") 'helm-locate-library)
(define-key minibuffer-local-map (kbd "M-p") 'helm-minibuffer-history)
(define-key minibuffer-local-map (kbd "M-n") 'helm-minibuffer-history)
(define-key global-map [remap find-tag] 'helm-etags-select)
(define-key global-map [remap list-buffers] 'helm-buffers-list)
(global-set-key (kbd "C-c h o") 'helm-swoop)
(global-set-key (kbd "C-c s") 'helm-multi-swoop-all)
(define-key isearch-mode-map (kbd "M-i") 'helm-swoop-from-isearch)
(define-key helm-swoop-map (kbd "M-i") 'helm-multi-swoop-all-from-helm-swoop)
    #+END_SRC
** Yasnippet
   #+BEGIN_SRC emacs-lisp
(defun disable-yas-in-mode-hook ()
  "Hook to disable yasnippet when it causes issues for some other mode."
  (yas-minor-mode -1))
(require 'yasnippet)
(use-package yasnippet
  :init
  (set 'yas-verbosity 1)
  (add-to-list 'yas-snippet-dirs "~/.emacs.d/tuhdosnippets/")
  (yas-global-mode t)
  (add-hook 'term-mode-hook 'disable-yas-in-mode-hook)
                                        ;(add-hook 'org-mode-hook 'disable-yas-in-mode-hook)
  (yas-reload-all t)
  (add-hook 'c-mode-hook 'yas-minor-mode-on)
  (add-hook 'c++-mode-hook 'yas-minor-mode-on)
  (add-hook 'latex-mode-hook 'yas-minor-mode-on))



   #+END_SRC
** Terminal Usage
   #+BEGIN_SRC emacs-lisp
(use-package multi-term

  :bind (("<f6>" . multi-term-next)
         ("C-<f6>" . multi-term))
  (:map term-raw-map
        ("C-c C-j" . term-line-mode))
  :config
  (if (file-exists-p "/usr/bin/fish")
      (setq multi-term-program "/usr/bin/fish"))
  (when (require 'term nil t) ; only if term can be loaded..
    (setq term-bind-key-alist
          (list (cons "C-c C-c" 'term-interrupt-subjob)
                (cons "C-p" 'previous-line)
                (cons "C-n" 'next-line)
                (cons "M-f" 'term-send-forward-word)
                (cons "M-b" 'term-send-backward-word)
                (cons "C-c C-j" 'term-line-mode)
                (cons "C-c C-k" 'term-char-mode)
                (cons "M-DEL" 'term-send-backward-kill-word)
                (cons "M-d" 'term-send-forward-kill-word)
                (cons "<C-left>" 'term-send-backward-word)
                (cons "<C-right>" 'term-send-forward-word)
                (cons "C-r" 'term-send-reverse-search-history)
                (cons "M-p" 'term-send-raw-meta)
                (cons "M-y" 'term-send-raw-meta)
                (cons "C-y" 'term-send-raw)))))
   #+END_SRC
** Latex/Auctex
   #+BEGIN_SRC emacs-lisp
(require 'latex)
(setq TeX-auto-save t)
(setq TeX-parse-self t)
(setq-default TeX-master nil)
(use-package latex-preview-pane
  :config
  (setq TeX-save-query nil)
  (latex-preview-pane-enable)
  (setq doc-view-continuous t))
   #+END_SRC
*** Asy
    #+BEGIN_SRC emacs-lisp
(require 'bind-key)
(defun run-asy-in-tex ()
  (interactive "")
  (TeX-command TeX-run-LaTeX (TeX-master-file nil nil nil) t)
  (save-window-excursion (compile "asy *.asy"))
  (TeX-command TeX-run-LaTeX (TeX-master-file nil nil nil) t)
  )
(add-to-list 'TeX-command-list '("Asymptote" "asy *.asy" TeX-run-TeX nil t :help "Run Asymptote"))
(if (file-exists-p "/usr/share/asymptote")
    (add-to-list 'load-path "/usr/share/asymptote/")
  (autoload 'asy-mode "asy-mode.el" "Asymptote Major Mode" t)
  (autoload 'lasy-mode "asy-mode.el" "Hybrid Asymptote/LaTeX Major Mode" t)
  (autoload 'asy-insinuate-latex "asy-mode.el" "Asymptote Insinuate LaTeX" t)
  (add-to-list 'auto-mode-alist '("\\.asy$" . asy-mode)))
    #+END_SRC
** Company
*** Basic
    #+BEGIN_SRC emacs-lisp
(use-package company
  :diminish company-mode
  :config
  (global-company-mode t)
  (require 'cc-mode)
  (setq company-idle-delay 0.001
        company-tooltip-idle-delay 0.001
        company-clang-arguments (list "-std=c++1z" "-Wall" "-Werror" "-Wpedantic -I./ -I./include/ -I../include/ -I../"))
  (delete 'company-semantic company-backends))
    #+END_SRC
*** Company Auctex
    #+BEGIN_SRC emacs-lisp 
(use-package company-auctex
  :defer 2
  :config
  (company-auctex-init))
    #+END_SRC
*** Yasnippet
    #+BEGIN_SRC emacs-lisp
                                        ;   (when (featurep 'yasnippet)
;; Add yasnippet support for all company backends
;; https://github.com/syl20bnr/spacemacs/pull/179
(defvar company-mode/enable-yas t
  "Enable yasnippet for all backends.")
(defun company-mode/backend-with-yas (backend)
  (if (or (not company-mode/enable-yas) (and (listp backend) (member 'company-yasnippet backend)))
      backend
    (append (if (consp backend) backend (list backend))
            '(:with company-yasnippet))))
(setq company-backends (mapcar #'company-mode/backend-with-yas company-backends))
(global-set-key (kbd "C-c y") 'company-yasnippet)
                                        ;)
    #+END_SRC
** Flycheck
   #+BEGIN_SRC emacs-lisp
(defun disable-flycheck-temporarily ()
  "Disables flycheck in current buffer."
  (interactive)
  (flycheck-mode -1))
(use-package flycheck
  :defer 2
  :config
  (setq flycheck-idle-change-delay 0.00001)
  (global-flycheck-mode)
  (add-hook 'org-src-mode-hook 'disable-flycheck-temporarily))
   #+END_SRC
** Web Development
   #+BEGIN_SRC emacs-lisp
(use-package web-mode
  :defer 2
  )
   #+END_SRC
** C/C++
*** Basic Settings
    #+BEGIN_SRC emacs-lisp
(setq c-default-style "stroustrup") ;; set style to "stroustrup"
(add-hook 'c-mode-common-hook 'hs-minor-mode)
    #+END_SRC
*** Debugging
    This is really cool. Try it with M-x gdb and choose the
    binary you want to debug.
    #+BEGIN_SRC emacs-lisp 
(setq  gdb-many-windows t
       gdb-show-main t)
    #+END_SRC
*** Packages
**** Company
     #+BEGIN_SRC emacs-lisp
(require 'cc-mode)
(define-key c-mode-map  [(tab)] 'company-complete)
(define-key c++-mode-map  [(tab)] 'company-complete)
(define-key c-mode-map (kbd "TAB") 'company-complete)
(define-key c++-mode-map (kbd "TAB") 'company-complete)
     #+END_SRC
***** C-headers
      #+BEGIN_SRC emacs-lisp

(use-package company-c-headers
  :defer 2
  :config
  (when (string= system-name "fed-lap")
    (add-to-list 'company-c-headers-path-system "/usr/include/c++/6.2.1/")
    (semantic-add-system-include "/usr/include/c++/6.2.1" 'c++-mode))
  (when (string= system-name "arch-desktop")
    (add-to-list 'company-c-headers-path-system "/usr/include/c++/6.1.1/"))
  (when (string= system-name "virtualbox")
    (add-to-list 'company-c-headers-path-system "/usr/lib64/gcc/x86_64-pc-linux-gnu/4.9.3/include/"))
  (add-to-list 'company-backends 'company-c-headers))

      #+END_SRC
**** Irony Mode
     #+BEGIN_SRC emacs-lisp
(require 'counsel)
(add-hook 'c++-mode-hook 'irony-mode)
(add-hook 'c-mode-hook 'irony-mode)

(defun my-irony-mode-hook()
  (define-key irony-mode-map [remap completion-at-point]
                                        ;'irony-completion-at-point-async)
    'counsel-irony)
  (define-key irony-mode-map [remap complete-symbol]
                                        ;'irony-completion-at-point-async))
    'counsel-irony))
(use-package irony
  :config
  (add-hook 'irony-mode-hook 'my-irony-mode-hook)
  (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options))
(use-package company-irony
  :config
  (add-hook 'irony-mode-hook 'company-irony-setup-begin-commands))
(use-package company-irony-c-headers
  :config
  (eval-after-load 'company
    '(add-to-list
      'company-backends '(company-irony-c-headers company-irony))))
     #+END_SRC
**** Rtags
     #+BEGIN_SRC emacs-lisp 
(use-package rtags
  :config
  (require 'rtags)
  (require 'company)
  (setq rtags-autostart-diagnostics t)
  (rtags-diagnostics)
  (setq rtags-completions-enabled t)
  (push 'company-rtags company-backends)
                                        ;    (require 'rtags-helm)
  (setq rtags-use-helm t)
  (add-hook 'c-mode-common-hook 'rtags-start-process-unless-running)
  (add-hook 'c++-mode-common-hook 'rtags-start-process-unless-running))
     #+END_SRC
**** YCMD
     #+BEGIN_SRC emacs-lisp
(when (file-exists-p "/home/einarelen/src/ycmd/ycmd/")
  (use-package ycmd
    :disabled t
    :diminish ycmd-mode
    :defer 2
    :config
    (add-hook 'c-mode-hook 'ycmd-mode)
    (add-hook 'c++-mode-hook 'ycmd-mode)
    (set-variable 'ycmd-server-command
                  '("python" "/home/einarelen/src/ycmd/ycmd/")))
  (use-package company-ycmd
    
    :defer 2
    :init
    (company-ycmd-setup)))

     #+END_SRC
**** Flycheck
     #+BEGIN_SRC emacs-lisp
(defun another-flycheck-rtags-setup()
  (interactive)
  (flycheck-select-checker 'rtags)
  (setq-local flycheck-highlighting-mode nil)
  (setq-local flycheck-check-syntax-automatically nil)
  (rtags-enable-standard-keybindings))
(when (featurep 'rtags)
  (require 'flycheck-rtags)
  (add-hook 'c-mode-common-hook 'another-flycheck-rtags-setup))
(setq-local flycheck-highlighting-mode nil)
;; (when (featurep 'irony)
;;   (use-package flycheck-irony

;;     :defer 2
;;     :config
;;     (add-hook 'flycheck-mode-hook #'flycheck-irony-setup)))
;; (when (and
;;        (featurep 'ycmd)
;;        (file-exists-p "/home/einarelen/src/ycmd/ycmd/"))
;;   (use-package flycheck-ycmd
;;   :defer 2
;;   :config
;;     (flycheck-ycmd-setup)))
     #+END_SRC
**** Function Args
     #+BEGIN_SRC emacs-lisp 
(use-package function-args
  :disabled t
  :diminish function-args-mode
  :defer 2
  :config
  (fa-config-default))
     #+END_SRC
**** Clang Format
     #+BEGIN_SRC emacs-lisp
(use-package clang-format
  
  :defer 2
  :bind (:map
         c-mode-map
         ("C-c f" . clang-format-region)
         ("C-c C-f" . clang-format-buffer)
         :map c++-mode-map
         ("C-c f" . clang-format-region)
         ("C-c C-f" . clang-format-buffer)))
     #+END_SRC
**** Semantic and Semantic Refactor
     #+BEGIN_SRC emacs-lisp
(require 'cc-mode)
;; (require 'semantic)
;; (global-semanticdb-minor-mode 1)
;; (global-semantic-idle-scheduler-mode 1)
;; (setq semantic-idle-scheduler-idle-time 0.01)
;; (semantic-mode 1)
;;     (require 'srefactor)
;;     (require 'srefactor-lisp)
;;     (define-key c-mode-map (kbd "M-<return>") 'srefactor-refactor-at-point)
;;     (define-key c++-mode-map (kbd "M-<return>") 'srefactor-refactor-at-point)
;; (semantic-add-system-include "/usr/include/boost/" 'c++-mode)
     #+END_SRC
*** C/C++ Keybindings
    #+BEGIN_SRC emacs-lisp
(define-key c-mode-map (kbd "C-c o") 'ff-find-other-file)
(define-key c++-mode-map (kbd "C-c o") 'ff-find-other-file)
(define-key c-mode-map (kbd "C-c C-c") 'comment-dwim-2)
(define-key c++-mode-map (kbd "C-c C-c") 'comment-dwim-2)
    #+END_SRC

** Emacs Lisp
*** Eldoc
    #+BEGIN_SRC emacs-lisp
(defun turn-off-eldoc ()
  "Temporarily turn off eldoc-mode."
  (eldoc-mode -1))
;; (use-package "eldoc"
;;   :diminish eldoc-mode
;;   :defer 2
;;   :init
;;   (progn (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode) (add-hook 'lisp-interaction-mode-hook 'turn-on-eldoc-mode) (add-hook 'ielm-mode-hook 'turn-on-eldoc-mode)))

    #+END_SRC

* Org Mode
** Basic Setup
   #+BEGIN_SRC emacs-lisp
(defun re-parse-configurations ()
  "Reparse the main configuration file"
  (interactive)
  (org-babel-load-file "~/.emacs.d/configurations.org"))
(use-package org
  :defer 1
  :init
  (setq org-src-preserve-indentation t)
  (setq org-src-tab-acts-natively t)
  :config
  (plist-put org-format-latex-options :scale 2.5)
  (add-to-list 'org-structure-template-alist
               '("la"
                 "#+BEGIN_EXPORT latex \n\\begin{align*}\n?\n\\end{align*}\n#+END_EXPORT"))
  (add-to-list 'org-structure-template-alist '("cc" "#+BEGIN_SRC C++ :flags -lginac -lcln -ldl :exports none\n?\n#+END_SRC"))
  (add-to-list 'org-structure-template-alist
               '("el"
                 "#+BEGIN_SRC emacs-lisp \n?\n#+END_SRC"))
  (add-to-list 'org-structure-template-alist '("eq" "\\begin{equation}\n?\n\\end{equation}\n"))
                                        ;(add-to-list 'org-structure-template-alist '("eq" "#+NAME:?\n#+BEGIN_EQUATION\n #+END_EQUATION\n")) 
  (add-to-list 'org-structure-template-alist '("th" "#+begin_theorem\n?\n#+end_theorem\n"))
  (add-to-list 'org-structure-template-alist '("ll" "@@latex:?@@"))
  (add-to-list 'org-structure-template-alist '("lh"
                                               "#+LATEX_HEADER: \\usepackage{physics, braket} \n\
                      ,#+LATEX_HEADER:\\usepackage[parfill]{parskip} \n\
                      ,#+LATEX_HEADER: \\usepackage{pxfonts} \n\
                      ,#+LATEX_HEADER: \\def\\dbar{{\\mathchar'26\\mkern-12mu d}}\n\
                      ,#+LATEX_HEADER: \\newcommand{\\hbat}{\\hbar}\n\
                      ,#+LATEX_HEADER: \\newcommand{\\vhat}[1]{\\vb{\\hat{#1}}}\n\
                      ,#+LATEX_HEADER: \\newcommand{\\ehat}[1]{\\vhat{e}_{#1}}\n\
                      ,#+LATEX_HEADER: \\newcommand{\\qfrac}[2]{{\\qty(\\frac{#1}{#2})}}\n\
                      ,#+LATEX_HEADER: \\newcommand{\\ofrac}[1]{\\frac{1}{#1}}\n\
                      ,#+LATEX_HEADER: \\newcommand{\\onfrac}[1]{\\frac{-1}{#1}}\n\
                      ,#+OPTIONS: num:6 H:6"))
  (add-to-list 'org-structure-template-alist "ll" "@@latex:")
  (setq org-default-notes-file "~/.emacs.d/org/refile.org"
        org-use-fast-todo-selection t
        org-src-window-setup 'current-window)
  :bind (("\C-cl" . org-store-link)
         ("\C-ca" . org-agenda)
         ("\C-cb" . org-iswitchb)
         ("C-c c" . org-capture)
         :map org-mode-map
         ("C-c ." . org-timestamp)
         ("\M-\C-g" . org-plot/gnuplot)))

   #+END_SRC
** Todo
   #+BEGIN_SRC emacs-lisp
(setq org-todo-keywords
      (quote ((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d)")
              (sequence "WAITING(w@/!)" "HOLD(h@/!)" "|" "CANCELLED(c@/!)" "PHONE" "MEETING"))))
(setq org-todo-keyword-faces
      (quote (("TODO" :foreground "red" :weight bold)
              ("NEXT" :foreground "blue" :weight bold)
              ("DONE" :foreground "forest green" :weight bold)
              ("WAITING" :foreground "orange" :weight bold)
              ("HOLD" :foreground "magenta" :weight bold)
              ("CANCELLED" :foreground "forest green" :weight bold)
              ("MEETING" :foreground "forest green" :weight bold)
              ("PHONE" :foreground "forest green" :weight bold))))
(setq org-todo-state-tags-triggers
      (quote (("CANCELLED" ("CANCELLED" . t))
              ("WAITING" ("WAITING" . t))
              ("HOLD" ("WAITING") ("HOLD" . t))
              (done ("WAITING") ("HOLD"))
              ("TODO" ("WAITING") ("CANCELLED") ("HOLD"))
              ("NEXT" ("WAITING") ("CANCELLED") ("HOLD"))
              ("DONE" ("WAITING") ("CANCELLED") ("HOLD")))))
   #+END_SRC
** Agenda
   #+BEGIN_SRC emacs-lisp
(setq org-agenda-dim-blocked-tasks nil)
(setq org-agenda-compact-blocks t)
   #+END_SRC
** Org-plot
   #+BEGIN_SRC emacs-lisp 
   #+END_SRC
** Calendar
   #+BEGIN_SRC emacs-lisp
(use-package calfw
  
  :defer 2
  :init
  (require 'calfw-org))
(use-package org-gcal
  
  :defer 2
  :config
  (setq org-gcal-client-id "393897935817-6f7lc36osa9o9kqc10u65hhstu8idp4o.apps.googleusercontent.com" org-gcal-client-secret "GIgx5Re1yKKboMSPn1aUREs8" org-gcal-file-alist '(("einar.elen@gmail.com" . "/home/einarelen/ownCloud/org/cal/main.org"))))
  ;;; https://calendar.google.com/calendar/ical/einar.elen%40gmail.com/private-97060e03f66653b16c4d6c7164f8d633/basic.ics
   #+END_SRC
** Babel
   #+BEGIN_SRC emacs-lisp
(require 'ob-C)
(org-babel-do-load-languages
 'org-babel-load-languages
 '((C . t) (emacs-lisp . t) (python . t) (sh . t) (gnuplot . t)))
   #+END_SRC
** Refile and Capture
   #+BEGIN_SRC emacs-lisp
(setq org-capture-templates
      (quote (("t" "todo" entry (file "~/.emacs.d/org/refile.org")
               "* TODO %?\n%U\n%a\n" :clock-in t :clock-resume t)
              ("r" "respond" entry (file "~/.emacs.d/org/refile.org")
               "* NEXT Respond to %:from on %:subject\nSCHEDULED: %t\n%U\n%a\n" :clock-in t :clock-resume t :immediate-finish t)
              ("n" "note" entry (file "~/.emacs.d/org/refile.org")
               "* %? :NOTE:\n%U\n%a\n" :clock-in t :clock-resume t)
              ("j" "Journal" entry (file+datetree "~/.emacs.d/org/diary.org")
               "* %?\n%U\n" :clock-in t :clock-resume t)
              ("w" "org-protocol" entry (file "~/.emacs.d/org/refile.org")
               "* TODO Review %c\n%U\n" :immediate-finish t)
              ("m" "Meeting" entry (file "~/.emacs.d/org/refile.org")
               "* MEETING with %? :MEETING:\n%U" :clock-in t :clock-resume t)
              ("p" "Phone call" entry (file "~/.emacs.d/org/refile.org")
               "* PHONE %? :PHONE:\n%U" :clock-in t :clock-resume t)
              ("h" "Habit" entry (file "~/.emacs.d/org/refile.org")
               "* NEXT %?\n%U\n%a\nSCHEDULED: %(format-time-string \"%<<%Y-%m-%d %a .+1d/3d>>\")\n:PROPERTIES:\n:STYLE: habit\n:REPEAT_TO_STATE: NEXT\n:END:\n")
              ("d" "daily" entry (file+datetree "~/.emacs.d/org/dailies/what-normal-beings-do-and-dailies.org")
               ""))))
(setq org-refile-targets (quote ((nil :maxlevel . 9)
                                 (org-agenda-files :maxlevel . 9))))
(setq org-refile-use-outline-path t)
(setq org-refile-allow-creating-parent-nodes 'confirm)
(setq org-indirect-buffer-display 'current-window)
   #+END_SRC
** Daily Checks
   #+BEGIN_SRC emacs-lisp
(defun daily-checklist () "Open the daily checklist file"
       (interactive)
       (find-file "~/.emacs.d/org/dailies/what-normal-beings-do-and-dailies.org")
       )
(setq org-publish-project-alist
      '(("dailies-html"
         :base-directory "~/.emacs.d/org/dailies/"
         :base-extension "org"
         :publishing-directory "~/.emacs.d/org/html/"
         :publishing-function org-html-publish-to-html)
        ("dailies-pdf"
         :base-directory "~/.emacs.d/org/dailies/"
         :base-extension "org"
         :publishing-directory "~/.emacs.d/org/tex/"
         :publishing-function org-latex-publish-to-pdf)))
   #+END_SRC
** Publish
   #+BEGIN_SRC emacs-lisp
(require 'ox-latex)

   #+END_SRC
* Communication
** Email
*** Misc
    #+BEGIN_SRC emacs-lisp
(require 'gnus-dired)
;; make the `gnus-dired-mail-buffers' function also work on
;; message-mode derived modes, such as mu4e-compose-mode
(defun gnus-dired-mail-buffers ()
  "Return a list of active message buffers."
  (let (buffers)
    (save-current-buffer
      (dolist (buffer (buffer-list t))
        (set-buffer buffer)
        (when (and (derived-mode-p 'message-mode)
                   (null message-sent-message-via))
          (push (buffer-name buffer) buffers))))
    (nreverse buffers)))
(setq gnus-dired-mail-mode 'mu4e-user-agent)
(add-hook 'dired-mode-hook 'turn-on-gnus-dired-mode)
    #+END_SRC
*** Mu4e
    #+BEGIN_SRC emacs-lisp
(when (file-exists-p "/usr/local/bin/mu")
  (add-to-list 'load-path "~/.emacs.d/mu4e/")
  (when (require 'mu4e nil 'noerror)
    (use-package mu4e
      :defer 2
      :config
      (require 'mu4e-contrib)
      (setq mu4e-maildir "~/Maildir"
            mu4e-drafts-folder "/[Gmail].Drafts"
            mu4e-sent-folder   "/[Gmail].Sent Mail"
            mu4e-trash-folder  "/[Gmail].Trash"
            mu4e-sent-messages-behavior 'delete
            mu4e-maildir-shortcuts
            '(("/INBOX"               . ?i)
              ("/[Gmail].Sent Mail"   . ?s)
              ("/[Gmail].Trash"       . ?t)
              ("/[Gmail].All Mail"    . ?a))
            mu4e-get-mail-command "offlineimap"
            mu4e-update-interval 450)
      (require 'smtpmail)
      (setq message-send-mail-function 'smtpmail-send-it
            smtpmail-stream-type 'starttls
            smtpmail-default-smtp-server "smtp.gmail.com"
            smtpmail-smtp-server "smtp.gmail.com"
            smtpmail-smtp-service 587)
      (setq mu4e-html2text-command 'mu4e-shr2text)
      (defun run-mu4e-after-init ()      (mu4e))
                                        ;(add-hook 'after-init-hook 'run-mu4e-after-init)
      )))
    #+END_SRC
*** Gnus
** IRC
   #+BEGIN_SRC emacs-lisp
   #+END_SRC
* Utilities
** Lastpass
   #+BEGIN_SRC emacs-lisp
(defun lp-login (login-name)
  "Testing"
  (interactive "sLastpass account: ")
  (shell-command (concat "lpass login " login-name)))
(defun lp-ls
    (&optional args &optional output-buffer &optional error-buffer)
  "Derp"
  (interactive "s(Optional) Groupname:
   s(Optional) Output buffer: ")
  (if (string= output-buffer "")
      (shell-command (concat "lpass ls " args))
    (shell-command (concat "lpass ls " args) output-buffer error-buffer)))

(defun lp-show (name &optional output-buffer &optional error-buffer)
  "darp"
  (interactive "sName: ")
  (if (string= output-buffer "") (shell-command (concat "lpass show" name))(shell-command (concat "lpass show " name) output-buffer error-buffer)))

(defun lp-insert-show (name &optional)
  "dlarp"
  (interactive "sName: ") (lp-show name t))
(defun lp-insert-ls (&optional args)
  "Derp"
  (interactive "s(Optional) Groupname:") (lp-ls args t))
(defun lp-get-password (name &optional output-buffer &optional error-buffer)
  (interactive "sName: ")
  (lp-show (concat name "| grep password | grep -v sudo | cut -d\" \" -f2 ") output-buffer error-buffer))

(defun lp-insert-password (name)
  (interactive "sName: ")
  (lp-get-password name t)
  )
   #+END_SRC
** Other stuff
   #+BEGIN_SRC emacs-lisp
(defun switch-configuration() "Cycle between current buffer, configuration file and dailies" (interactive)
       (when (and (not (boundp 'return-is-next)) (and (not (boundp 'stored-buffer)) (and (not (boundp 'dailies-is-next))) (not (boundp 'current-buffer))))
         (setq stored-buffer nil current-buffer nil return-is-next nil dailies-is-next nil)
         )
       (when (not (bound-and-true-p stored-buffer))
         (setq stored-buffer (current-buffer)
               dailies-is-next t vars-are-set t)
         (configuration-file)
         )
       (when (and dailies-is-next (not vars-are-set))
         (setq return-is-next t vars-are-set t dailies-is-next nil)
         (daily-checklist)
         )
       (when (and return-is-next (not vars-are-set))
         (let ((tmp stored-buffer))
           (setq stored-buffer nil return-is-next nil)
           (switch-to-buffer tmp)
           )
         )
       (setq vars-are-set nil)
       )
(defun switch-to-mu4e() "Cycle to mu4e and back without turning it off"
       (interactive)
       (when (and (not (boundp 'mu4e-is-next)) (not (boundp 'return-from-mu4e-is-next)))
         (setq return-from-mu4e-is-next nil mu4e-stored-buffer nil mu4e-is-next t))

       (when (and (bound-and-true-p mu4e-stored-buffer)
                  (bound-and-true-p return-from-mu4e-is-next))
         (let ((tmp mu4e-stored-buffer))
           (setq mu4e-stored-buffer nil mu4e-is-next t return-from-mu4e-is-next nil)
           (switch-to-buffer tmp)
           ))

       (when (and (not (bound-and-true-p return-from-mu4e-is-next))
                  (and (not (bound-and-true-p mu4e-stored-buffer))
                       (bound-and-true-p mu4e-is-next)))
         (setq mu4e-stored-buffer (current-buffer)
               return-from-mu4e-is-next t mu4e-is-next nil) (mu4e))

       )
(global-set-key (kbd "<f7>") 'switch-to-mu4e)
(global-set-key (kbd "<f8>") 'switch-configuration)
   #+END_SRC
* Experimental
** Emacs Lisp
   #+BEGIN_SRC emacs-lisp
(semantic-mode -1)
(add-to-list 'load-path "~/.emacs.d/org-notes-mode/")
(add-to-list 'load-path "~/.emacs.d/org-notes-mode/meson-ide/")
(let ((default-directory "~/.emacs.d/org-notes-mode/meson-ide/"))
  (org-babel-tangle-file "meson-ide.org")
  (save-window-excursion
    (let (to-delete (find-file "~/msi/meson-ide.el"))
      (indent-buffer)
      (load-file "meson-ide.el")
      )))
(require 'ert)
(require 'org-notes)
(require 'meson-ide)
(ert-delete-all-tests)
(meson-ide-setup)
   #+END_SRC
** Elisp Development
   #+BEGIN_SRC emacs-lisp 
(defun disable-smartparens ()
  (interactive)
  "Disables smartparens."
  (turn-off-smartparens-mode))
(defun enable-paredit ()
  (interactive)
  "Enables paredit."
  (paredit-mode t))
(add-hook 'emacs-lisp-mode-hook 'disable-smartparens)
(add-hook 'emacs-lisp-mode-hook 'enable-paredit)
(defun foo ()
  "Foo." (interactive)
  (if t
      (message "Foo.")
    (message "Not implemented")))

(defvar lisp-modes '(emacs-lisp-mode
                     inferior-emacs-lisp-mode
                     ielm-mode
                     lisp-mode
                     inferior-lisp-mode
                     lisp-interaction-mode
                     slime-repl-mode))
(defvar lisp-mode-hooks
  (mapcar (function
           (lambda (mode)
             (intern
              (concat (symbol-name mode) "-hook"))))
          lisp-modes))
(defsubst hook-into-modes (func &rest modes)
  (dolist (mode-hook modes) (add-hook mode-hook func)))
(use-package info-look
  :commands info-lookup-add-help)
(use-package lisp-mode
  :defer t
  :preface
  (defvar smile-mode nil)
  (defvar lisp-mode-initialized nil)
  (defun my-lisp-mode-hook ()
    (unless lisp-mode-initialized
      (setq lisp-mode-initialized t)
      (use-package redshank
        :diminish redshank-mode)
      (use-package elisp-slime-nav
        :diminish elisp-slime-nav-mode)
      (use-package edebug)
      (use-package eldoc
        :diminish eldoc-mode
        :commands eldoc-mode
        :config
        (use-package eldoc-extension
          :disabled t
          :defer t
          :init
          (add-hook 'emacs-lisp-mode-hook #'(lambda () (require 'eldoc-extension)) t))
        (eldoc-add-command 'paredit-backward-delete 'paredit-close-round))
      (use-package cldoc
        :commands (cldoc-mode turn-on-cldoc-mode)
        :diminish cldoc-mode)
      (use-package ert
        :bind ("C-c e t" . ert-run-tests-interactively))
      (use-package elint
        :commands 'elint-initialize
        :preface
        (defun elint-current-buffer ()
          (interactive)
          (elint-initialize)
          (elint-current-buffer))
        :config
        (add-to-list 'elint-standard-variables 'current-prefix-arg)
        (add-to-list 'elint-standard-variables 'command-line-args-left)
        (add-to-list 'elint-standard-variables 'buffer-file-coding-system)
        (add-to-list 'elint-standard-variables 'emacs-major-version)
        (add-to-list 'elint-standard-variables 'window-system))
      (use-package highlight-cl
        :disabled t
        :init
        (mapc (function
               (lambda (mode-hook)
                 (add-hook mode-hook 'highlight-cl-add-font-lock-keywords)))
              lisp-mode-hooks))
      (defun my-elisp-indent-or-complete (&optional arg)
        (interactive "p")
        (call-interactively 'lisp-indent-line)
        (unless (or (looking-back "\\s-*") (bolp)
                    (not (looking-back "[-A-Za-z0-9_*+/=<>!?]+")))
          (call-interactively 'lisp-complete-symbol)))
      (defun my-lisp-indent-or-complete (&optional arg)
        (interactive "p")
        (if (or (looking-back "^\\s-*") (bolp))
            (call-interactively 'lisp-indent-line)
          (call-interactively 'slime-indent-and-complete-symbol)))
      (defun my-byte-recompile-file ()
        (save-excursion
          (byte-recompile-file buffer-file-name)))
      (use-package testcover
        :commands testcover-this-defun)
      (mapc (lambda (mode)
              (info-lookup-add-help
               :mode mode
               :regexp "[^][()'\" \t\n]+"
               :ignore-case t
               :doc-spec '(("(ansicl)Symbol Index" nil nil nil))))
            lisp-modes))
    (auto-fill-mode 1)
    (paredit-mode 1)
    (redshank-mode 1)
    (elisp-slime-nav-mode 1)
    (local-set-key (kbd "<return>") 'paredit-newline)
    (bind-key "<tab>" #'my-elisp-indent-or-complete emacs-lisp-mode-map)
    (add-hook 'after-save-hook 'check-parens nil t)
    (unless (memq major-mode
                  '(emacs-lisp-mode inferior-emacs-lisp-mode ielm-mode))
                                        ;        (turn-on-cldoc-mode)
      (bind-key "M-q" #'slime-reindent-defun lisp-mode-map)
      (bind-key "M-l" #'slime-selector lisp-mode-map)))
  :init
  (apply #'hook-into-modes 'my-lisp-mode-hook lisp-mode-hooks))

(use-package pp-c-l
  :commands pretty-control-l-mode
  :init
  (add-hook 'prog-mode-hook 'pretty-control-l-mode))
(bind-key "C-x C-e" #'pp-eval-last-sexp)
   #+END_SRC
* To be integrated
  #+BEGIN_SRC emacs-lisp
(require 'xah-replace-pairs)
(defvar multireplace-list nil "Nah.")
(defvar multireplace-pair-first nil "nah.")
(defvar multireplace-pair-second nil "nah.")
(defun multireplace (first second)
  (interactive "r")
  (while (yes-or-no-p "More pairs?")
    (print "1")
    (setq multireplace-pair-first (read-from-minibuffer "First:"))
    (print multireplace-pair-first)
    (setq multireplace-pair-second (read-from-minibuffer "Second:"))
    (print multireplace-pair-second)
    (setq multireplace-list (cons (list multireplace-pair-first multireplace-pair-second) multireplace-list))
    (setq multireplace-pair-first nil multireplace-pair-second nil))
  (xah-replace-pairs-region first second multireplace-list)
  (setq multireplace-list nil multireplace-pair-first nil multireplace-pair-second nil))

(require 'multiple-cursors)
(global-set-key (kbd "C-M-.") 'mc/mark-next-like-this)
(require 'spaceline-config)
(use-package spaceline-config
  :init (spaceline-spacemacs-theme))
(require 'spaceline-config)
(spaceline-spacemacs-theme)
(spaceline-helm-mode t)
(spaceline-info-mode t)
(use-package all-the-icons
  :config (spaceline-all-the-icons-theme)
    ;;; Remember (all-the-icons-install-fonts)
  )
  #+END_SRC
  #+BEGIN_SRC emacs-lisp
(require 'cmake-mode)
(require 'rtags)
(require 'cmake-ide)
(require 'cmake-font-lock)
(require 'dumb-jump)
(autoload 'cmake-font-lock-activate "cmake-font-lock" nil t)
(add-hook 'cmake-mode-hook 'cmake-font-lock-activate)
(cmake-ide-setup)
(require 'bind-key)
(bind-key "M-." 'rtags-find-symbol-at-point c++-mode-map)
(bind-key "M-." 'rtags-find-symbol-at-point c-mode-map)
(bind-key "M-," 'rtags-location-stack-back c-mode-map)
(bind-key "M-," 'rtags-location-stack-back c++-mode-map)
(setq rtags-use-helm t)
(bind-key "C-x ." 'rtags-find-symbol c-mode-map)
(bind-key "C-x ." 'rtags-find-symbol c++-mode-map)
(global-prettify-symbols-mode t)
(bind-key "<f9>" 'eshell)
(require 'expand-region)
(global-set-key (kbd "C-=") 'er/expand-region)
  #+END_SRC
  #+BEGIN_SRC emacs-lisp 
;;   (require 'exwm)
;;   (require 'exwm-config)
;;   (define-key exwm-mode-map (kbd "C-c C-j") 'exwm-input-grab-keyboard)
;;   (exwm-enable)
;; (message "ted")
  #+END_SRC
  #+BEGIN_SRC emacs-lisp 
(defun xah-change-bracket-pairs ( *fromType *toType *begin *end)
  "Change bracket pairs from one type to another on current line or selection.
          For example, change all parenthesis () to square brackets [].

          When called in lisp program, *begin *end are region begin/end position, *fromType or *toType is a string of a bracket pair. \u2056 \"()\",  \"[]\", etc.
          URL `http://ergoemacs.org/emacs/elisp_change_brackets.html'
          Version 2016-11-04"
  (interactive
   (let ((-bracketsList
          '("() paren"
            "{} braces" "[] square"
            "<> greater"
            "\u201c\u201d curly quote"
            "\u2018\u2019 single"
            "\u2039\u203a french"
            "«» double french"
            "\u300c\u300d corner"
            "\u300e\u300f double corner"
            "\u3010\u3011 LENTICULAR"
            "\u3016\u3017 white LENTICULAR"
            "\u300a\u300b double angle"
            "\u3008\u3009 angle "
            "\u3014\u3015 TORTOISE"
            "\u2985\u2986 white paren"
            "\u301a\u301b white square"
            "\u2983\u2984 white braces"
            "\u2329\u232a"
            "\u2991\u2992"
            "\u29fc\u29fd"
            "\u27e6\u27e7 math square"
            "\u27e8\u27e9 math angle"
            "\u27ea\u27eb"
            "\u27ee\u27ef"
            "\u27ec\u27ed"
            "\u275b\u275c"
            "\u275d\u275e"
            "\u2768\u2769"
            "\u276a\u276b"
            "\u2774\u2775"
            "\u276c\u276d"
            "\u276e\u276f"
            "\u2770\u2771"
            "   none"
            )))
     (list
      (helm-comp-read "Replace this:" -bracketsList )
      (helm-comp-read "To:" -bracketsList )
      (if (use-region-p) (region-beginning) nil)
      (if (use-region-p) (region-end) nil))))
  (save-excursion
    (save-restriction
      (when (null *begin)
        (setq *begin (line-beginning-position))
        (setq *end (line-end-position)))
      (narrow-to-region *begin *end)
      (let ( (case-fold-search nil)
             (-fromLeft (substring *fromType 0 1))
             (-toLeft (if (string-equal (substring *toType 0 1) " ")
                          (progn "")
                        (substring *toType 0 1)))
             (-fromRight (substring *fromType 1 2))
             (-toRight (if (string-equal (substring *toType 1 2) " ")
                           (progn "")
                         (substring *toType 1 2))))
        (progn
          (goto-char (point-min))
          (while (search-forward -fromLeft nil t)
            (overlay-put (make-overlay (match-beginning 0) (match-end 0)) 'face 'highlight)
            (replace-match -toLeft 'FIXEDCASE 'LITERAL)))
        (progn
          (goto-char (point-min))
          (while (search-forward -fromRight nil t)
            (overlay-put (make-overlay (match-beginning 0) (match-end 0)) 'face 'highlight)
            (replace-match -toRight 'FIXEDCASE 'LITERAL)))))))
(require 'server)
(unless (server-running-p)
  (server-start))
(load-theme 'spacemacs-dark t)

  #+END_SRC
