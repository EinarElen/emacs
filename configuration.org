#+AUTHOR: Einar Elén
#+EMAIL: einar.elen@gmail.com
#+OPTIONS: toc:3 html5-fancy:t org-html-preamble:nil
#+HTML_DOCTYPE_HTML5: t
#+PROPERTY: header-args :tangle yes
#+STARTUP: noinlineimages

* Emacs
:PROPERTIES:
:ID:       98e63f19-0f9f-4d64-8679-f73f25010c4e
:END:
** Definitions and Variables
:PROPERTIES:
:ID:       7ace9abf-9530-423a-927f-a024a8c67df5
:END:
*** Definitions                                                   :ignore:
:PROPERTIES:
:ID:       3e2c6e03-2178-42d9-be36-b0f978dbaecd
:END:
These exist because the emacs byte-compiler cannot be sure
that these variables and functions are actually defined. As
we know that they are, we can tell it to relax!

You should in general never need to care about this
section. We also define a customization group called [[elisp:(customize-group 'elib)][`elib']]
that can be used for any customizations we create later.

#+BEGIN_SRC emacs-lisp 
(eval-when-compile
  (defvar mac-command-modifier)
  (defvar flycheck-highlighting-mode)
  (defvar flycheck-check-syntax-automatically)
  (defvar TeX-view-program-selection)
  (defvar elib-helm-tex-alist)
  (defvar TeX-view-program-list)
  (defvar with-editor-emacsclient-executable)
  (defvar compilation-read-command)
  (setq ad-redefinition-action 'accept))
#+END_SRC
** Improve Basic Emacs Experience
:PROPERTIES:
:ID:       0c5f0b2e-abdf-41c3-90d1-fab40849003d
:END:
*** Configuration file
:PROPERTIES:
:ID:       03a6d1fd-eb0e-4df0-919b-640c5e9e9af0
:END:
Creates a function called [[elisp:(describe-function
 'configuration/gtd-file-or-restart-emacs)][`configuration/gtd-file-or-restart-emacs']] which by default
returns you to this file and binds it to "<f8>" globally. If
you give it one universal argument, it returns you to [[elisp:(describe-variable
 'user-org-gtd-inbox)][`user-org-gtd-inbox']], with two universal arguments to
#+BEGIN_SRC emacs-lisp
(defun configuration/gtd-file-or-restart-emacs (x)
  (interactive "p")
  (message "%s" current-prefix-arg)
  (cond ((equal current-prefix-arg '(4))
         (find-file user-org-gtd-inbox))
        ((equal current-prefix-arg '(16))
         (find-file elib-user-org-directory))
        ((equal current-prefix-arg '(64))
         (restart-emacs))
        (t (find-file config-file-file-name))))

(global-set-key (kbd "<f8>") 'configuration/gtd-file-or-restart-emacs)
#+END_SRC
*** Additional Settings
:PROPERTIES:
:ID:       99d4c001-1607-49f3-a799-2297e4f500af
:END:
Change the default location of [[elisp:(describe-variable
'user-emacs-directory)][`user-emacs-directory']] so that it
does not clutter our configuration directory. Use
[[elisp:(describe-variable
'user-emacs-config-directory)][`user-emacs-config-directory']]
instead for the configuration directory.

#+BEGIN_SRC emacs-lisp
(setq user-emacs-directory
      (file-name-as-directory
       (expand-file-name
        (concat
         user-emacs-config-directory
         "machine-local-files"))))
#+END_SRC


Disable scroll bar and toolbar, disable the keys that hide
emacs (they are easy to hit on accident which is /really/
annoying). Also, show column and line number of the cursor
in the modeline.
#+BEGIN_SRC emacs-lisp
;; Does not make sense in a terminal
(when (display-graphic-p)
  (scroll-bar-mode -1)
  (tool-bar-mode -1))
;; Way too easy to hit by accident
(global-unset-key (kbd "C-x C-z"))
(global-unset-key (kbd "C-z"))
(setq column-number-mode t
      line-number-mode t)
#+END_SRC

Turn on word-wrapping in each buffer and make it so that
commands operate on visual lines rather than logical ones.
#+BEGIN_SRC emacs-lisp
(global-visual-line-mode t)
#+END_SRC

Highlight the current line
#+BEGIN_SRC emacs-lisp
(global-hl-line-mode t)
#+END_SRC

Flash the screen rather than making noise when complaining.
#+BEGIN_SRC emacs-lisp
(setq visible-bell t)
#+END_SRC
Show a clock!
#+BEGIN_SRC emacs-lisp
(display-time)
#+END_SRC
Always answer yes or no questions with just y or n, yes or no is
annoying to type. Emacs graphical pop-ups sometimes causes the program
to hang so I disable it.
#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
(setq use-dialog-box nil)
#+END_SRC
Enable syntax highlighting in all modes where it is possible!
#+BEGIN_SRC emacs-lisp
(global-font-lock-mode t)
#+END_SRC
If we are using an emacs with native line-numbering, use it!
Otherwise, use nlinum for line-numbering.
#+BEGIN_SRC emacs-lisp
(if (boundp 'display-line-numbers)
   (progn
     (global-display-line-numbers-mode t)
     (setq display-line-numbers-widen t)
     (setq display-line-numbers-width 4)
     (setq display-line-numbers 'visual)
     )

  (use-package nlinum
    :defer 3
    :preface
    (defun disable-nlinum-mode-hook () (nlinum-mode -1))
    :config
    (global-nlinum-mode t)
    (add-hook 'pdf-view-mode-hook 'disable-nlinum-mode-hook)))
#+END_SRC

Other stuff which may or may not work...
#+BEGIN_SRC emacs-lisp
(use-package tramp
  :defer 3
  :config
  (setq tramp-default-method "ssh"))
(setq backup-directory-alist `((".*" . ,temporary-file-directory))
      auto-save-file-name-transforms `((".*" ,temporary-file-directory t))
      backup-by-copying t    ;; Don't delink hard-links
      version-control t      ;; use version numbers on backups
      delete-old-versions t  ;; Automatically delete excess backups
      kept-new-versions 20   ;; how many of the newest versions to keep
      kept-old-versions 5    ;; and how many of the old
      )

(setq ;gc-cons-threshold 100000000
 inhibit-startup-message nil
 history-length t
 history-delete-duplicates t
 version-control t
 x-stretch-cursor nil)
(setq-default
 fill-column 60
 cursor-type 'hbar)
(setq mac-command-modifier 'meta)
#+END_SRC
*** Window Management
:PROPERTIES:
:ID:       3bdf2a82-7310-42a2-886d-5f49ac718167
:END:
Winner allows you to restore previous window configurations and jump
around in the window configuration history using C-c <left> and C-c
<right> (the arrow keys).

Try it out by typing C-x 3, C-x o, C-x b (choose some buffer) and then
C-c <left> twice to get back! Then try C-c <right> once and C-c <left
again to return!


#+BEGIN_SRC emacs-lisp
(use-package winner
  :defer nil
  :bind (("C-c <left>" . winner-undo)
	 ("C-c <right>" . winner-redo))
  :config
  (winner-mode t))
;; (use-package switch-window
;;   :defer 2
;;   :bind (("C-x o" . switch-window)))
;;
#+END_SRC

**** Clipmon
:PROPERTIES:
:ID:       da180b8f-e514-4a17-a313-10c86c59023a
:END:
Clipmon tries to help emacs synchronize copies and
pastes between emacs and the rest of your operating
system.
#+BEGIN_SRC emacs-lisp
(use-package clipmon
  :defer 4
  :config (setq clipmon-autoinsert-timeout nil
		clipmon-autoinsert-sound nil
		clipmon-autoinsert-color nil
		clipmon-transform-suffix nil)
  (clipmon-mode))
#+END_SRC
****  Windmove
:PROPERTIES:
:ID:       fdd6346c-192c-4e63-b10a-a3e665812ffa
:END:
Windmove keybindings allows you to switch between your
windows with shift + arrow keys which can be handy when
you're tired.
#+BEGIN_SRC emacs-lisp
(use-package windmove
  :after org
  :hook ((org-shiftup-final-hook . windmove-up)
         (org-shiftdown-final-hook . windmove-down)
         (org-shiftleft-final-hook . windmove-left)
         (org-shiftright-final-hook . windmove-right))
  :config
  (windmove-default-keybindings))


#+END_SRC
**** Zygospore
:PROPERTIES:
:ID:       d02288e4-e02c-4269-8653-eaa4f24b96d8
:END:
Zygospore replaces the default kill all other windows with
a version which lets you go back if you use it again.
#+BEGIN_SRC emacs-lisp
(use-package zygospore
  :defer 1
	 :bind (("C-x 1" . zygospore-toggle-delete-other-windows)))
#+END_SRC
**** Help window management
:PROPERTIES:
:ID:       8652fd88-e184-46a9-ba72-25f6223c0994
:END:
By default help windows don't put you in them
immediately, I'd rather they did so they can be killed
quickly after reading.
#+BEGIN_SRC emacs-lisp
(setq help-window-select t)
#+END_SRC


*** Hydra
:PROPERTIES:
:ID:       245eb695-0abf-435d-aab8-eaf1e5a1f8de
:END:
Hydra is a package which allows fancy keyboard bindings. The
only one which currently exists is C-M-o for
window 	management.
#+BEGIN_SRC emacs-lisp
(use-package hydra
  :defer 2
  ;;        ("C-M-s" . hydra-spelling/body))
  :commands (hydra-add-font-lock
             hydra-default-pre hydra-keyboard-quit
             hydra--call-interactively-remap-maybe
             hydra-show-hint hydra-set-transient-map)
  :config
  (define-key global-map (kbd "C-M-o")  'hydra-window/body)
  (hydra-add-font-lock)
  (use-package ace-window)
  (use-package transpose-frame)
  (use-package default-text-scale
    :config
    (default-text-scale-mode t))
  (defhydra hydra-window ()
    "Window management"
    ("a" windmove-left)
    ("s" windmove-down)
    ("d" windmove-right)
    ("w" windmove-up)
    ("3" (lambda ()
	   (interactive)
	   (split-window-right)
	   (windmove-right))
     "Vertical")
    ("2" (lambda ()
	   (interactive)
	   (split-window-below)
	   (windmove-down))
     "Horizontal")
    ("t" transpose-frame "'")
    ("1" delete-other-windows "Delete All" :color blue)
    ("A" ace-window "Ace")
    ("S" ace-swap-window "Swap")
    ("k" ace-delete-window "Kill")
    ("i" ace-delete-other-windows "Ace-max")
    ("b" helm-mini "Buffers")
    ("q" nil "cancel" :color blue)
    ("M-t" text-scale-decrease "Local Text Scale--")
    ("C-t" text-scale-increase
     "Local Text Scale++")
    ("C-f" default-text-scale-increase
     "Global Text Scale++")
    ("M-f" default-text-scale-decrease "Global Text Scale--"))

  (eval-after-load "flyspell"
    (defhydra hydra-spelling (:color blue)
      "^
  ^Spelling^          ^Errors^            ^Checker^
  ^────────^──────────^──────^────────────^───────^───────
  _q_ quit            _<_ previous        _c_ correction
  ^^                  _>_ next            _d_ dictionary
  ^^                  _f_ check           _m_ mode
  ^^                  ^^                  ^^
  "
      ("q" nil)
      ("<" flyspell-correct-previous :color pink)
      (">" flyspell-correct-next :color pink)
      ("c" ispell)
      ("d" ispell-change-dictionary)
      ("f" flyspell-buffer)
      ("m" flyspell-mode)) )
  (print "")
  )


#+END_SRC

*** Mac-specific stuff
:PROPERTIES:
:ID:       2a98cf18-bc88-4bd1-95d0-44473338cd63
:END:
Add latex, bash, and much more support because they are in
weird places on Mac OS systems.  Because why wouldn't they
be.
#+BEGIN_SRC emacs-lisp
(if (equal system-type 'darwin)
    (progn (add-to-list 'exec-path "/usr/local/bin/")
           (add-to-list 'exec-path "/Library/TeX/texbin/pdflatex")
           (setenv "PATH" (concat "/usr/local/bin:/Library/TeX/texbin/:" (getenv "PATH")))))
#+END_SRC
*** Restarting Emacs
:PROPERTIES:
:ID:       3d5b1d39-5979-4951-b3ff-044537807d60
:END:
#+BEGIN_SRC emacs-lisp
(defun restart-emacs-with-arguments ()
  (interactive)
  (let ((response
         (read-string "Arguments to new emacs: "
                      )))
    (restart-emacs '(response))))
(defun restart-emacs-debug ()
  (interactive)
  ""
  (restart-emacs '("--debug-init")))
(use-package restart-emacs
  :init

  (defun restart-emacs-quick ()
    (interactive)
    ""
    (restart-emacs '("-Q")))

  :config

  (define-key-after
    global-map
    [menu-bar restart-emacs-menu]
    (cons "Restart Emacs"
          (make-sparse-keymap
           "Restart-emacs-menu-keymap"))
    'tools)

  (define-key global-map
    [menu-bar restart-emacs-menu rs]
    '("Restart Emacs" . restart-emacs)
    )
  (define-key global-map
    [menu-bar restart-emacs-menu rs-d]
    '("Restart Emacs (Debug)" . restart-emacs-debug))
  (define-key global-map
    [menu-bar restart-emacs-menu rs-q]
    '("Restart Emacs (Quick)" . restart-emacs-quick))
  (define-key global-map
    [menu-bar restart-emacs-menu rs-args]
    '("Restart Emacs (Args...)" . restart-emacs-with-arguments))


  )
#+END_SRC
** Looks/Themes
:PROPERTIES:
:ID:       ce830bc7-3da6-432a-a723-1d7faf6cb31d
:END:
*** Basic Configuration
:PROPERTIES:
:ID:       644ee45f-f75a-4cbd-b3b1-57778fea1221
:END:
Adds colouring for variables in programming languages. Sets
the starting buffer to this file.
#+BEGIN_SRC emacs-lisp
;; (setq initial-buffer-choice config-file-file-name)

(use-package color-identifiers-mode
  :diminish color-identifiers-mode
  :defer 4
  :config
  (global-color-identifiers-mode t))

#+END_SRC
*** Themes
**** Spaceline
#+BEGIN_SRC emacs-lisp
(use-package spaceline
  :defer 2
  :commands (spaceline-spacemacs-theme
             spaceline-helm-mode spaceline-info-mode)
  :config
  (use-package spaceline-config
    :ensure nil
    :config
    (spaceline-spacemacs-theme)
    (spaceline-helm-mode t)
    (spaceline-info-mode t)
    ;; (use-package all-the-icons
    ;;   :config
    ;;   (use-package spaceline-all-the-icons
    ;;     :config
    ;;     (spaceline-all-the-icons-theme)))
    ))
#+END_SRC
**** Spacemacs
#+BEGIN_SRC emacs-lisp
(use-package spacemacs-common
  :ensure spacemacs-theme
  :config )
#+END_SRC
**** Doom-Themes

#+BEGIN_SRC emacs-lisp
(use-package doom-themes
  :config
  (setq doom-themes-enable-bold t doom-themes-enable-italic t)
  (doom-themes-neotree-config)
  (doom-themes-treemacs-config)
  (doom-themes-org-config))
#+END_SRC
*** Fonts
#+BEGIN_SRC emacs-lisp
(set-frame-font "Source Code Pro 13" nil t)
#+END_SRC

** Text Editing
:PROPERTIES:
:ID:       e88a991a-273f-4647-9f69-db4480e4f2c4
:END:
Everything in here is essentially from [[http://tuhdo.github.io][tuhdo]] and most of it
is sane by default. Check out the individual packages in his
C/C++ tutorial!
*** Basic
:PROPERTIES:
:ID:       ee87ba06-6f6d-4d2b-b85d-bcfe9ed0928a
:END:
#+BEGIN_SRC emacs-lisp
(setq global-mark-ring-max 5000
      mark-ring-max 5000
      mode-require-final-newline t
      tab-width 2
      kill-ring-max 5000
      kill-whole-line t)
(setq-default indent-tabs-mode nil
	      indent-tabs-mode nil)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-language-environment "UTF-8")
(prefer-coding-system 'utf-8)
;; Not sure if i want this feature, it causes you to delete
;; things in selection if you start writing much like on
;; most operating systems.
;; (delete-selection-mode t)

;; (add-hook 'sh-mode-hook (lambda ()
;;    k                      (setq
;;                          tab-width
;;                          4)))

;; (use-package simple
;;   :ensure nil
;;   :hook
;;   ((prog-mode)
;;    . auto-fill-mode))

;; (use-package refill :hook ((text-mode org-mode) ))





(use-package
  whitespace
  :config (add-hook
	   'diff-mode-hook
	   (lambda ()
	     (setq-local
	      whitespace-style
	      '(face
		tabs
		tab-mark
		spaces
		space-mark
		trailing
		indentation::space
		indentation::tab
		newline
		newline-mark))
	     (whitespace-mode 1)))
  (global-set-key
   (kbd "C-c w")
   'whitespace-mode))
;;(use-package diff-mode)
;;(add-hook 'prog-mode-hook (lambda () (interactive) (setq
;;                          show-trailing-whitespace 1)))

;; (add-hook 'text-mode-hook 'auto-fill-mode)
#+END_SRC
*** Keybindings
:PROPERTIES:
:ID:       e2c8acc1-eb44-40a8-b854-a7f21334de9e
:END:
Disable certain keybindings that are often clicked by
mistake. Add keybinding for compilation (F5) and for
capitalising (M-c).

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "RET") 'newline-and-indent)
(global-set-key (kbd "C-<down-mouse-1>") 'ignore)
(global-set-key (kbd "C-<down-mouse-2>") 'ignore)
(global-set-key (kbd "C-<down-mouse-3>") 'ignore)
(global-set-key (kbd "C-<mouse-1>")
                'ignore)

(global-set-key (kbd "C-<mouse-2>") 'ignore)

(global-set-key (kbd "C-<mouse-3>") 'ignore)

(global-set-key (kbd "M-c") 'capitalize-dwim)

(global-set-key (kbd "<f5>")
                (lambda () (interactive)
                  (setq-local compilation-read-command nil)
                  (call-interactively 'compile)))
#+END_SRC
*** Packages
:PROPERTIES:
:ID:       833d7de4-405a-4879-8cb2-f8ff9b497cb9
:END:
**** Rainbow Delimiters
:PROPERTIES:
:ID:       7a40a382-9438-4c45-bec4-dedb955febd5
:END:
Rainbow delimiters highlights braces, brackets, and their
friends.

#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :hook (prog-mode . rainbow-delimiters-mode-enable))
#+END_SRC
**** Aggressive Indentation
:PROPERTIES:
:ID:       9963e877-08ae-4ddf-b709-df81df380927
:END:
Tries to keep your indentation in check by, being aggressive
about it. It is related to electric-indent-mode but is, more
aggressive.

#+BEGIN_SRC emacs-lisp
(use-package aggressive-indent
  :config
  (global-aggressive-indent-mode -1))
#+END_SRC
**** Which-key
:PROPERTIES:
:ID:       a94d0064-685f-4b20-b43d-6fc8021987c9
:END:
Which-key gives you suggestions if you have started a key
combination but stopped. Real handy.
#+BEGIN_SRC emacs-lisp
(use-package which-key
  :ensure t
  :diminish which-key-mode
  :hook (after-init . which-key-mode))
#+END_SRC
**** Volatile Highlights
:PROPERTIES:
:ID:       bf40c61d-c498-4754-920a-4a73936b7286
:END:
Briefly highlights changes to the buffer for things like
pasting.
#+BEGIN_SRC emacs-lisp
(use-package volatile-highlights
  :diminish volatile-highlights-mode
  :config
  (volatile-highlights-mode t))
#+END_SRC
**** Dtrt-Indent
:PROPERTIES:
:ID:       155f1c87-b5c8-4c8d-9da5-5ec273426ae6
:END:
Guess indentation for many newly opened files based on what
is already in them.
#+BEGIN_SRC emacs-lisp
(use-package dtrt-indent
  :defer 2
  :config
  (dtrt-indent-mode t)
  (setq dtrt-indent-verbosity 0))
#+END_SRC
**** Whitespace Butler
:PROPERTIES:
:ID:       18029dc2-51f4-4533-86b5-60fe5694f083
:END:
Whitespace butler kills useless whitespace when you aren't
doing anything else.
#+BEGIN_SRC emacs-lisp
(use-package ws-butler
  :hook ((prog-mode org-mode text-mode fundamental-mode) . ws-butler-mode)
  :diminish ws-butler-mode)
#+END_SRC
**** Undo Tree
:PROPERTIES:
:ID:       d2fa8cc9-fec4-41f2-b331-8b1cb3c40a2a
:END:
Makes undoing really fancy with a tree. Try it with C-x u.
#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :diminish undo-tree-mode
  :bind (("C-x u" . undo-tree-visualize))
  :config
  (global-undo-tree-mode)
  (setq undo-tree-visualizer-timestamps nil
	undo-tree-visualizer-diff t))
#+END_SRC
**** Smartparens
:PROPERTIES:
:ID:       efa46fec-5f1e-49bd-9d49-afc32561af23
:END:
Smartparens makes working with pairs of things such as
parentheses simple. It keeps you from messing them up which
is neat.
#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :diminish smartparens-mode
  :defer 1
  :commands sp-pair
  :hook ((org-mode text-mode TeX-mode c-mode-common org-src-mode)
         . smartparens-mode)
  :config
  (setq sp-escape-quotes-after-insert nil)
  (require 'smartparens-config)
  (sp-pair "\\[" "\\]")
  (setq ;; sp-base-key-bindings 'paredit
   sp-autoskip-closing-pair 'always
   sp-hybrid-kill-entire-symbol nil)
  (smartparens-strict-mode)
  ;; (sp-use-paredit-bindings)
  ;; (smartparens-global-mode t)
  :bind (:map smartparens-mode-map (("M-<down>" . nil)
				    ("M-<up>" . nil))))
#+END_SRC
**** Comment-dwim-2
:PROPERTIES:
:ID:       cd4c7416-60e7-4b90-95c0-35de82183bfb
:END:
Lets you comment out stuff in more cleaver ways than
default. Dwim stands for do what i mean.
#+BEGIN_SRC emacs-lisp
(use-package comment-dwim-2
  :bind (("M-;" . comment-dwim-2)))
#+END_SRC
**** Anzu
:PROPERTIES:
:ID:       4bc566de-5f12-4aed-b39d-8d57b522fcb6
:END:
Anzu makes the regular query and replace function much more
useful.
#+BEGIN_SRC emacs-lisp
(use-package anzu
  :diminish anzu-mode
  :config
  (global-anzu-mode t)
  :bind (("M-%" . anzu-query-replace)
	 ("C-M-%" . anzu-query-replace-regexp)))
#+END_SRC
**** Iedit
:PROPERTIES:
:ID:       5a77dfde-4a06-4502-99ac-77c360b9ba13
:END:
This is really cool. Mark a section and edit all occurrences
of the section.
#+BEGIN_SRC emacs-lisp
(use-package iedit
  :config
  (setq iedit-toggle-key-default nil)
  :bind (("C-M-;" . iedit-mode)))
#+END_SRC
**** Customized Functions (Mainly From Prelude)
:PROPERTIES:
:ID:       884d3d75-7357-4ac4-b50a-4cbc8b8401ab
:END:
#+BEGIN_SRC emacs-lisp
(defun prelude-move-beginning-of-line (arg)
  "Move point back to indentation of beginning of line. Move
  point to the first non-whitespace character on this line. If
  point is already there, move to the beginning of the
  line. Effectively toggle between the first non-whitespace
  character and the beginning of the line.

If ARG is not nil or 1, move forward ARG - 1 lines first. If
point reaches the beginning or end of the buffer, stop
there."


  (interactive "^p")
  (setq arg (or arg 1))
  ;; Move lines first
  (when (/= arg 1)
    (let ((line-move-visual nil))
      (forward-line (1- arg))))
  (let ((orig-point (point)))
    (back-to-indentation)
    (when (= orig-point (point))
      (move-beginning-of-line 1))))

(global-set-key (kbd "C-a") 'prelude-move-beginning-of-line)
(defadvice kill-ring-save (before slick-copy activate compile)
  "When called interactively with no active region, copy a
single line instead."
  (interactive
   (if mark-active (list (region-beginning) (region-end))
     (message "Copied line")
     (list (line-beginning-position)
           (line-beginning-position 2)))))

(defadvice kill-region (before slick-cut activate compile)
  "When called interactively with no active region, kill a
  single line instead."
  (interactive
   (if mark-active (list (region-beginning) (region-end))
     (list (line-beginning-position)
           (line-beginning-position 2)))))
;; kill a line, including whitespace characters until next non-whitespace character
;; of next line
(defadvice kill-line (before check-position activate)
  (if (member major-mode
              '(emacs-lisp-mode scheme-mode lisp-mode
                                c-mode c++-mode objc-mode
                                latex-mode plain-tex-mode))
      (if (and (eolp) (not (bolp)))
          (progn (forward-char 1)
                 (just-one-space 0)
                 (backward-char 1)))))
;; taken from prelude-editor.el
;; automatically indenting yanked text if in programming-modes
(defvar yank-indent-modes
  '(LaTeX-mode TeX-mode)
  "Modes in which to indent regions that are yanked (or
  yank-popped). Only modes that don't derive from
  `prog-mode' should be listed here.")

(defvar yank-indent-blacklisted-modes
  '(python-mode slim-mode haml-mode)
  "Modes for which auto-indenting is suppressed.")

(defvar yank-advised-indent-threshold 1000
  "Threshold (# chars) over which indentation does not
  automatically occur.")

(defun yank-advised-indent-function (beg end)
  "Do indentation, as long as the region isn't too large."
  (if (<= (- end beg) yank-advised-indent-threshold)
      (indent-region beg end nil)))

(defadvice yank (after yank-indent activate)
  "If current mode is one of 'yank-indent-modes, indent
yanked text (with prefix arg don't indent)."

  (if (and (not (ad-get-arg 0))
           (not (member major-mode
                        yank-indent-blacklisted-modes))
           (or (derived-mode-p 'prog-mode)
               (member major-mode yank-indent-modes)))
      (let ((transient-mark-mode nil))
        (yank-advised-indent-function (region-beginning)
                                      (region-end)))))


(defadvice yank-pop (after yank-pop-indent activate)
  "If current mode is one of `yank-indent-modes', indent
yanked text (with prefix arg don't indent)."
  (when (and (not (ad-get-arg 0))
             (not (member major-mode
                          yank-indent-blacklisted-modes))
             (or (derived-mode-p 'prog-mode)
                 (member major-mode yank-indent-modes)))
    (let ((transient-mark-mode nil))
      (yank-advised-indent-function (region-beginning)
                                    (region-end)))))
;; prelude-core.el
(defun indent-buffer ()
  "Indent the currently visited buffer."
  (interactive)
  (indent-region (point-min) (point-max)))


;; prelude-editing.el
(defcustom prelude-indent-sensitive-modes
  '(coffee-mode python-mode slim-mode haml-mode yaml-mode)
  "Modes for which auto-indenting is suppressed."
  :type 'list
  :group 'prelude)

(defun indent-region-or-buffer ()
  "Indent a region if selected, otherwise the whole buffer."
  (interactive)
  (unless (member major-mode prelude-indent-sensitive-modes)
    (save-excursion
      (if (region-active-p)
          (progn
            (indent-region (region-beginning) (region-end))
            (message "Indented selected region."))
        (progn
          (indent-buffer)
          (message "Indented buffer.")))
      (whitespace-cleanup))))

(global-set-key (kbd "C-c i") 'indent-region-or-buffer)

;; add duplicate line function from Prelude
;; taken from prelude-core.el
(defun prelude-get-positions-of-line-or-region ()
  "Return positions (beg . end) of the current line or
region."
  (let (beg end)
    (if (and mark-active (> (point) (mark)))
        (exchange-point-and-mark))
    (setq beg (line-beginning-position))
    (if mark-active
        (exchange-point-and-mark))
    (setq end (line-end-position))
    (cons beg end)))

;; smart openline
(defun prelude-smart-open-line (arg)
  "Insert an empty line after the current line. Position the
cursor at its beginning, according to the current mode. With
a prefix ARG open line above the current line."
  (interactive "P")
  (if arg
      (prelude-smart-open-line-above)
    (progn
      (move-end-of-line nil)
      (newline-and-indent))))

(defun prelude-smart-open-line-above ()
  "Insert an empty line above the current line. Position the
cursor at it's beginning, according to the current mode."
  (interactive)
  (move-beginning-of-line nil)
  (newline-and-indent)
  (forward-line -1)
  (indent-according-to-mode))
(global-set-key (kbd "M-o") 'prelude-smart-open-line)
#+END_SRC

**** Avy
:PROPERTIES:
:ID:       3ba766e4-840c-4647-b3e3-7497c7dcf21d
:END:
Avy provides an interesting way to find things in text. It
is the kind of thing that you definitely would be useful if
you got started but which I haven't really gotten started
with.
#+BEGIN_SRC emacs-lisp
(use-package avy
  :config
  (setq avy-all-windows nil)
  (use-package avy-zap
    :defer 3)
  :bind (("C-:" . avy-goto-char)
	 ("C-;" . avy-goto-word-1)))
#+END_SRC
**** Dumb-Jump
:PROPERTIES:
:ID:       965b25ec-745c-4c97-aaeb-df9dd5c22d3b
:END:
Dumb jump tries to find variables and functions by simply
searching for the word in as many files as possible.
#+BEGIN_SRC emacs-lisp
(use-package dumb-jump
  :defer 2
  :diminish dumb-jump-mode
  :bind (("C-M-g" . dumb-jump-go)
	 ("C-M-p" . dumb-jump-back)
	 ("C-M-q" . dumb-jump-quick-look))
  :config
  (dumb-jump-mode t))
#+END_SRC

** PDF-Handling
:PROPERTIES:
:ID:       77b2a7a3-3ab5-4862-9f1a-78495d8011d2
:END:
The basic emacs pdf viewing utility, docview, is kind of
wonky. This installs a different utility, pdf-tools
which is wonderful! It does require some things
installed on your system to work (development version of
all of them)
- libpng
- libpoppler-glib, libpoppler-private
- imagemagick
- libz
- gcc, g++
- make
- automake
- autoconf

It is currently only enabled on linux, mac, and cygwin.
#+BEGIN_SRC emacs-lisp
  (use-package pdf-tools
    :mode ("\\.pdf\\'" . pdf-view-mode)
    :when (or (eq system-type 'gnu/linux)
              (eq system-type 'cygwin)
              (eq system-type 'darwin))
    :defer 2
    :config

    (setq-default pdf-view-display-size 'fit-page))
#+END_SRC

** Emacs-dashboard
Dashboard sets up a nice startup instead of the default
startup. It shows you files you've opened recently and your
agenda items.
#+BEGIN_SRC emacs-lisp
(use-package dashboard
  :defer nil
  :init
  :config
  (dashboard-setup-startup-hook)
  (add-to-list 'dashboard-items '(agenda) t)
  (setq show-week-agenda-p t)
(setq initial-buffer-choice (lambda () (get-buffer "*dashboard*")))
)
#+END_SRC
** Neotree
Neotree is a nice little file browser. I have it bound to f1.
#+BEGIN_SRC emacs-lisp
(use-package neotree
  :defer 1
  :config
  (setq neo-theme (if (display-graphic-p) 'icons 'arrow))
  (setq neo-smart-open t)

  :bind ("<f1>" . neotree-toggle ))
#+END_SRC
** EVIL/Tutor
If you are a vim-user, you will love Evil-mode. It is an
implementation of the good stuff from vim in Emacs (this
might be somewhat contentious). I have it on so I can mess
around with vim from time to time but I set the default
state of each buffer to the standard Emacs mode.

There is an implementation of the vim tutor available for
Evil-mode.

[[https://www.youtube.com/watch?v=JWD1Fpdd4Pc][There is a great talk about Evil-mode for vim users
available by Aaron Bieber]]

Ironically, this talk is the reason I got started... with Emacs.

#+BEGIN_SRC emacs-lisp
;; (use-package evil
;;   :config
;;   :disabled t
;;   (setq evil-default-state 'emacs)
;;   ;; (use-package org-evil)
;;   ;; (use-package evil-tutor)
;;   (evil-mode t))
#+END_SRC
* Development/Writing
:PROPERTIES:
:ID:       cb1005df-4514-4726-b68b-1373343100d4
:END:
Again, visit [[http://tuhdo.github.io][tuhdo]] but check out the stuff about helm specifically!
** Project Management
:PROPERTIES:
:ID:       94034714-fb8d-42ea-8956-e84cf7849cb8
:END:
*** Projectile
:PROPERTIES:
:ID:       37e27ecb-6374-429d-81ac-3ddc0968e9aa
:END:
#+BEGIN_SRC emacs-lisp
(use-package projectile
  :hook (prog-mode . projectile-mode)
  :init
  (setq projectile-keymap-prefix (kbd "C-c p"))
  :config

  (projectile-global-mode)
  (setq projectile-enable-caching t)
  :diminish projectile-mode)
#+END_SRC
*** Magit
:PROPERTIES:
:ID:       10086449-5e80-4ed3-96e5-0439180ec58a
:END:
#+BEGIN_SRC emacs-lisp
(when (not (string= system-type "windows-nt"))
  (use-package magit
    :commands magit-status
    :bind ("C-x g" . magit-status)
    :config)
  )
#+END_SRC
** Helm
:PROPERTIES:
:ID:       319b55eb-ac6a-4658-bb7c-23a7b86ea768
:END:
Helm makes emacs a lot better.
*** Helm Gtags
:PROPERTIES:
:ID:       34bc616f-cb89-4937-921a-ca59340051c0
:END:
#+BEGIN_SRC emacs-lisp
(use-package helm-gtags
  :when (executable-find "gtags")
  :hook ((dired-mode eshell-mode c-mode c++-mode java-mode asm-mode) . helm-gtags-mode)
  :config
  (setq
   helm-gtags-ignore-case t
   helm-gtags-auto-update t
   helm-gtags-use-input-at-cursor t
   helm-gtags-pulse-at-cursor t
   helm-gtags-prefix-key "\C-cg")
  (setq helm-gtags-prefix-key "\C-cg"))
#+END_SRC
*** Basic Configuration
:PROPERTIES:
:ID:       4ef254df-450b-4522-9849-4f790b9a8a72
:END:
#+BEGIN_SRC emacs-lisp
(use-package helm
  :functions helm-find-files
  :commands
  (helm-mode helm-M-x helm-show-kill-ring helm-mini
             helm-find helm-all-mark-rings
             helm-apropos helm-info-Emacs
             helm-locate-library helm-minibuffer-history
             helm-occur helm-wikipedia-suggest helm-register
             helm-etags-select helm-buffers-list helm-google
             helm-yas-complete helm-ag helm-grep-ag
             helm-elisp-show-help helm-command-prefix
             helm-locate helm-man-woman helm-autoresize-mode
             helm-descbinds-mode helm-themes helm-dash
             helm-multi-swoop-all
             helm-swoop-without-pre-input
             helm-swoop-from-isearch  helm-projectile
             helm-semantic helm-info-semantic)
  :diminish helm-mode
  :bind (("M-x" . helm-M-x)
	 ("M-y" . helm-show-kill-ring)
	 ("C-x b" . helm-mini)
	 ("C-x C-f" . helm-find-files)
	 ("C-h SPC" . helm-all-mark-rings)
	 :map help-map
	 ("C-f" . helm-apropos)
	 ("r" . helm-info-emacs)
	 ("C-l" . helm-locate-library)
	 :map minibuffer-local-map
	 ("M-p" . helm-minibuffer-history)
	 ("M-n" . helm-minibuffer-history)
	 :map helm-grep-mode-map
	 ("<return>" . helm-grep-mode-jump-other-window)
	 ("n" . helm-grep-mode-jump-other-window-forward)
	 ("p" . helm-grep-mode-jump-other-window-backward))
  :config
  (use-package helm-config
    :ensure nil)
  (helm-mode t)
  (use-package helm-files
    :ensure nil)
  (use-package helm-find
    :ensure nil)
  (use-package helm-command :ensure nil
    :config
    (setq helm-M-x-requires-pattern nil)
    (setq helm-M-x-fuzzy-match t))
  (use-package helm-grep
    :ensure nil)
  (global-set-key (kbd "C-c h") 'helm-command-prefix)
  (global-unset-key (kbd "C-x c"))
  (bind-key "C-c h o" #'helm-occur)
  (bind-key "C-c h C-c w" #'helm-wikipedia-suggest)
  (bind-key "C-c h x" #'helm-register)
  (define-key global-map [remap find-tag] 'helm-etags-select)
  (define-key global-map [remap list-buffers] 'helm-buffers-list)

  (use-package helm-google
    :config
    (when (executable-find "curl")
      (setq helm-net-prefer-curl t)))
  (use-package helm-c-yasnippet
    :after yasnippet
    :config
    (setq helm-yas-display-key-on-candidate t))
  (use-package helm-ag)
  (use-package helm-elisp
    :ensure nil
    :config
    (setq helm-apropos-fuzzy-match t))

  (use-package helm-locate
    :ensure nil
    :config
    (setq helm-locate-fuzzy-match t))
  (use-package helm-files
    :ensure nil
    :config
    (setq helm-ff-search-library-in-sexp t
	  helm-ff-file-name-history-use-recentf t
	  helm-ff-skip-boring-files t))
  (use-package helm-for-files
    :ensure nil)
  (setq helm-scroll-amount 4
	helm-split-window-inside-p t
	helm-input-idle-delay 0.01
	helm-candidate-number-limit 500
	helm-move-to-line-cycle-in-source t
	helm-buffers-fuzzy-matching t
        helm-recentf-fuzzy-match t)
  (add-to-list 'helm-sources-using-default-as-input 'helm-source-man-pages)
  ;; (add-hook 'eshell-mode-hook
  ;;           #'(lambda ()
  ;;               (define-key eshell-mode-map (kbd "M-l")  'helm-eshell-history)))
  (add-hook 'helm-goto-line-before-hook 'helm-save-current-pos-to-mark-ring)
  (helm-autoresize-mode t)
  (use-package helm-descbinds
    :config
    (helm-descbinds-mode t))
  (use-package helm-themes
    :commands helm-themes
    :bind (("<f10>" . helm-themes)))
  (use-package helm-dash)

  (use-package helm-swoop
    :bind
    (("C-c s" . helm-multi-swoop-all)
     ("C-s" . helm-swoop-without-pre-input)
     ("C-r" . helm-swoop-without-pre-input)
     :map isearch-mode-map
     ("M-i" . helm-swoop-from-isearch))
    :commands
    (helm-swoop
     helm-multi-swoop
     helm-swoop-from-isearch
     helm-multi-swoop-all-from-helm-swoop)
    :config
    (global-set-key (kbd "C-c h s") 'helm-swoop)
    (define-key helm-swoop-map (kbd "M-i")
      'helm-multi-swoop-all-from-helm-swoop)
    (setq helm-multi-swoop-edit-save t
	  helm-swoop-split-with-multiple-windows t
	  helm-swoop-split-direction 'split-window-vertically
	  helm-swoop-speed-or-color t))
  (use-package helm-projectile
    :after (projectile)
    :config
    (helm-projectile-on)
    (setq projectile-completion-system 'helm)
    (setq projectile-indexing-method 'alien)))
#+END_SRC
** Elglot
:PROPERTIES:
:ID:       03d6f2fd-2956-473e-b654-4a2766edad38
:END:
An emacs language server protocol client. Kind of new.
Hopefully it gets useful in the future.
#+BEGIN_SRC emacs-lisp
(use-package eglot)
#+END_SRC
** Yasnippet
:PROPERTIES:
:ID:       42e5a0f0-74a7-485a-a909-471bffa936a5
:END:
#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :defer 1
  :init
  (defun start-yasnippet ()
    (interactive)
    (yas-minor-mode t))
  (defun elib-org-latex-yas ()
    (yas-activate-extra-mode  'latex-mode))
  ;; :commands yas-minor-mode
  ;; :hook (((prog-mode TeX-mode) . start-yasnippet))
  :config
  (use-package yasnippet-snippets)
  (set 'yas-verbosity 1)
  (add-to-list 'yas-snippet-dirs tuhdo-snippets-directory )
  (add-to-list 'yas-snippet-dirs elib-snippets-directory )
  (yas-global-mode t)
  (add-hook 'org-mode-hook #'elib-org-latex-yas))
#+END_SRC

** Terminal Usage
:PROPERTIES:
:ID:       9828326a-0250-455b-ac08-e349e5121ea2
:END:
Create and use multiple terminals with multi-term. It is
pretty nifty.
#+BEGIN_SRC emacs-lisp
(use-package multi-term
  :bind (("<f6>" . multi-term-next)
	 ("C-<f6>" . multi-term)
	 :map term-raw-map
	 ("C-c C-j" . term-line-mode))
  :config
  (if (file-exists-p "/usr/bin/fish")
      (setq multi-term-program "/usr/bin/fish"))
  (when (require 'term nil t) ;; only if term can be loaded..
    (setq
     term-bind-key-alist
     (list
      (cons "C-c C-c" 'term-interrupt-subjob)
      (cons "C-p" 'previous-line)
      (cons "C-n" 'next-line)
      (cons "M-f" 'term-send-forward-word)
      (cons "M-b" 'term-send-backward-word)
      (cons "C-c C-j" 'term-line-mode)
      (cons "C-c C-k" 'term-char-mode)
      (cons "M-DEL" 'term-send-backward-kill-word)
      (cons "M-d" 'term-send-forward-kill-word)
      (cons "<C-left>" 'term-send-backward-word)
      (cons "<C-right>" 'term-send-forward-word)
      (cons "C-r" 'term-send-reverse-search-history)
      (cons "M-p" 'term-send-raw-meta)
      (cons "M-y" 'term-send-raw-meta)
      (cons "C-y" 'term-send-raw)))))
	 #+END_SRC
** LaTeX/AUCTeX
:PROPERTIES:
:ID:       1b9bd876-1078-4366-9bde-9db814381c77
:END:
#+BEGIN_SRC emacs-lisp

(use-package tex
  :ensure auctex
  :mode (("\\.tex$" . TeX-mode))
  :defines TeX-run-TeX
  :bind (:map TeX-mode-map
	      ("C-c v" . elib-helm-tex-choose-program))
  :init
  (unless (getenv "TEXMFHOME")
        (setenv "TEXMFHOME" (concat (getenv "HOME") "/texmf")))

  :commands
  (TeX-revert-document-buffer
   TeX-command TeX-master-file)
  :config
  ;; (setq TeX-source-correlate-start-server t)
  (add-hook 'LaTeX-mode-hook #'TeX-source-correlate-mode)
  (add-hook 'TeX-after-compilation-finished-functions #'TeX-revert-document-buffer)
  ;; (define-key TeX-mode-map (kbd "TAB") 'company-complete)
  ;; (define-key TeX-mode-map (kbd "TAB") 'company-complete)
  (use-package tex-buf :ensure nil)
  (use-package latex-preview-pane
    :config
    (setq TeX-save-query nil)
    (latex-preview-pane-enable))
  (setq doc-view-continuous t)
  (use-package preview-latex
    :disabled t
    :defer 1)
  (use-package asy-mode
    :after (tex tex-buf)
    :when (executable-find "asy")
    :ensure nil
    :load-path elib-asymptote-load-path
    :mode ("\\.asy\\'" . asy-mode)
    :init
    (autoload 'asy-mode "asy-mode.el" "Asymptote Major Mode" t)
    (autoload 'lasy-mode "asy-mode.el" "Hybrid Asymptote/LaTeX Major Mode" t)
    (autoload 'asy-insinuate-latex "asy-mode.el" "Asymptote Insinuate LaTeX" t)
    :config
    (defun run-asy-in-tex ()
      (interactive "")
      (TeX-command TeX-run-TeX (TeX-master-file nil nil nil) t)
      (save-window-excursion (compile "asy *.asy"))
      (TeX-command TeX-run-TeX (TeX-master-file nil nil nil) t)
      )
    (add-to-list 'TeX-command-list
		 '("Asymptote" "asy *.asy" TeX-run-TeX nil t :help "Run Asymptote")))
  (setq TeX-auto-save t)
  (setq TeX-parse-self t)
  (setq-default TeX-master nil))
	 #+END_SRC
** Company
:PROPERTIES:
:ID:       1e97f178-f9db-4633-8c7e-fd5aa9a72bc5
:END:
 	#+BEGIN_SRC emacs-lisp
(use-package company
  :diminish company-mode
  :config
  (global-company-mode t)

  (setq company-idle-delay 0.01
	company-tooltip-idle-delay 0.01)
;;; Back-ends
;;; C/C++
  (use-package company-clang
    :disabled t
    :ensure nil
    :config
    (setq
     company-clang-arguments
     (list "-std=c++1z" "-Wall" "-Werror"
	   "-Wpedantic -I./ -I./include/ -I../include/ -I../")))
  (use-package company-c-headers
    :disabled t
    :after cc-mode
    :config
    ;; (define-key c-mode-map  [(tab)] 'company-complete)
    ;; (define-key c++-mode-map  [(tab)] 'company-complete)
    ;; (define-key c-mode-map (kbd "TAB") 'company-complete)
    ;; (define-key c++-mode-map (kbd "TAB") 'company-complete)
    (use-package semantic
      :commands semantic-gcc-setup
      :functions semantic-gcc-get-include-paths
      :config
      (semantic-gcc-setup)
      (dolist (name (semantic-gcc-get-include-paths "c++"))
	(add-to-list 'company-c-headers-path-system name)))
    (add-to-list 'company-backends 'company-c-headers))
  (use-package company-irony
    :disabled t
    :after irony
    :hook (irony-mode . company-irony-setup-begin-commands)
    :config
    (use-package company-irony-c-headers
      :after company-c-headers
      :config
      (add-to-list-multi 'company-backends '(company-irony-c-headers company-irony))))

  ;; TeX
  (use-package company-auctex
    :after tex
    :config
    (company-auctex-init))
  ;; Yasnippet
  (use-package company-yasnippet
    :ensure nil
    :after yasnippet
    :config
    (global-set-key (kbd "C-c y") 'company-yasnippet)
    (add-to-list 'company-backends 'company-yasnippet t))
;;; Elisp
  ;; (define-key emacs-lisp-mode-map (kbd "TAB") 'company-complete)
;;; Generic
  ;; (define-key prog-mode-map (kbd "TAB") 'company-complete)
;;; Config

  (when company-backends
    (progn
      (delete 'company-semantic company-backends))))
  #+END_SRC
** Flycheck
:PROPERTIES:
:ID:       84781c34-923c-43a6-8df9-4b6a1366d4db
:END:
	 #+BEGIN_SRC emacs-lisp
(use-package flycheck
  :disabled t
  :init
  (defun disable-flycheck-temporarily ()
    "Disables flycheck in current buffer."
    (interactive)
    (flycheck-mode -1))
  :config
  (setq flycheck-idle-change-delay 0.1)
  (add-hook 'org-src-mode-hook
            'disable-flycheck-temporarily)

  (global-flycheck-mode t))

	 #+END_SRC
** Web Development
:PROPERTIES:
:ID:       3c853127-d141-4de4-9f48-fd5dd4602930
:END:
	 #+BEGIN_SRC emacs-lisp
(use-package web-mode
	:defer 2)
	 #+END_SRC
** C/C++
:PROPERTIES:
:ID:       142a6210-ba13-4bfc-96d5-5034b7ed22c1
:END:
*** Basic Settings
:PROPERTIES:
:ID:       770bdc8e-7d22-488c-9e52-f44e75e60659
:END:
#+BEGIN_SRC emacs-lisp
(use-package cc-mode
  :mode (("\\.c\\'" . c-mode)
         ("\\.h\\'" . c++-mode)
         ("\\.hpp\\'" . c++-mode)
         ("\\.hxx\\'" . c++-mode)
         ("\\.ii\\'" . c++-mode)
         ("\\.C\\'" . c++-mode)
         ("\\.cpp\\'" . c++-mode)
         ("\\.CPP\\'" . c++-mode)
         ("\\.c++\\'" . c++-mode)
         ("\\.cxx\\'" . c++-mode)
         ("\\.cc\\'" . c++-mode)
         ("\\.CC\\'" . c++-mode))
  :hook (c-mode-common . hs-minor-mode)
  :bind (:map c-mode-base-map
              ("C-c o" . ff-find-other-file))
  :config
  (setq c-default-style "stroustrup"))
		#+END_SRC
*** Debugging
:PROPERTIES:
:ID:       035337e0-f10b-4bf8-a862-a14e8804eecc
:END:
		This is really cool. Try it with M-x gdb and choose the
		binary you want to debug.
		#+BEGIN_SRC emacs-lisp
(use-package gdb-mi
	:config
	(setq gdb-many-windows t
				gdb-show-main t))
		#+END_SRC
*** Packages
:PROPERTIES:
:ID:       94f26649-6cec-4874-816a-ed192e52b7be
:END:
**** CCLS/LSP

#+BEGIN_SRC emacs-lisp

(use-package lsp-mode
  :commands lsp
  :config
  (use-package lsp-ui
    :commands lsp-ui-mode)
  (use-package company-lsp
    :commands company-lsp)
  (use-package ccls
    :preface

    (add-hook 'c-mode-common-hook #'ccls-enable)
    (setq-default flycheck-disabled-checkers '(c/c++-clang c/c++-cppcheck c/c++-gcc))
    :defer nil
    :config

    (setq ccls-executable (potential-load-paths '("/usr/local/bin/ccls" "~/.local/bin/ccls")))
    (setq company-transformers nil company-lsp-async t company-lsp-cache-candidates nil)
    (add-to-list 'company-backends 'company-lsp)
  (use-package helm-xref
  :config
  (setq xref-show-xrefs-function 'helm-xref-show-xrefs)
  )
    )
  )


(defun ccls-enable ()
    (require 'lsp)
    (require 'ccls)
    (lsp))


#+END_SRC


**** Irony Mode
Irony provides auto completion for C++ which is helpful. It
uses a server program that has to be compiled before you can
use it. After installation, simply call [[elisp:(describe-function 'irony-install-server)][irony-install-server]]
		 #+BEGIN_SRC emacs-lisp
(use-package irony
  :disabled t
  :after cc-mode
  :hook ((irony-mode . irony-cdb-autosetup-compile-options)
         (c-mode-common . irony-mode)))
		 #+END_SRC
**** Rtags
:PROPERTIES:
:ID:       dacd9601-b4cb-49f3-b1bd-fe0adb0b546b
:END:
		 #+BEGIN_SRC emacs-lisp
(use-package rtags
  :disabled t
  :after cc-mode
  :when (executable-find "rdm")
  :commands rtags-diagnostics
  :load-path elib-rtags-load-path
  :ensure nil
  :bind (:map c-mode-base-map
              ("M-." . rtags-find-symbol-at-point)
              ("M-," . rtags-location-stack-back)
              ("C-x ." . rtags-find-symbol))
  :hook (c-mode-common . rtags-start-process-unless-running)
  :config
  (rtags-start-process-unless-running)
  (setq rtags-completions-enabled t)
  (setq rtags-autostart-diagnostics t)
  (rtags-diagnostics)
(use-package flycheck-rtags
    :after flycheck
    :load-path elib-rtags-load-path
    :ensure nil
    :hook (c-mode-common . another-flycheck-rtags-setup)
    :init
    (defun another-flycheck-rtags-setup ()
      (interactive)
      (flycheck-select-checker 'rtags)
      (setq-local flycheck-highlighting-mode nil)
      (setq-local flycheck-check-syntax-automatically nil)
      (rtags-enable-standard-keybindings))
    :config
    (require 'flycheck-rtags))
  (use-package company-rtags
    :after company
    :load-path elib-rtags-load-path
    :ensure nil
    :when (executable-find "rdm")
    :config
    (setq rtags-completions-enabled t)
    (add-to-list 'company-backends 'company-rtags))
  (use-package helm-rtags
    :after helm
    :load-path elib-rtags-load-path
    :ensure nil
    :config
    (setq rtags-display-result-backend 'helm)))
		 #+END_SRC

                 #+RESULTS:
                 : rtags-find-symbol

**** Clang Format
:PROPERTIES:
:ID:       6ca50e64-9ca9-42ca-8e64-279694d0d944
:END:
		 #+BEGIN_SRC emacs-lisp
(use-package clang-format
  :after cc-mode
  :bind (:map
	 c-mode-map
	 ("C-c f" . clang-format-region)
	 ("C-c C-f" . clang-format-buffer)
	 :map c++-mode-map
	 ("C-c f" . clang-format-region)
	 ("C-c C-f" . clang-format-buffer)))
		 #+END_SRC

**** Cmake
:PROPERTIES:
:ID:       c231c0a1-c165-4a46-a64c-d0d6da27f0c7
:END:
		 #+BEGIN_SRC emacs-lisp
(use-package cmake-mode
  :defer 3
  :config
  (use-package cmake-font-lock
    :defer 3
    :hook (cmake-mode . cmake-font-lock-activate)
    :config
    (autoload 'cmake-font-lock-activate "cmake-font-lock" nil t)))
		 #+END_SRC
**** Meson
:PROPERTIES:
:ID:       abbc6ce6-c892-494d-9dc5-821e063340f7
:END:

		 #+BEGIN_SRC emacs-lisp
(use-package meson-mode)
		 #+END_SRC
**** Cmake-ide
:PROPERTIES:
:ID:       e4b9cf20-4250-4756-82af-12a3f0ff09d0
:END:
		 #+BEGIN_SRC emacs-lisp
(use-package cmake-ide
	:after rtags
	:config
	(cmake-ide-setup))
		 #+END_SRC
**** ASM

#+BEGIN_SRC emacs-lisp
(use-package demangle-mode
  :hook asm-mode
)
#+END_SRC
** Emacs Lisp
:PROPERTIES:
:ID:       078eee9e-e320-40f5-a4b5-a9b75c5c6358
:END:
*** Eldoc
:PROPERTIES:
:ID:       403daf79-5206-41d5-8c8f-7d67cf471f9b
:END:
		#+BEGIN_SRC emacs-lisp
(defun turn-off-eldoc ()
	"Temporarily turn off eldoc-mode."
	(eldoc-mode -1))
(use-package "eldoc"
  :diminish eldoc-mode
  :defer 2
  :init
  (progn
    (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
    (add-hook 'lisp-interaction-mode-hook 'turn-on-eldoc-mode)
    (add-hook 'ielm-mode-hook 'turn-on-eldoc-mode)))
		#+END_SRC
*** Lispy
Lispy is an intersting package. At the moment, I don't use it.
**** Keybinding Cheat Sheet
 Key-bindings are
- Movement
  - j lispy-down
  - k lispy-up
  - h lispy-left
  - l lipsy-right
  - b special-lispy-back
    - Moves back in history for above commands
  - s special-lispy-move-down
  - w special-lispy-move-up
- Moving code around
  - > lispy-slurp
  - < lispy-barf
  - r lispy-raise
  - C lispy-convolute
- Function help
  - C-1 show function
  - C-2 show arguments
- Evaluation
  - e  evals
  - E evals and inserts
- Code exploration
  - F/M-. jumps to symbol
  - D/M-, jumps back
  - c clone
- Prettifying and transforming code
  - i prettify code
  - xi cond -> if
  - xc if -> cond
  - xf flatten function or macro
  - xr eval and replace
  - xl defun -> lambda
  - xd lambda -> defun
  - O make code one-line
  - M make code multi-line
**** Code
#+BEGIN_SRC emacs-lisp
(use-package
  lispy
  :hook ((inferior-emacs-lisp-mode
          ielm-mode
          lisp-mode
          lisp-interaction-mode
          emacs-lisp-mode) . lispy-mode))
#+END_SRC

* Org Mode
:PROPERTIES:
:ID:       bb4a983b-23e4-4f42-be11-7a7c062bcc9b
:END:
** Basic Setup
:PROPERTIES:
:ID:       bb4db413-5085-44e5-9606-f29c20891f43
:END:
	 #+BEGIN_SRC emacs-lisp :noweb yes
(use-package org
  :commands (org-mode org-babel-load-file org-babel-tangle-file)
  :pin org
  :preface
  (fset 'org-call-export-to-pdf
        (lambda (&optional arg) "Keyboard macro."
          (interactive "p")
          (kmacro-exec-ring-item '("lp" 0 "%d") arg)))
  (fset 'org-call-export-to-beamer
        (lambda (&optional arg) "Keyboard macro."
          (interactive "p")
          (kmacro-exec-ring-item
           (quote ("lP" 0
	           "%d")) arg)))
  :init
  (setq-default major-mode 'org-mode)
  (setq initial-major-mode 'org-mode)
  :config
  <<org-config-basic-settings>>
  <<org-config-style>>
  <<org-config-babel>>
  <<org-config-capture>>
  <<org-config-agenda>>
  <<org-config-refile>>
<<org-config-export>>
<<org-config-calendar-fetch>>
  <<org-config-calendar-calfw>>
<<org-config-calendar-gcal>>
<<org-config-calendar-caldav>>
<<org-config-ref>>
  :bind (("\C-cl" . org-store-link)
         ("\C-cb" . org-iswitchb)
         :map org-mode-map
         ("C-c m" . org-toggle-latex-fragment)
         ("C-c C-p" . org-previous-visible-heading)
         ("C-c M-o" . org-toggle-link-display)
         ("S-<f5>" . org-call-export-to-pdf)
         ;;("<f5>" . org-call-export-to-beamer)
         ("C-c ." . org-time-stamp)
         ("\M-\C-g" . org-plot/gnuplot)))

	 #+END_SRC

** Basic Settings
#+NAME: org-config-basic-settings
#+BEGIN_SRC emacs-lisp :tangle no
  ;; Pressing enter on an org link follows the link
  (setq org-return-follows-link t)
  (defvar elib-user-org-todo-key-sequences
    '((sequence "TODO(t)" "NEXT(n)" "WAITING(w)" "|"   "DONE(d)" "DELEGATED(D)" "CANCELLED(c)")))
(setq org-tag-alist (quote (("@errand" . ?e)
                            ("@office" . ?o)
                            ("@home" . ?h)
                            ("@school" . ?s)
                            (:newline)
                            ("WAITING" . ?w)
                            ("HOLD" . ?H)
                            ("CANCELLED" . ?c))))

(setq org-fast-tag-selection-single-key nil)

  (setq org-todo-keywords elib-user-org-todo-key-sequences)
  (setq org-src-tab-acts-natively t)
  (setq org-default-notes-file elib-user-org-gtd-inbox
        org-use-fast-todo-selection t
        org-src-window-setup 'current-window)
(setq org-preview-latex-default-process 'imagemagick)
      ;; Format is ("options" "package)
      (setq org-startup-with-latex-preview nil)
#+END_SRC

** Style/Look
#+NAME: org-config-style
#+BEGIN_SRC emacs-lisp :tangle no
;; (add-hook 'org-mode-hook 'variable-pitch-mode)
  (use-package org-bullets
    :config
    (add-hook 'org-mode-hook (lambda () (org-bullets-mode t))))

  (setq org-pretty-entities t)
  (setq org-pretty-entities-include-sub-superscripts nil)
  (setq org-hide-emphasis-markers t)
(setq org-startup-indented t)
(setq org-src-preserve-indentation t)
(setq org-src-fontify-natively t)
  (plist-put org-format-latex-options :scale 2)
#+END_SRC

** Org Babel
#+NAME: org-config-babel
#+BEGIN_SRC emacs-lisp :tangle no
(use-package ob
  :ensure nil
  :after org
  :bind (:map org-mode-map
              ("C-c d" . elib-ob-execute-next-block)
              ("C-c M-d" . elib-ob-reset-and-run-all-blocks-in-buffer))
  :preface
  (defun elib-ob-execute-next-block ()
    (interactive)
    (org-babel-next-src-block)
    (org-babel-execute-src-block))
  (defun elib-ob-reset-and-run-all-blocks-in-buffer ()
    (interactive)
    (when (ob-ipython--running-p)
      (ob-ipython-kill-kernel (car (ob-ipython--choose-kernel))))
    (beginning-of-buffer)
    (while (re-search-forward org-babel-src-block-regexp nil t)
      (org-babel-execute-src-block)))
  (defun ob-ipython--collect-json ()
    ;; hacks here
    (when (re-search-forward "{" nil t)
      (backward-char))
    ;; hacks end
    (let ((json-array-type 'list))
      (let (acc)
        (while (not (= (point) (point-max)))
          (setq acc (cons (json-read) acc))
          (forward-line))
        (nreverse acc))))
  :config
  (setq org-confirm-babel-evaluate nil)
  (use-package ob-asymptote
    :ensure org)
  (use-package ob-ipython
    :after ox-latex
    :when (or (file-exists-p "/usr/bin/jupyter")
              (file-exists-p (concat (getenv "HOME") "/.local/bin/jupyter")))
    :config
    (setq ob-ipython-command "jupyter")
    (add-hook 'org-babel-after-execute-hook 'org-display-inline-images 'append)
    )

  (org-babel-do-load-languages
   'org-babel-load-languages
   '((C . t)
     (emacs-lisp . t)
     (python . t)
     (ipython . t)
     (asymptote . t)
     (shell . t)
     (makefile . t)
     (shell . t)
     (latex . t)
     ;; (asm . t)
     (gnuplot . t))))



#+END_SRC

** Exporting and Preview
#+NAME: org-config-export
#+BEGIN_SRC emacs-lisp :tangle no
(setq org-export-async-init-file
      elib-org-async-init-file
      )
(setq org-export-in-background nil
      org-export-async-debug nil)
(load-file (concat user-emacs-config-directory "org-export-config.el"))
#+END_SRC

Since the configuration is used both by the async exporter
and the syncronous one, the configuration is kept in a
separate file that both exporters load. This prevents the
setups from getting out of sync (haha) with each other.
#+BEGIN_SRC emacs-lisp :tangle org-export-config.el
(use-package ox-latex
  :ensure nil
  :config
  (add-to-list-multi 'org-latex-minted-langs
                     (list
                      '(ipython "python")
                      '(C++ "c++")
                      '(c++ "c++")
                      '(C "c++")
                      '(shell "bash")
                      '(sh "bash")
                      '(python "python")
                      '(ruby "ruby")
                      ))
  ;; tell org to use listings
  (setq org-latex-listings 'minted)
  ;; you must include the listings package
 ;; Include shell-espace so we can use minted...
  (setq org-latex-pdf-process
        '("latexmk -pdflatex='pdflatex -shell-escape -bibtex -interaction nonstopmode -output-directory %o'  -pdf -f %f"
          ;; "latexmk -shell-escape -bibtex -interaction nonstopmode -output-directory %o %f"
          ;; "latexmk -shell-escape -bibtex -interaction nonstopmode -output-directory %o %f"
          ))

  (add-to-list-multi 'org-latex-packages-alist
                     (list '("altindent,wide" "eetex")
                           '("newfloat" "minted")
                           '("" "tikz")
                           ;; '("" "listingsutf8")
                           '("" "color")
                           )
                     )

  )
(use-package ox-twbs)
(use-package ox-html
:ensure nil
)
(use-package ox-odt
:ensure nil
)
(use-package ox-md
:ensure nil
)
(use-package ox-ipynb
  :load-path user-emacs-config-directory
  :ensure nil)
(use-package
  ox-reveal
  :config
  (use-package htmlize)
  (setq org-reveal-root "https://cdn.jsdelivr.net/reveal.js/3.0.0/"))
(use-package ox-beamer
  :ensure nil
  )
#+END_SRC

** Capture
:PROPERTIES:
:ID:       284aed85-1e89-4404-833c-9fee55c367f0
:END:
#+NAME: org-config-capture
#+BEGIN_SRC emacs-lisp :tangle no
(use-package org-capture
  :ensure nil
  :commands org-capture
  :bind	 ("C-c c"  . org-capture)
  :config
  (setq org-capture-templates
        '(("a" "Appointment" entry (file  elib-org-gcal-calendar-file-name)
           "* %?\n:PROPERTIES:\n\n:END:\nDEADLINE: %^T \n %i\n" :prepend t)
          ("d" "Deadline" entry (file+headline elib-user-org-gtd-inbox "Inbox: Deadlines")
           "* TODO %?\n:PROPERTIES:\n\n:END:\nDEADLINE: %^T \n %i\n")
          ("t" "To Do Item" entry (file+headline elib-user-org-gtd-inbox "Inbox: Todo")
           "* TODO %?\n%T" :prepend t)
          ("i" "Idea/Thought" entry (file+headline elib-user-org-gtd-inbox "Inbox: Thoughts")
           "* Thought:  %?\n%T" :prepend t)
          ("n" "Note" entry (file+headline elib-user-org-notes-file-name "Unsorted Notes")
           "* Note %?\n%T")
          ("r" "Resource" entry
           (file+headline elib-user-org-resources-file-name "Unsorted")
           "* %? %^L %^g \n%T" :prepend t)
          ("l" "Link" entry (file+headline elib-user-org-links-file-name "Unsorted")
           "* %? \n%^C %^g \n%T" :prepend t)

          ))
  (defun elib-export-org-link-file ()
    (interactive)
    (with-current-buffer
        (find-file elib-user-org-links-file-name)
      (org-twbs-export-to-html)))

  (defadvice org-capture-finalize
      (after delete-capture-frame activate)
    "Advise capture-finalize to close the frame"
    (if (equal "capture" (frame-parameter nil 'name))
        (delete-frame)))

  (defadvice org-capture-destroy
      (after delete-capture-frame activate)
    "Advise capture-destroy to close the frame"
    (if (equal "capture" (frame-parameter nil 'name))
        (delete-frame)))

  (use-package noflet
    :ensure t )
  (defun make-capture-frame ()
    "Create a new frame and run org-capture."
    (interactive)
    (make-frame '((name . "capture")))
    (select-frame-by-name "capture")
    (delete-other-windows)
    (noflet ((switch-to-buffer-other-window (buf) (switch-to-buffer buf)))
      (org-capture))))
#+END_SRC
** Agenda
:PROPERTIES:
:ID:       5132d5c7-4885-4fed-a77f-1421c6684ae9
:END:
#+NAME: org-config-agenda
#+BEGIN_SRC emacs-lisp :tangle no
(use-package org-agenda
  :commands org-agenda
  :ensure nil
  :bind (("\C-ca" . org-agenda))
  :init
(add-to-list-multi 'org-agenda-files (list
                          elib-user-org-gtd-file
                          elib-user-org-gtd-inbox
                          elib-user-org-phone-file
                          elib-org-gcal-calendar-file-name))
(dolist (element elib-org-gcal-ics-list)
           (add-to-list 'org-agenda-files (elt element 2)))
(defvar elib-org-agenda-silent-view
  (delete  elib-org-gcal-hemsidan-ics-org org-agenda-files))
  :config
  (setq org-agenda-custom-commands
        '(("C" "Block agenda"
           ((agenda "" )
            ;; limits the agenda display to a single day
            (todo "" ((org-agenda-files elib-org-agenda-silent-view))))
           ((org-agenda-compact-blocks t))) ;; options set here apply to the entire block
          ;; ...other commands here
          ))
  (setq org-agenda-dim-blocked-tasks nil)
  (setq org-agenda-compact-blocks t)
  )
#+END_SRC

** Refile
:PROPERTIES:
:ID:       d6e57986-c359-4249-93bd-85ec765f1373
:END:
We cannot use use-package here because the refile things are
defined in the same file as the regular
org-functionality. We instead do a hand-made version by
telling emacs to run some code either once it loads [[elisp:(describe-function
 'org-agenda)][`org-agenda']] or, if [[elisp:(describe-function 'org-agenda)][`org-agenda']] is already loaded just load
it immediately. This is done by the [[elisp:(describe-function 'eval-after-load)][`eval-after-load']]
functionality of Emacs.
#+NAME: org-config-refile
#+BEGIN_SRC emacs-lisp :tangle no
(progn
     (setq org-refile-targets
           '((nil :maxlevel . 3)
             (user-org-gtd-file
              :maxlevel . 3)
             (org-gtd-inbox :level . 1)
             (user-org-gtd-inbox :level . 1)
             (config-file-file-name
              :maxlevel . 3)
             (user-org-tickler-file
              :maxlevel . 2))))
#+END_SRC

** Org-ref
#+NAME: org-config-ref
#+BEGIN_SRC emacs-lisp :tangle no
(use-package org-ref
  :init
  :config
(setq org-ref-bibtex-hydra-key-binding "C-c j")
(require 'org-ref-bibtex)
(bind-key "C-c j" 'org-ref-bibtex-hydra/body org-mode-map)
  (use-package helm-bibtex
    :config
    (setq bibtex-completion-bibliography "~/nextcloud/bibliography/general.bib"
          bibtex-completion-library-path "~/nextcloud/bibliography/bibtex-pdfs"
          bibtex-completion-notes-path "~/nextcloud/bibliography/helm-bibtex-notes")
    )



  (setq reftex-default-bibliography "~/nextcloud/bibliography/general.bib")
  (setq org-ref-bibliography-notes "~/nextcloud/bibliography/notes.org"
        org-ref-default-bibliography '("~/nextcloud/bibliography/general.bib")
        org-ref-pdf-directory "~/nextcloud/bibliography/bibtex-pdfs/")
  ;; (setq org-latex-pdf-process (list "latexmk -shell-escape -bibtex -f -pdf %f")
  ;; )
  )
#+END_SRC
** Calendar
:PROPERTIES:
:ID:       84501e67-62f7-4d9b-9af8-37fdd13d20f3
:END:
*** Code Import
#+NAME: org-config-calendar
#+BEGIN_SRC emacs-lisp :tangle no
<<org-calendar-calfw>>
<<org-calendar-fetch>>
<<org-calendar-gcal>>
<<org-calendar-caldav>>
#+END_SRC

*** Calfw
#+NAME: org-config-calendar-calfw
#+BEGIN_SRC emacs-lisp :tangle no
(use-package calfw
  :when (file-exists-p
         elib-user-org-calendar-secrets-file)
  :config
  (defun elib-open-calendar-template ()
    (interactive)
    (cfw:open-calendar-buffer
     :date nil :buffer nil :custom-map nil :view nil
     :sorter nil
     :annotation-sources nil
     :contents-sources
     (list
      (cfw:ical-create-source
       "Gmail" "calendar-address"
       "Blue")
      (cfw:ical-create-source
       "Info"     "calendar-address"
       "Purple")
      (cfw:ical-create-source
       "lu"     "calendar-address"
       "Red")
      (cfw:org-create-source "Red")
      )))
  (use-package calfw-org)
  (use-package calfw-ical)


  (load-file elib-user-org-calendar-secrets-file)
  (bind-key "C-c q" 'elib-open-calendar)
  ;; (setq cfw:org-agenda-schedule-args '(:timestamp))
  (setq cfw:org-overwrite-default-keybinding t)
  (setq calendar-week-start-day 1) ;; 1 = Monday, 0 = Sunday
  )
#+END_SRC
*** Org-Caldav
#+NAME: org-config-calendar-caldav
#+BEGIN_SRC emacs-lisp :tangle no
(load-file elib-user-org-caldav-settings-file)
(use-package org-caldav
  :disabled t
  :after org
  :config
  ;; this hook saves an ics file once an org-buffer is saved
  (use-package oauth2)
  (setq plstore-cache-passphrase-for-symmetric-encryption t)
  (defun my-icalendar-agenda-export()
    (if (member (buffer-file-name) org-agenda-files)
        (org-icalendar-combine-agenda-files)))
  ;; (add-hook 'after-save-hook 'my-icalendar-agenda-export
  ;; )
  ;; (run-with-idle-timer  1200 t  'org-caldav-sync)
  ;; (org-caldav-sync)

  )
(setq org-icalendar-alarm-time 1440)
(setq org-icalendar-combined-name "Org Mode Calendar")
(setq org-icalendar-combined-description "Calendar exported from Org-mode")
(setq org-icalendar-exclude-tags nil)
(setq org-icalendar-combined-agenda-file (expand-file-name "~/nextcloud/org/cal/combined.ics"))
(setq org-icalendar-include-todo 'all)
(setq org-icalendar-use-deadline '(event-if-todo event-if-not-todo))
(setq org-icalendar-use-scheduled '(event-if-todo event-if-not-todo))
(setq org-icalendar-store-UID t)
	 #+END_SRC
*** Org Gcal
**** Org-Fetch
#+NAME: org-config-calendar-fetch
#+BEGIN_SRC emacs-lisp :tangle no
(defun elib-sync-icals ()
  (interactive)
  (save-window-excursion
    (with-temp-buffer
      (let ((default-directory elib-org-calendar-directory))
        (dolist (element elib-org-gcal-ics-list)
          (let ((url (elt element 0))
                (ics-file (elt element 1))
                (org-file (elt element 2)))
            (shell-command (concat "wget " url " -O " ics-file) t)
            (async-shell-command (concat "cabal exec ical-org " ics-file " " org-file) t)
            ))))))
(run-with-idle-timer 3600 t #'elib-sync-icals)
(run-with-idle-timer 5 nil #'elib-sync-icals)
#+END_SRC

**** Package
#+NAME: org-config-calendar-gcal
#+BEGIN_SRC emacs-lisp :tangle no
(use-package org-gcal
  :after org, calfw, org-agenda
  :commands org-gcal-sync
  :init

  :config
  (add-hook 'after-init-hook (lambda ()
                               (message "Starting org-gcal-refresh-timer!")
                               (run-with-timer t 3000 #'org-gcal-refresh-token)
                               ) )
(progn
(add-hook 'org-agenda-mode-hook  (lambda () (org-gcal-sync))))

   )


#+END_SRC
** Table of Content Generation
:PROPERTIES:
:ID:       e4967c66-567f-4fd9-a13c-e41e8b0ad444
:END:
#+BEGIN_SRC emacs-lisp
(use-package toc-org
  :defer 2
  :hook ((org-mode . toc-org-enable)))
#+END_SRC
* Communication
:PROPERTIES:
:ID:       891ec807-5600-43e3-a82d-876ca19fc80b
:END:
** Email
:PROPERTIES:
:ID:       85c9e3ba-bb40-4ac8-93cb-bfd7c1f942b1
:END:
*** Misc
:PROPERTIES:
:ID:       e7f4c7a0-4f14-4a73-8b89-608b1a009cc0
:END:
		#+BEGIN_SRC emacs-lisp
(require 'gnus-dired)
(require 'smtpmail)

;; make the `gnus-dired-mail-buffers' function also work on
;; message-mode derived modes, such as mu4e-compose-mode
(bind-keys* :map dired-mode-map ("a" . gnus-dired-attach))

(defun gnus-dired-mail-buffers ()
  "Return a list of active message buffers."
  (let (buffers)
    (save-current-buffer
      (dolist (buffer (buffer-list t))
	(set-buffer buffer)
	(when (and (derived-mode-p 'message-mode)
		   (null message-sent-message-via))
	  (push (buffer-name buffer) buffers))))
    (nreverse buffers)))
(setq gnus-dired-mail-mode 'mu4e-user-agent)
(add-hook 'dired-mode-hook 'turn-on-gnus-dired-mode)
		#+END_SRC
*** Mu4e
:PROPERTIES:
:ID:       6c9d56eb-6703-49d1-8386-fb44a3db1ee9
:END:
#+BEGIN_SRC emacs-lisp
(defun get-string-from-file (filePath)
  "Return filePath's file content."
  (with-temp-buffer
    (insert-file-contents filePath)
    (buffer-string)))
(defvar elib-info-signature-file (potential-load-paths '("~/.emacs.d/files/info-signature.org")) )


(defun my-mu4e-choose-signature ()
  "Insert one of a number of sigs"
  (interactive)
  (let
      ((message-signature
        (mu4e-read-option
         "Signature:"
         `(("info" .
            ,(get-string-from-file elib-info-signature-file))
           ("swan" .
            "Einar Elén
Secretary of the steering group (SWAN)
")))))
    (message-insert-signature)
(org-mime-htmlize)
))

(defvar mu4e-previous-attachment-directory "~/Downloads")
(defvar mu4e-attachment-dired-buffer nil)
(defvar mu4e-attachment-dired-buffer-name "*mu4e-dired-for-attach*")



(bind-keys*
 :map dired-mode-map
 ("Q" . mu4e-attachment-quit))

(defun start-mu4e-attachment-dired ()
  (interactive)
  ;; (unless (bufferp mu4e-attachment-dired-buffer)
  ;;   (setq mu4e-attachment-dired-buffer
  ;;         (get-buffer-create
  ;;          mu4e-attachment-dired-buffer-name)))
  (dired mu4e-previous-attachment-directory)
  (let ((previous-dired dired-directory))
    (if (y-or-n-p-with-timeout (format "Use previous attachment
  directory, %s? " previous-dired) 4 t)
        (progn (quit-window)
               (dired mu4e-previous-attachment-directory))
      (progn (quit-window)
             (call-interactively 'dired)))))
(defun mu4e-attachment-quit ()
  (interactive)
  (if (equal major-mode 'dired-mode)
      (setq mu4e-previous-attachment-directory
            dired-directory))
  (quit-window))
(defun mu4e-attach-advice (&rest ignored)
  (mu4e-attachment-quit))
(advice-add 'gnus-dired-attach :after #'mu4e-attach-advice)

(when elib-mu4e-load-path
  (use-package mu4e
    :ensure nil
    :bind (("<f12>" . mu4e)
           :map mu4e-compose-mode-map
           ("C-c d" . start-mu4e-attachment-dired)
           )
    :when (executable-find "mu")
    :defer 1
    :init

    (defun choose-msmtp-account ()
      (if (message-mail-p)
          (save-excursion
            (let*
                ((from (save-restriction
                         (message-narrow-to-headers)
                         (message-fetch-field "from")))
                 (case-fold-search t)
                 (account
                  (cond
                   ((string-match "gmail.com" from) "gmail")
                   ((string-match "student.lu.se" from) "lu")
                   ((string-match "luna.lu.se" from) "info"))))
              (setq message-sendmail-extra-arguments (list '"-a" account))))))
    (defun my-mu4e-set-account ()
      "Set the account for composing a message."
      (let* ((account
              (if mu4e-compose-parent-message
                  (let ((maildir (mu4e-message-field mu4e-compose-parent-message :maildir)))
                    (string-match "/\\(.*?\\)/" maildir)
                    (match-string 1 maildir))
                (completing-read (format "Compose with account: (%s) "
                                         (mapconcat #'(lambda (var) (car var))
                                                    my-mu4e-account-alist "/"))
                                 (mapcar #'(lambda (var) (car var)) my-mu4e-account-alist)
                                 nil t nil nil (caar my-mu4e-account-alist))))
             (account-vars (cdr (assoc account my-mu4e-account-alist))))
        (if account-vars
            (mapc #'(lambda (var)
                      (set (car var) (cadr var)))
                  account-vars)
          (error "No email account found"))))
    :load-path elib-mu4e-load-path
    :hook ((mu4e-compose-mode . (lambda ()
                                  (local-set-key
                                   (kbd "C-c C-w")
                                   #'my-mu4e-choose-signature)))
           (message-send-mail . choose-msmtp-account)
           (mu4e-compose-pre . my-mu4e-set-account))
    :config
    (use-package helm-mu
      :after helm
      :bind (:map mu4e-main-mode-map
                  ("s" . helm-mu)
                  ("c" . helm-mu-contacts)
                  :map mu4e-headers-mode-map
                  ("s" . helm-mu)
                  ("c" . helm-mu-contacts)
                  :map mu4e-view-mode-map
                  ("s" . helm-mu))
      :config
      (use-package mu4e-maildirs-extension)
      (use-package mu4e-alert
        :when elib-mu4e-load-path
        :config
        (mu4e-alert-enable-notifications)
        (mu4e-alert-enable-mode-line-display)
        (mu4e-alert-set-default-style 'libnotify))
      (setq helm-mu-contacts-after "01-Jan-2017 00:00:00"))
    (use-package mu4e-contrib
      :ensure nil
      :load-path elib-mu4e-load-path)
    (use-package org-mu4e
      :load-path elib-mu4e-load-path
      :ensure nil
      :after org
      :config
      (setq org-mu4e-link-query-in-headers-mode nil))

    (use-package mu4e-jump-to-list)
    (use-package mu4e-conversation)

    (setq mu4e-maildir "~/Maildir"
          mu4e-sent-messages-behavior 'delete
          mu4e-use-fancy-chars t
          mu4e-attachment-dir "~/Downloads/"
          mu4e-view-show-images t
          mu4e-get-mail-command "mbsync -a"
          mu4e-update-interval 360)
    (setq mu4e-sent-folder "/gmail/sent-mail"
          mu4e-drafts-folder "/gmail/drafts"
          mu4e-trash-folder "/gmail/trash"
          user-mail-address "einar.elen@gmail.com"
          smtpmail-default-smtp-server "smtp.gmail.com"
          ;;smtpmail-local-domain "account1.example.com"
          smtpmail-smtp-server "smtp.gmail.com"
          smtpmail-stream-type 'starttls
          smtpmail-smtp-service 587)


    (defvar my-mu4e-account-alist
      '(("gmail"
         (mu4e-sent-folder "/gmail/sent-mail")
         (mu4e-drafts-folder "/gmail/drafts")
         (mu4e-trash-folder "/gmail/trash")
         (user-full-name "Einar Elén")
         (user-mail-address "einar.elen@gmail.com")
         (smtpmail-default-smtp-server "smtp.gmail.com")
         ;;smtpmail-local-domain "account1.example.com"
         (smtpmail-smtp-server "smtp.gmail.com")
         (smtpmail-stream-type 'starttls)
         (smtpmail-smtp-service 587)
         )
        ("lu"
         (mu4e-sent-folder "/lu/sent-mail")
         (mu4e-drafts-folder "/lu/drafts")
         (mu4e-trash-folder "/lu/trash")
         (user-mail-address "nat13eel@student.lu.se")
         (user-full-name "Einar Elén")
         (smtpmail-default-smtp-server "smtp.gmail.com")
         ;;(smtpmail-local-domain "")
         (smtpmail-smtp-user "nat13eel")
         (smtpmail-smtp-server "smtp.gmail.com")
         (smtpmail-stream-type starttls)
         (smtpmail-smtp-service 465))
        ("info"
         (mu4e-sent-folder "/info/sent-mail")
         (mu4e-drafts-folder "/info/drafts")
         (mu4e-trash-folder "/info/trash")
         (user-mail-address "info-ordf@luna.lu.se")
         (user-full-name "Chairperson, Information Committee (LUNA)")
         (smtpmail-default-smtp-server "smtp.gmail.com")
         ;;(smtpmail-local-domain "")
         (smtpmail-smtp-user "info-ordf")
         (smtpmail-smtp-server "smtp.gmail.com")
         (smtpmail-stream-type starttls)
         (smtpmail-smtp-service 587))
        ))

    (setq message-send-mail-function 'message-send-mail-with-sendmail
          sendmail-program "/usr/bin/msmtp"
          user-full-name "Einar Elén")
    ;; Borrowed from http://ionrock.org/emacs-email-and-mu.html
    ;; Choose account label to feed msmtp -a option based on From header
    ;; in Message buffer; This function must be added to
    ;; message-send-mail-hook for on-the-fly change of From address before
    ;; sending message since message-send-mail-hook is processed right
    ;; before sending message.

    (setq message-sendmail-envelope-from 'header)

(add-to-list-multi
     'mu4e-bookmarks
     `(,(make-mu4e-bookmark
         :name "All New Inbox Mail"
         :query "maildir:/gmail/Inbox OR \
maildir:/lu/Inbox OR maildir:/info/Inbox and flag:unread"
         :key ?z)
       ,(make-mu4e-bookmark
         :name "All Sent Mail"
         :query
         "\"maildir:/gmail/sent-mail\" OR \
\"maildir:/lu/sent-mail\" OR \
maildir:/info/sent-mail"
         :key ?s)
       ,(make-mu4e-bookmark
         :name "With PDF Files"
         :query "mime:application/pdf"
         :key ?P)))
    (setq mu4e-view-prefer-html t)

    (setq mu4e-maildir-shortcuts
          '(("/gmail/Inbox" . ?g)
            ("/gmail/sent-mail" . ?G)
            ("/lu/Inbox" . ?l)
            ("/lu/sent-mail" . ?L)
            ("/info/Inbox" . ?i)
            ("/info/[Gmail]/Skickat" . ?I)
            ("/gmail/[Gmail]/Trash" . ?t)
            ))
    ;; (add-to-list 'mu4e-bookmarks
    ;;              '("maildir:/Gmail/gitorious-ml flag:unread" "Unread on the mailing list" ?m))

    ;; Needed with mbsync, apparently
    (setq mu4e-change-filenames-when-moving t)
    (setq mu4e-html2text-command 'mu4e-shr2text)
    ;; (setq mu4e-html2text-command "w3m -T text/html")
    (setq shr-color-visible-luminance-min 80)

    ;; Experimental
    (setq mu4e-compose-format-flowed nil)
))

(use-package org-mime
  :init
  (defun org-mime-org-buffer-htmlize ()
    "Create an email buffer containing the current org-mode file
  exported to html and encoded in both html and in org formats as
  mime alternatives."
    (interactive)
    (org-mime-send-buffer 'html)
    (message-goto-to))
  (defun mu4e-compose-org-mail ()
    (interactive)
    (mu4e-compose-new)
    (org-mu4e-compose-org-mode))
  ;; this is stolen from John but it didn't work for me until I
  ;; made those changes to mu4e-compose.el
  (defun htmlize-and-send ()
    "When in an org-mu4e-compose-org-mode message, htmlize and send it."
    (interactive)
    (when (member 'org~mu4e-mime-switch-headers-or-body post-command-hook)
      (org-mime-htmlize)
      (org-mu4e-compose-org-mode)
      (mu4e-compose-mode)
      (message-send-and-exit)))

  :config
  ;; This overloads the amazing C-c C-c commands in org-mode with one more function
  ;; namely the htmlize-and-send, above.
  (add-hook 'org-ctrl-c-ctrl-c-hook 'htmlize-and-send t)

  ;; Originally, I set the `mu4e-compose-mode-hook' here, but
  ;; this new hook works much, much better for me.
  (add-hook 'mu4e-compose-post-hook
            (defun do-compose-stuff ()
              "My settings for message composition."
              (org-mu4e-compose-org-mode)))


  )

#+END_SRC
** Web Browsing
:PROPERTIES:
:ID:       d26d51a3-2894-4a4b-abf3-a47859d99fd3
:END:
#+BEGIN_SRC emacs-lisp
(use-package w3m-load
  :when (and (executable-find "w3m") (file-exists-p
                                      "/usr/share/emacs/site-lisp/w3m"))
  :load-path "/usr/share/emacs/site-lisp/w3m/"
  :ensure nil
  )
#+END_SRC
* Utilities
:PROPERTIES:
:ID:       d3f405a0-845a-4217-8767-9ac286ce1107
:END:
** Spell Checking
:PROPERTIES:
:ID:       59f29b06-a01d-4073-a3cd-02ec9d5ec7b8
:END:
*** Abbrev
:PROPERTIES:
:ID:       e06b732b-55ae-45d2-914e-924681806857
:END:
#+BEGIN_SRC emacs-lisp
(setq abbrev-file-name abbrev-location)
(use-package abbrev
  :disabled t
  :ensure nil
  :defer 3
  :config
  ;; (abbrev-mode t)
  (if (file-exists-p abbrev-file-name)
      (quietly-read-abbrev-file)) )
#+END_SRC
*** Flyspell
:PROPERTIES:
:ID:       8a3113a7-f058-4209-8332-49520dc98a0f
:END:
#+BEGIN_SRC emacs-lisp
(use-package flyspell
  :defer 1
  :disabled t
  :custom
  (flyspell-abbrev-p t)
  (flyspell-issue-message-flag nil)
  (flyspell-issue-welcome-flag nil)
  (flyspell-mode 1)
  :config
  (use-package helm-flyspell
    :bind (("C-c ;" . helm-flyspell-correct))))
#+END_SRC
** Google Translate
:PROPERTIES:
:ID:       c39596fe-1f9e-41ac-82e6-588bbedd90b2
:END:
	 #+BEGIN_SRC emacs-lisp
(use-package google-translate
  :config
  (use-package google-translate-smooth-ui
    :ensure nil
    :bind (("C-c t" . 'google-translate-smooth-translate))
    :config
    (setq google-translate-translation-directions-alist
	  '(("sv" . "en") ("en" . "sv")))))
	 #+END_SRC
** Presentations
:PROPERTIES:
:ID:       194829a7-5352-480e-9835-3c20d1e608a3
:END:
	 #+BEGIN_SRC emacs-lisp
(use-package demo-it
	:config)


;(demo-it-create (demo-it-presentation "./configuration.org"))

;(demo-it-start)
	 #+END_SRC

* Experimental
:PROPERTIES:
:ID:       ce0fc4de-8b3b-4cb3-b1f5-796b2a1d1524
:END:
** Emacs Lisp
:PROPERTIES:
:ID:       b5e75921-2a62-41e7-b76c-9aaf7085cb7b
:END:
	 #+BEGIN_SRC emacs-lisp
;(semantic-mode -1)
(use-package org-notes
	:when (file-exists-p "~/ownCloud/projects/elisp/")
	:disabled t
	:load-path "~/ownCloud/projects/elisp/"
	:ensure nil
	:commands (org-notes-mode
						 toggle-org-latex-export-on-save
						 org-notes-cpp-help
						 org-notes-latex-help
						 org-notes-math-help))
(use-package meson-ide
	:when (file-exists-p (expand-file-name "~/meson-ide"))
	:after org-mode
	:disabled t
	:load-path "~/meson-ide"
	:ensure nil
	:defer 3
	:preface
	(defun compile-meson-ide ()
		(when nil (let ((default-directory "~/.emacs.d/org-notes-mode/meson-ide/"))
							(org-babel-tangle-file "meson-ide.org"))))
	(compile-meson-ide)
	:config
	(meson-ide-setup))

(use-package ert
	:commands (ert-deftest ert))
	 #+END_SRC
* To be integrated
** LastPass
#+BEGIN_SRC emacs-lisp
(use-package lastpass
  :config
  (setq lastpass-user user-mail-address))
#+END_SRC

** Python

#+BEGIN_SRC emacs-lisp
(use-package python-mode
  :config
  (setq py-python-command "python3"


        )
  (defun python (&optional argprompt buffer fast exception-buffer split switch)
  "Start an Python interpreter.

Optional ARG \\[universal-argument] prompts for path to the interpreter."
  (interactive "P")
  (py-shell argprompt nil "python3" buffer fast exception-buffer split switch)))
(use-package elpy
  :config
  :disabled t
  (setq python-shell-interpreter "jupyter"
        python-shell-interpreter-args "console --simple-prompt"
        )
  (setq python-shell-interpreter "jupyter"
        python-shell-interpreter-args "console --simple-prompt"
        python-shell-prompt-detect-failure-warning nil)
  (add-to-list 'python-shell-completion-native-disabled-interpreters
               "jupyter")

  (elpy-enable)
  (setq elpy-modules (delq 'elpy-module-flymake elpy-modules))
  (add-hook 'elpy-mode-hook 'flycheck-mode)
  (use-package py-autopep8
    :config
    (add-hook 'elpy-mode-hook 'py-autopep8-enable-on-save))


  ;; (elpy-use-ipython)
  (setq elpy-rpc-python-command "python3"))
(use-package ein
    :config
    (setq ein:jupyter-default-server-command "jupyter")
    (use-package ein-company
      :ensure nil
      :config
      (require 'ein-company)
      )
    )
#+END_SRC
** ?
:PROPERTIES:
:ID:       9dafe517-3d1c-4cd5-9a12-5550abed6e44
:END:
There is only darkness here. Flee.
	#+BEGIN_SRC emacs-lisp
(use-package lorem-ipsum)
(defun rgr/toggle-context-help ()
  "Turn on or off the context help.
Note that if ON and you hide the help buffer then you need to
manually reshow it. A double toggle will make it reappear"
  (interactive)
  (with-current-buffer (help-buffer)
    (unless (local-variable-p 'context-help)
      (set (make-local-variable 'context-help) t))
    (if (setq context-help (not context-help))
	(progn
	  (if (not (get-buffer-window (help-buffer)))
	      (display-buffer (help-buffer)))))
    (message "Context help %s" (if context-help "ON" "OFF"))))

(defun rgr/context-help ()
  "Display function or variable at point in *Help* buffer if visible.
Default behaviour can be turned off by setting the buffer local
context-help to false"
  (interactive)
  (let ((rgr-symbol (symbol-at-point))
        (help-window-select)
        ) ; symbol-at-point http://www.emacswiki.org/cgi-bin/wiki/thingatpt%2B.el
    (with-current-buffer (help-buffer)
      (unless (local-variable-p 'context-help)
        (set (make-local-variable 'context-help) t))
      (if (and context-help (get-buffer-window (help-buffer))
               rgr-symbol)
          (if (fboundp  rgr-symbol)
              (describe-function rgr-symbol)
	    (if (boundp  rgr-symbol) (describe-variable rgr-symbol)))))))

(defadvice eldoc-print-current-symbol-info
    (around eldoc-show-c-tag activate)
  (cond
   ((eq major-mode 'emacs-lisp-mode) (rgr/context-help) ad-do-it)
   ((eq major-mode 'lisp-interaction-mode) (rgr/context-help) ad-do-it)
   ((eq major-mode 'apropos-mode) (rgr/context-help) ad-do-it)
   (t ad-do-it)))

(global-set-key (kbd "C-c C-h") 'rgr/toggle-context-help)

;; (define-minor-mode my-contextual-help-mode
;;   "Displays help for the current symbol whenever the *Help* buffer is visible.

;; Advises `eldoc-print-current-symbol-info'."
;;   :lighter " C-h"
;;   :global t
;;   (require 'help-mode) ;; for `help-xref-interned'
;;   (message "Contextual help is %s" (if my-contextual-help-mode "on" "off"))
;;   (and my-contextual-help-mode
;;        (eldoc-mode 1)
;;        (eldoc-current-symbol)
;;        (my-contextual-help :force)))

;; (defadvice eldoc-print-current-symbol-info (before my-contextual-help activate)
;;   "Triggers contextual elisp *Help*. Enabled by `my-contextual-help-mode'."
;;   (and my-contextual-help-mode
;;        (derived-mode-p 'emacs-lisp-mode)
;;        (my-contextual-help)))

;; (defun my-contextual-help (&optional force)
;;   "Display function or variable at point in *Help* buffer, if visible."
;;   (when (or force (get-buffer-window (help-buffer)))
;;     (let ((sym (eldoc-current-symbol)))
;;       ;; If something else changes the help buffer contents, ensure we
;;       ;; don't immediately revert back to the current symbol's help.
;;       (and sym
;;            (not (keywordp sym))
;;            (not (eq sym (get 'my-contextual-help 'last-sym)))
;;            (put 'my-contextual-help 'last-sym sym)
;;            (save-selected-window
;;              (help-xref-interned sym))))))

;; (my-contextual-help-mode 1)


(use-package nameless
  :after (lisp-mode org-mode)
  :hook ((emacs-lisp-mode org-mode) . nameless-mode))

(use-package xah-replace-pairs
	:commands xah-replace-pairs-region
	:preface
	(defvar multireplace-list nil "Nah.")
	(defvar multireplace-pair-first nil "nah.")
	(defvar multireplace-pair-second nil "nah.")
	(defun multireplace (first second)
		(interactive "r")
		(while (yes-or-no-p "More pairs?")
			(print "1")
			(setq multireplace-pair-first (read-from-minibuffer "First:"))
			(print multireplace-pair-first)
			(setq multireplace-pair-second (read-from-minibuffer "Second:"))
			(print multireplace-pair-second)
			(setq multireplace-list (cons (list multireplace-pair-first multireplace-pair-second) multireplace-list))
			(setq multireplace-pair-first nil multireplace-pair-second nil))
		(xah-replace-pairs-region first second multireplace-list)
		(setq multireplace-list nil multireplace-pair-first nil
					multireplace-pair-second nil))
	:defer 3)


(use-package multiple-cursors
  :bind (("C-M-." . mc/mark-next-like-this))
  )


	#+END_SRC
	#+BEGIN_SRC emacs-lisp
(global-prettify-symbols-mode t)

(defun scratch-here (&optional region-begin region-end)
	"Opens a new scratch-buffer associated with the current buffer to the side of
the current buffer.

If region is active, or REGION-BEGIN and REGION-END are set, insert content of
region into scratch buffer. If associated scratch buffer already exists, open it
and insert region contents at top."
	(interactive (if (use-region-p)
									 (list (region-beginning) (region-end))
								 (list nil nil)))
	(let* ((curr-buffer-name (buffer-name (current-buffer)))
				 (scratch-buffer-name (concat "*scratch " curr-buffer-name "*"))
				 (scratch-buffer (get-buffer-create scratch-buffer-name))
				 (region-string (if (and region-begin region-end)
														(buffer-substring-no-properties region-begin
																														region-end) nil))
				 (scratch-window-open (get-buffer-window scratch-buffer)))
		(if scratch-window-open
				(select-window scratch-window-open)
			(split-window-horizontally)
			(other-window 1)
			(switch-to-buffer scratch-buffer))
		(emacs-lisp-mode)
		(when region-string (insert region-string)))
	(goto-char (point-min)))


(bind-key "<f7>" 'eshell)
(use-package "eshell"
  :ensure nil
  :init
  (bind-key "<f9>" 'eshell-here)
  :config
  (defun eshell-here ()
    "Opens up a new shell in the directory associated with the
current buffer's file. The eshell is renamed to match that
directory to make multiple eshell windows easier."
    (interactive)
    (let* ((parent (if (buffer-file-name)
		       (file-name-directory (buffer-file-name))
		     default-directory))
	   (height (/ (window-total-height) 3))
	   (name   (car (last (split-string parent "/" t))))
	   (_eshell-name (concat "*eshell: " name "*"))
	   (already-existing (get-buffer _eshell-name)))
      (split-window-vertically (- height))
      (other-window 1)
      (if already-existing
	  (switch-to-buffer _eshell-name)
	(eshell "new")
	(rename-buffer _eshell-name))
      (insert (concat "ls"))
      (eshell-send-input)))

  (require 'em-tramp)
  (setq password-cache t)
  (setq password-cache-expiry 3600)

  (with-eval-after-load 'esh-module
    ;; REVIEW: It used to work, but now the early `provide' seems to backfire.
    (unless (boundp 'eshell-modules-list)
      (load "esh-module"))
    ;; Don't print the banner.
    (delq 'eshell-banner eshell-modules-list)
    (push 'eshell-tramp eshell-modules-list))

  (setq
   eshell-ls-use-colors t
   ;; ffap-shell-prompt-regexp changes the behaviour of `helm-find-files' when
   ;; point is on prompt. I find this disturbing.
   ffap-shell-prompt-regexp nil
   eshell-history-size 262144
   eshell-hist-ignoredups t
   eshell-destroy-buffer-when-process-dies t)

  (defun ambrevar/eshell-prompt ()
    (let ((path (abbreviate-file-name (eshell/pwd))))
      (concat
       (when ambrevar/eshell-status-p
         (propertize (or (ambrevar/eshell-status-display) "") 'face font-lock-comment-face))
       (format
        (propertize "(%s@%s)" 'face '(:weight bold))
        (propertize (user-login-name) 'face '(:foreground "cyan"))
        (propertize (system-name) 'face '(:foreground "cyan")))
       (if (and (require 'magit nil t) (or (magit-get-current-branch) (magit-get-current-tag)))
           (let* ((prefix (abbreviate-file-name (magit-rev-parse "--show-prefix")))
                  (before-prefix (substring-no-properties path nil (when (/= 0 (length prefix)) (- (length prefix))))))
             (format
              (propertize "[%s/%s@%s]" 'face '(:weight bold))
              (propertize before-prefix 'face `(:foreground ,(if (= (user-uid) 0) "red" "green") :weight bold))
              (propertize prefix 'face `(:foreground ,(if (= (user-uid) 0) "orange" "gold")))
              (or (magit-get-current-branch) (magit-get-current-tag))))
         (format
          (propertize "[%s]" 'face '(:weight bold))
          (propertize path 'face `(:foreground ,(if (= (user-uid) 0) "red" "green") :weight bold))))
       (propertize "\nÎ»$" 'face '(:weight bold))
       " ")))

;;; Leave `eshell-highlight-prompt' to t as it sets the read-only property.
  (setq eshell-prompt-function #'ambrevar/eshell-prompt)
;;; If the prompt spans over multiple lines, the regexp should match
;;; last line only.
  (setq-default eshell-prompt-regexp "^Î»$ ")

  (with-eval-after-load 'em-term
    (dolist (p '("abook" "alsamixer" "cmus" "fzf" "gtypist" "htop" "mpsyt" "mpv" "mutt" "ncdu" "newsbeuter" "pinentry-curses" "ranger" "ssh" "watch" "wifi-menu"))
      (add-to-list 'eshell-visual-commands p))
    (setq eshell-visual-subcommands
          ;; Some Git commands use a pager by default.
          ;; Either invoke the subcommands in a term ("visual") or configure Git
          ;; to disable the pager globally.
          ;; '(("git" "log" "diff" "show")
          '(("sudo" "wifi-menu")        ; Arch Linux
            ("sudo" "vi" "visudo"))))

;;; Alias management possibilities:
;;; - Version eshell-alias and store it in user-emacs-directory. Simplest and
;;; fastest, but aliases cannot be included conditionnaly, e.g. depending on the
;;; existence of a program.
;;; - Store eshell-alias in cache and populate it dynamically on startup.
  ;; (setq eshell-aliases-file (concat user-emacs-directory "eshell-alias"))
;;;
;;; `eshell/alias' is too slow as it reads and write the file on each definition.
;;; Let's write manually instead.
  (with-eval-after-load 'em-alias
;;; If we read the alias list here, it means we make commandline-defined aliases persistent.
    ;; (eshell-read-aliases-list)
    (dolist
        (alias
         '(("l" "ls -1 $*")
           ("la" "ls -lAh $*")
           ("ll" "ls -lh $*")
           ;; TODO: Aliasing eshell/{cp,mv,ln} does not work.
           ;; REVIEW: Eshell/TRAMP's sudo does not work with aliases.
           ;; See #28320, #27168.
           ;; ("ls" "ls -F $*") ; not supported
           ;; ("emacs" "find-file $1")
           ;; ("cp" "eshell/cp -iv $*")
           ;; ("mv" "eshell/mv -iv $*")
	   ("ff" "find-file $1")
	   ("FF" "sudo-find-file $1")
	   ("d" "dired $1")
           ("cpv" "cp -iv $*")
           ("mvv" "mv -iv $*")
           ("rmv" "rm -v $*")
           ("md" "eshell/mkdir -p $*")
           ("mkcd" "eshell/mkdir -p $* ; cd $1"))) ; TODO: '&&' does not work because mkdir exits with nil?
      (add-to-list 'eshell-command-aliases-list alias))
    (eshell-write-aliases-list))

;;; Hooks
;;; `nobreak-char-display' makes some output look weird, e.g. with 'tree'.
                                        ;(add-hook 'eshell-mode-hook 'ambrevar/turn-off-nobreak-char-display)

;;; History
;;; Filter out space-beginning commands from history.
;;; TODO: history/command hook: trim spaces.  Check `eshell-rewrite-command-hook'.
;;; TODO: history: do not save failed Eshell commands (See `eshell-last-command-status')
;;; Eshell commands always return 0.
  (setq eshell-input-filter
        (lambda (str)
          (not (or
                ;; Here we can filter out failing commands.  This is usually a bad
                ;; idea since a lot of useful commands have non-zero exit codes
                ;; (including Emacs/Eshell functions).
                ;; (/= eshell-last-command-status 0)
                (string= "" str)
                (string-prefix-p " " str)))))

;;; Shared history.
  (defvar ambrevar/eshell-history-global-ring nil
    "The history ring shared across Eshell sessions.")

  (defun ambrevar/eshell-hist-use-global-history ()
    "Make Eshell history shared across different sessions."
    (unless ambrevar/eshell-history-global-ring
      (when eshell-history-file-name
        (eshell-read-history nil t))
      (setq ambrevar/eshell-history-global-ring (or eshell-history-ring (make-ring eshell-history-size))))
    (setq eshell-history-ring ambrevar/eshell-history-global-ring))
  (add-hook 'eshell-mode-hook 'ambrevar/eshell-hist-use-global-history)

;;; Spawning
  (defun ambrevar/eshell-or-new-session (&optional arg)
    "Create an interactive Eshell buffer.
Switch to last Eshell session if any.
Otherwise create a new one and switch to it.
See `eshell' for the numeric prefix ARG."
    (interactive "P")
    (if (or arg (eq major-mode 'eshell-mode))
        (eshell (or arg t))
      (let ((last (buffer-list)))
        (while (and last
                    (not (with-current-buffer (car last)
                           (eq major-mode 'eshell-mode))))
          (setq last (cdr last)))
        (if last
            (switch-to-buffer (car last))
          (eshell (or arg t))))))

;;; Auto-suggestion - esh-autosuggest
  (use-package esh-autosuggest
    :ensure t)
  (when (require 'esh-autosuggest nil t)
    (setq esh-autosuggest-delay 0.75)
    (add-hook 'eshell-mode-hook 'esh-autosuggest-mode)
    (define-key esh-autosuggest-active-map (kbd "<tab>") 'company-complete-selection)
    (when (require 'helm-config nil t)
      (define-key company-active-map (kbd "M-p") 'helm-eshell-history)))

;;; Kaushal's seconds to human-readable time - https://scripter.co/convert-seconds-to-human-time/ [Your car will be ready in 8000 seconds]
  (defun modi/seconds-to-human-time (&optional seconds)
    "Convert SECONDS to \"DDd HHh MMm SSs\" string.

SECONDS is a non-negative integer or fractional number.

SECONDS can also be a list of such numbers, which is the case
when this function is called recursively.

When called interactively, if a region is selected SECONDS is
extracted from that, else the user is prompted to enter those."
    (interactive)
    (let ((inter (called-interactively-p 'interactive)))
      (when inter
        (let ((seconds-str (if (use-region-p)
                               (buffer-substring-no-properties (region-beginning) (region-end))
                             (read-string "Enter seconds: "))))
          (setq seconds (string-to-number seconds-str)))) ;"1" -> 1, "1.2" -> 1.2, "" -> 0
      (let* ((MINUTE 60)
             (HOUR (* 60 MINUTE))
             (DAY (* 24 HOUR))
             (sec (cond
                   ((listp seconds) ;This is entered only by recursive calls
                    (car (last seconds)))
                   ((and (numberp seconds) ;This is entered only in the first entry
                         (>= seconds 0))
                    seconds)
                   (t
                    (user-error "Invalid argument %S" seconds))))
             (gen-time-string
              (lambda (time inter)
                "Return string representation of TIME.
TIME is of the type (DD HH MM SS), where each of those elements
are numbers.  If INTER is non-nil, echo the time string in a
well-formatted manner instead of returning it."
                (let ((filler "    ")
                      (str ""))
                  (dolist (unit '("d" "h" "m" "s"))
                    (let* ((val (car (rassoc unit time)))
                           (val-str (cond
                                     ((and (string= unit "s") ;0 seconds
                                           (= val 0)
                                           (string-match-p "\\`\\s-*\\'" str))
                                      " 0s")
                                     ((and (string= unit "s")
                                           (> val 0))
                                      (if (integerp val)
                                          (format "%2d%s" val unit)
                                        (format "%5.2f%s" val unit)))
                                     ((and val (> val 0))
                                      (format "%2d%s " val unit))
                                     (t
                                      filler))))
                      (setq str (concat str val-str))))
                  ;; (message "debug: %S" time)
                  (if inter
                      (message "%0.2f seconds â %s"
                               seconds
                               (string-trim (replace-regexp-in-string " +"  " " str)))
                    (string-trim-right str)))))
             (time (cond
                    ((>= sec DAY)       ;> day
                     (let* ((days (/ (floor sec) DAY))
                            (rem (- sec (* days DAY))))
                       ;; Note that (list rem) instead of just `rem' is
                       ;; being passed to the recursive call to
                       ;; `modi/seconds-to-human-time'.  This helps us
                       ;; distinguish between direct and re-entrant
                       ;; calls to this function.
                       (append (list (cons days "d")) (modi/seconds-to-human-time (list rem)))))
                    ((>= sec HOUR)      ;> hour AND < day
                     (let* ((hours (/ (floor sec) HOUR))
                            (rem (- sec (* hours HOUR))))
                       (append (list (cons hours "h")) (modi/seconds-to-human-time (list rem)))))
                    ((>= sec MINUTE)    ;> minute AND < hour
                     (let* ((mins (/ (floor sec) MINUTE))
                            (rem (- sec (* mins MINUTE))))
                       (append (list (cons mins "m")) (modi/seconds-to-human-time (list rem)))))
                    (t                  ;< minute
                     (list (cons sec "s"))))))
        ;; If `seconds' is a number and not a list, this is *not* a
        ;; recursive call.  Return the time as a string only then.  For
        ;; re-entrant executions, return the `time' list instead.
        (if (numberp seconds)
            (funcall gen-time-string time inter)
          time))))

;;; Extra execution information
  (defvar ambrevar/eshell-status-p t
    "If non-nil, display status before prompt.")
  (defvar ambrevar/eshell-status--last-command-time nil)
  (make-variable-buffer-local 'ambrevar/eshell-status--last-command-time)
  (defvar ambrevar/eshell-status-min-duration-before-display 1
    "If a command takes more time than this, display its duration.")

  (defun ambrevar/eshell-status-display ()
    (when ambrevar/eshell-status--last-command-time
      (let ((duration (time-subtract (current-time) ambrevar/eshell-status--last-command-time)))
        (setq ambrevar/eshell-status--last-command-time nil)
        (when (> (time-to-seconds duration) ambrevar/eshell-status-min-duration-before-display)
          (format "#[STATUS] End time %s, duration: %s\n"
                  (format-time-string "%F %T" (current-time))
                  (modi/seconds-to-human-time (time-to-seconds duration)))))))
  ;; (format "#[STATUS] End time %s, duration %.3fs\n"
  ;;         (format-time-string "%F %T" (current-time))
  ;;         (time-to-seconds duration))))))


  (defun ambrevar/eshell-status-record ()
    (setq ambrevar/eshell-status--last-command-time (current-time)))

  (add-hook 'eshell-pre-command-hook 'ambrevar/eshell-status-record)

;;; Detach
  (when (require 'package-eshell-detach nil t)
    (defun ambrevar/eshell-detach-set-keys ()
      (define-key eshell-mode-map (kbd "C-c C-z") 'eshell-detach-stop)
      (define-key eshell-mode-map (kbd "S-<return>") 'eshell-detach-send-input)
      (define-key eshell-mode-map (kbd "C-<return>") 'eshell-detach-attach))
    (add-hook 'eshell-mode-hook 'ambrevar/eshell-detach-set-keys))

  ;; Man
  (when (string= (file-symlink-p (executable-find "man")) "mandoc")
    ;; Some systems like Void Linux use mandoc instead of man and do not know the
    ;; --nj, --nh flags.
    (defun ambrevar/pcmpl-args-mandoc-man-function (name)
      (let ((process-environment process-environment))
        ;; Setting MANWIDTH to a high number makes most paragraphs fit on a single
        ;; line, reducing the number of false positives that result from lines
        ;; starting with `-' that aren't really options.
        (push "MANWIDTH=10000" process-environment)
        (pcmpl-args-process-file "man" "--" name)))
    (setq pcmpl-args-man-function 'ambrevar/pcmpl-args-mandoc-man-function))

  ;; Completion
  (when (require 'bash-completion nil t)
    (when (and (or (executable-find "fish")
                   ;; "fish" needs not be in PATH with guix.
                   (executable-find "guix"))
               (require 'fish-completion nil t))
      (setq fish-completion-fallback-on-bash-p t)
      (global-fish-completion-mode)))



  (use-package "em-smart"
    :ensure nil
    :config
    (setq eshell-where-to-jump 'begin)
    (setq eshell-review-quick-commands nil)
    (setq eshell-smart-space-goes-to-end t))
  (require 'em-smart)
  (setq eshell-where-to-jump 'begin)
  (setq eshell-review-quick-commands nil)
  (setq eshell-smart-space-goes-to-end t)
  (add-hook 'eshell-mode-hook 'eshell-smart-initialize)
  (eshell-smart-initialize)
  (defun eshell/x ()
    (insert "exit")
    (eshell-send-input)
    (delete-window))
  (setq eshell-aliases-file
        (concat user-emacs-config-directory ".eshell-aliases"))

  (use-package helm-eshell
    :ensure nil
    )

  ;; (add-hook 'eshell-mode-hook
  ;;           (lambda ()
  ;;             (define-key eshell-mode-map
  ;;               (kbd "M-p")
  ;;               'helm-eshell-history)))
  ;; (defun pcomplete/sudo ()
  ;;   (let ((prec (pcomplete-arg 'last -1)))
  ;;     (cond ((string= "sudo" prec)
  ;;            (while (pcomplete-here*
  ;;                    (funcall pcomplete-command-completion-function)
  ;;                    (pcomplete-arg 'last) t))))))
  ;; (add-hook 'eshell-mode-hook
  ;;           (lambda ()
  ;;             (eshell-cmpl-initialize)
  ;;             (define-key eshell-mode-map
  ;;               [remap eshell-pcomplete] 'helm-esh-pcomplete)
  ;;             (define-key eshell-mode-map
  ;;               (kbd "M-p") 'helm-eshell-history)))
  )

(use-package dash)
(use-package tco)
(use-package equake
  :ensure t

  :config

                                        ; some examples of optional settings follow:
  (global-set-key (kbd "C-x C-c") 'equake-check-if-in-equake-frame-before-closing) ; prevent accidental frame-closure
  (setq equake-size-width 0.99) ; set width a bit less than full-screen (prevent 'overflow' on multi-monitor)
  ;; set distinct face for Equake: white foreground with dark blue background, and different font
  (set-face-attribute 'equake-buffer-face 'nil :inherit 'default :family "DejaVu Sans Mono" :background "#000000" :foreground "white"))




(use-package expand-region
  :defer 3
  :config
  (global-set-key (kbd "C-=") 'er/expand-region)
  )
	#+END_SRC
	#+BEGIN_SRC emacs-lisp
(defun xah-change-bracket-pairs ( *fromType *toType *begin *end)
  "Change bracket pairs from one type to another on current line or selection.
					For example, change all parenthesis () to square brackets [].

					When called in lisp program, *begin *end are region begin/end position, *fromType or *toType is a string of a bracket pair. \u2056 \"()\",  \"[]\", etc.
					URL `http://ergoemacs.org/emacs/elisp_change_brackets.html'
					Version 2016-11-04"
  (interactive
   (let ((-bracketsList
	  '("() paren"
	    "{} braces" "[] square"
	    "<> greater"
	    "\u201c\u201d curly quote"
	    "\u2018\u2019 single"
	    "\u2039\u203a french"
	    "«» double french"
	    "\u300c\u300d corner"
	    "\u300e\u300f double corner"
	    "\u3010\u3011 LENTICULAR"
	    "\u3016\u3017 white LENTICULAR"
	    "\u300a\u300b double angle"
	    "\u3008\u3009 angle "
	    "\u3014\u3015 TORTOISE"
	    "\u2985\u2986 white paren"
	    "\u301a\u301b white square"
	    "\u2983\u2984 white braces"
	    "\u2329\u232a"
	    "\u2991\u2992"
	    "\u29fc\u29fd"
	    "\u27e6\u27e7 math square"
	    "\u27e8\u27e9 math angle"
	    "\u27ea\u27eb"
	    "\u27ee\u27ef"
	    "\u27ec\u27ed"
	    "\u275b\u275c"
	    "\u275d\u275e"
	    "\u2768\u2769"
	    "\u276a\u276b"
	    "\u2774\u2775"
	    "\u276c\u276d"
	    "\u276e\u276f"
	    "\u2770\u2771"
	    "   none"
	    )))
     (list
      (helm-comp-read "Replace this:" -bracketsList )
      (helm-comp-read "To:" -bracketsList )
      (if (use-region-p) (region-beginning) nil)
      (if (use-region-p) (region-end) nil))))
  (save-excursion
    (save-restriction
      (when (null *begin)
	(setq *begin (line-beginning-position))
	(setq *end (line-end-position)))
      (narrow-to-region *begin *end)
      (let ( (case-fold-search nil)
	     (-fromLeft (substring *fromType 0 1))
	     (-toLeft (if (string-equal (substring *toType 0 1) " ")
			  (progn "")
			(substring *toType 0 1)))
	     (-fromRight (substring *fromType 1 2))
	     (-toRight (if (string-equal (substring *toType 1 2) " ")
			   (progn "")
			 (substring *toType 1 2))))
	(progn
	  (goto-char (point-min))
	  (while (search-forward -fromLeft nil t)
	    (overlay-put (make-overlay (match-beginning 0) (match-end 0)) 'face 'highlight)
	    (replace-match -toLeft 'FIXEDCASE 'LITERAL)))
	(progn
	  (goto-char (point-min))
	  (while (search-forward -fromRight nil t)
	    (overlay-put (make-overlay (match-beginning 0) (match-end 0)) 'face 'highlight)
	    (replace-match -toRight 'FIXEDCASE 'LITERAL)))))))

(use-package server
  :commands (server-running-p server-start)
  :config
  (unless (server-running-p)
    (server-start)
    ))
;; (unless (get-buffer "*Standalone Eshell*")
;;   (save-window-excursion
;;     (eshell)
;;     (rename-buffer "*Standalone Eshell*")))
;; (defun goto-standalone-eshell ()
;;   (interactive)
;;   (switch-to-buffer "*Standalone Eshell*"))
(use-package macrostep
	:after lisp-mode
	)

;; (use-package spacemacs-theme
;; :ensure t
;; :defer nil
;; )
;;  (load-theme 'spacemacs-dark t)
	#+END_SRC

** ESUP
:PROPERTIES:
:ID:       08422b75-c0c1-488d-98a5-ca9ea3007865
:END:
	 #+BEGIN_SRC emacs-lisp
(use-package f
	:defer 3
	)
(use-package esup
	:after f
	:preface
	)
(defun esup-without-byte-compiler ()
	(interactive)
	(let ((esupfile (make-temp-file "esup")))
		(save-window-excursion
			(find-file (expand-file-name esupfile))
			(insert "(require 'package)
	(setq package-enable-at-startup nil)
	(add-to-list 'package-archives
							 '(\"melpa\" . \"http://melpa.org/packages/\") t)
	(add-to-list 'package-archives
							 '(\"org\" . \"http://orgmode.org/elpa/\") t)
	(require 'use-package)
	(unless (package-installed-p 'use-package)
		(package-refresh-contents)
		(package-install 'use-package))
	;(eval-when-compile (require 'use-package))
	(setq use-package-debug nil)
																				;(setq use-package-verbose 'debug)
	(setq use-package-verbose nil)

	(setq use-package-always-ensure t)\n")
			(insert-file-contents "~/.emacs.d/configuration.el")
			(save-buffer)
			(esup (expand-file-name esupfile))
			)))
(defvar generate-init-file-name
	"configuration-debug.el")
(defun generate-init-file ()
	(interactive)
	(org-babel-tangle-file "~/.emacs.d/configuration.org")
	(save-window-excursion
		(let ((to-delete (find-file generate-init-file-name)))
			(erase-buffer)
			(goto-char (point-max))
			(insert-file-contents "~/.emacs.d/configuration.el")
			(goto-char (point-max))
		 (insert "\n")
		 (save-buffer)
		 )))

	 #+END_SRC
** Disabled Stuff
:PROPERTIES:
:ID:       eba4b8c9-1906-4da1-bdbb-a392ba6b0f2e
:END:

*** Language Tool
:PROPERTIES:
:ID:       77de540d-80d0-4d49-ad45-374160838bdc
:END:
	 #+BEGIN_SRC emacs-lisp
(defun locate-langtool ()
  (or (executable-find "languagetool")
      (executable-find "langtool")))
(use-package langtool
  :disabled t
  :when (locate-langtool)
  :config
  (setq langtool-bin (locate-langtool))
  (setq langtool-language-tool-jar (locate-langtool))
  (setq langtool-default-language "en-GB"))
;(langtool-check-buffer)
	 #+END_SRC

* EXWM
Emacs has a complete window manager implemented in it. This
is both crazy and great. I use it some of the time when I
work. My startup script calls emacs with the argument
"--exwm" so we enable exwm only when it is called that way.

** Config
#+BEGIN_SRC emacs-lisp
(defun elib-toggle-kbd-language ()
  (interactive)
  (shell-command "xkb-switch -n" t))

(defun elib-exwm-launch  (command)
                        (interactive (list (read-shell-command "$ ")))
                        (start-process-shell-command command nil command))

(defvar elib-exwm-workspace-window-assignments
  '(("Google-chrome")))
(defun elib-exwm-init-buffers ()
  (interactive)
  (save-excursion
    (exwm-workspace-switch-create 2)
    (elib-exwm-launch "google-chrome")

    (exwm-workspace-switch-create 3)
    (elib-exwm-launch "gnome-control-center bluetooth")
    (split-window-horizontally)
    (other-window 1)
    (elib-exwm-launch "pavucontrol")
    (split-window)
    (other-window 1)
    (elib-exwm-launch "blueman-manager")
    )
  )


(defun elib-exwm-config ()
  (setq mouse-autoselect-window t)
  (setq focus-follows-mouse t)
  (setq exwm-workspace-number 4)
  (setq exwm-systemtray-height 24)
  (define-key exwm-mode-map (kbd "C-c C-j") 'exwm-input-grab-keyboard)
  ;; Make class name the buffer name

  (add-hook 'exwm-update-class-hook
            (lambda ()
              (exwm-workspace-rename-buffer exwm-class-name)))
  (exwm-input-set-key (kbd "s-<return>") #'dmenu)
  ;; 's-r': Reset
  (exwm-input-set-key (kbd "s-r") #'exwm-reset)
  (exwm-input-set-key (kbd "s-C-r") #'exwm-restart)
  ;; 's-w': Switch workspace
  (exwm-input-set-key (kbd "s-w") #'exwm-workspace-switch)
  (exwm-input-set-key (kbd "s-SPC") #'elib-toggle-kbd-language)
  ;; 's-N': Switch to certain workspace
  (dotimes (i 10)
    (exwm-input-set-key (kbd (format "s-%d" i))
                        `(lambda ()
                           (interactive)
                           (exwm-workspace-switch-create ,i))))
  ;; 's-&': Launch application
  (exwm-input-set-key (kbd "s-&") #'elib-exwm-launch
                      )
  (exwm-input-set-key (kbd "s-o") #'other-window)
  (exwm-input-set-key (kbd "s-j") #'exwm-input-grab-keyboard)

  (setq exwm-input-simulation-keys
        '(
          ;; movement
          ([?\C-b] . [left])
          ([?\M-b] . [C-left])
          ([?\C-f] . [right])
          ([?\M-f] . [C-right])
          ([?\C-p] . [up])
          ([?\C-n] . [down])
          ([?\C-a] . [home])
          ([?\C-e] . [end])
          ([?\M-v] . [prior])
          ([?\C-v] . [next])
          ([?\C-d] . [delete])
          ([?\C-k] . [S-end delete])
          ;; cut/paste.
          ([?\C-w] . [?\C-x])
          ([?\M-w] . [?\C-c])
          ([?\C-y] . [?\C-v])
          ;; search
          ([?\C-s] . [?\C-f])))
  (menu-bar-mode 1)
  (tool-bar-mode -1)
  (exwm-enable)
  (use-package dmenu
    :config
    (exwm-input-set-key (kbd "C-s-SPC") #'dmenu)
    )
  )





#+END_SRC


** Setup
:PROPERTIES:
:ID:       aa1694a9-e7c5-41ac-88ca-bc1474edc5ae
:END:
#+BEGIN_SRC emacs-lisp
(if (member "--exwm" command-line-args)
    (use-package exwm
      :config
      (require 'exwm-systemtray)
      (exwm-systemtray-enable)
      (add-to-list 'helm-source-names-using-follow "EXWM buffers")
      (use-package helm-exwm)
      (elib-exwm-config)
      (exwm-enable)
      (helm-themes))
  (load-theme 'spacemacs-dark t))
#+END_SRC

* Enable Custom Keybindings
