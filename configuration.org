#+AUTHOR: Einar Elén
#+EMAIL: einar.elen@gmail.com
#+OPTIONS: toc:3 html5-fancy org-html-preamble:nil
#+HTML_DOCTYPE_HTML5: t
#+PROPERTY: header-args :tangle yes
#+STARTUP: noinlineimages
* Emacs
:PROPERTIES:
:ID:       98e63f19-0f9f-4d64-8679-f73f25010c4e
:END:
** Definitions and Variables
:PROPERTIES:
:ID:       7ace9abf-9530-423a-927f-a024a8c67df5
:END:
*** Handy lisp functions and macros                                :ignore:
:PROPERTIES:
:ID:       b69b0adc-9d96-436d-87cc-623dd2210280
:END:
#+BEGIN_SRC emacs-lisp 
(eval-when-compile
  (defun potential-load-paths (list)
    (let ((value))
      (dolist (elt list value)
	(when (and (not value) (file-exists-p elt))
	  (setq value (expand-file-name elt))))
      value)))
(defmacro alist-get-equal (key alist &optional default
			       remove)
  "A call to `alist-get' with testfn set to `equal'"
  `(alist-get ,key ,alist ,default ,remove 'equal))


(defmacro alist-get-equal-simple (key alist)
  "A call to `alist-get' with default and remove set to
  nil and testfn set to `equal'

  In reality, a call to `alist-get-equal' with default and
  remove set to nil."
  `(alist-get-equal ,key ,alist nil nil))

(defmacro add-to-list-multi (lst elts &optional append compare-fn)
  "Call `add-to-list' for each element in ELTS to LST."
  `(dolist (x ,elts)
     (add-to-list ,lst x ,append ,compare-fn)))


(defun add-to-list-force (lst elt)
  "If the car of ELT is a key in LST, replace the value with the
value from ELT. Otherwise, call `add-to-list'"
  (if (assoc (car elt) lst)
      (setf
       (cdr (assoc (car elt) lst))
       (cdr elt))
    (add-to-list 'lst elt)))
#+END_SRC
*** Definitions                                                   :ignore:
:PROPERTIES:
:ID:       3e2c6e03-2178-42d9-be36-b0f978dbaecd
:END:
These exist because the emacs byte-compiler cannot be sure
that these variables and functions are actually defined. As
we know that they are, we can tell it to relax!

You should in general never need to care about this
section. We also define a customization group called [[elisp:(customize-group 'elib)][`elib']]
that can be used for any customizations we create later.

#+BEGIN_SRC emacs-lisp 
(eval-when-compile
    (defvar mac-command-modifier)
  (defvar flycheck-highlighting-mode)
  (defvar flycheck-check-syntax-automatically)
  (defvar TeX-view-program-selection)
  (defvar elib-helm-tex-alist)
  (defvar TeX-view-program-list)
  (defvar with-editor-emacsclient-executable)
  (defvar compilation-read-command)
  (setq ad-redefinition-action 'accept))
#+END_SRC
*** Customization Groups
:PROPERTIES:
:ID:       43a45132-8b1d-4179-8f56-60acd084d17c
:END:
Customization groups makes making changes simpler and
exploring the configurations and definitions that are made
in this file. If you want to start exploring, try calling [[elisp:(describe-function
 'customize-group)][`customize-group']] and looking into the base group [[elisp:(customize-group 'elib)][`elib']].

Currently the subgroups of [[elisp:(customize-group 'elib)][`elib']] are
- [[elisp:(customize-group 'elib-file-paths)][`elib-file-paths']]
  - Contains file paths that you can customize
- [[elisp:(customize-group 'elib-calendar)][`elib-calendar']]
  - Things related to [[elisp:(describe-package 'calfw)][`calfw']] and [[elisp:(describe-function 'org-gcal)][`org-gcal']] that provide
    calendar functionality for emacs
  - [[elisp:(customize-group 'elib-org)][`elib-org']]
    - Contains org-mode related configuration
  - [[elisp:(customize-group 'elib-helm-tex)][`elib-helm-tex']]
    - Configuration for the [[elisp:(describe-function 'elib-helm-tex-choose-program)][`elib-helm-tex-choose-program']] function
    - Subgroups for three possible pdf-viewers
      1) [[elisp:(customize-group 'elib-helm-tex-pdf-tools)][`elib-helm-tex-pdf-tools']]
      2) [[elisp:(customize-group 'elib-helm-tex-okular)][`elib-helm-tex-okular']]
      3) [[elisp:(customize-group 'elib-helm-tex-evince)][`elib-helm-tex-evince']]
#+BEGIN_SRC emacs-lisp
  (eval-when-compile
    (defgroup elib nil
      "Overarching customization group for any custom groups
    created in `config-file-file-name'."
      :tag "*elib*")

    (defgroup elib-file-paths nil
      "Customization group for file-paths."
      :group 'elib
      :tag "elib-file-paths")
    (defgroup elib-calendar nil
      "Customization group for `calfw' and `org-gcal'."
      :tag "elib-calendar"
      :group 'elib-)
    (defgroup elib-org nil
      "Customization group for `org-mode'."
      :tag "elib-org"
      :group 'elib)

    (defgroup elib-helm-tex nil
      "Customization group for the\
    `elib-helm-tex-choose-program' function."
      :tag "elib-helm-TeX"
      :group 'elib)
    (defgroup elib-helm-tex-pdf-tools nil
      "Customization group for the PDF-tools reader\
   for the `elib-helm-tex'-group."
      :tag "elib-'helm-TeX-PDF-tools"
      :group 'elib-helm-tex)
    (defgroup elib-helm-tex-okular nil
      "Customization group for the Okular reader for\
   the `elib-helm-tex'-group."
      :tag "elib-helm-TeX-Okular"
      :group 'elib-helm-tex)
    (defgroup elib-helm-tex-evince nil
      "Customization group for the Evince reader for\
   the `elib-helm-tex'-group."
      :tag "elib-helm-TeX-Evince"
      :group 'elib-helm-tex)
    )
#+END_SRC
*** User variables
:PROPERTIES:
:ID:       db82c885-b522-451d-9a7e-9928d2b54395
:END:
**** Personal Information                                         :Update:
:PROPERTIES:
:ID:       942248fc-6008-48a1-8ab7-a7097851aff9
:END:
Here we set all important personal details.
- Your name in [[elisp:(describe-variable 'user-full-name)][`user-full-name']]
- Your primary email address in [[elisp:(describe-variable 'user-mail-address)][`user-mail-address']]
- Any additional email addresses in [[elisp:(describe-variable 'user-mail-address-list)][`user-mail-address-list']]

#+BEGIN_SRC emacs-lisp
  (eval-when-compile
    (setq user-full-name "Einar Elén"
	  user-mail-address "einar.elen@gmail.com")
    (defcustom user-mail-address-list `(,user-mail-address,
					"info-ordf@luna.lu.se",
					"nat13eel@student.lu.se")
      "A list of the `user-mail-address' and any additional
    email addresses of the user."
      :group 'elib
      :type '(repeat string)))
#+END_SRC
**** Location of Executables                                      :ignore:
:PROPERTIES:
:ID:       5100a407-137f-4905-b6bd-8880e136d64f
:END:
Since we want to be able to use the same configuration
regardless of where programs might be stored on our
computer, we define some variables for storing the location
of these programs. They are set automatically using the
handy [[elisp:(describe-function 'executable-find)][`executable-find']] function.

#+BEGIN_SRC emacs-lisp
  (eval-when-compile
    (setq
     with-editor-emacsclient-executable (executable-find
					 "emacsclient")
     magit-git-executable (executable-find "git")
     cide--rdm-executable (executable-find "rdm")
     irony-cmake-executable (executable-find "cmake")
     company-cmake-executable irony-cmake-executable
     cmake-mode-cmake-executable company-cmake-executable

     company-clang-executable (executable-find "clang")
     flycheck-c/c++-clang-executable company-clang-executable

     flycheck-c/c++-gcc-executable (executable-find "gcc")
     clang-format-executable (executable-find "clang-format")
     company-gtags-executable (or (executable-find "global")
				  (executable-find "gtags"))))
 #+END_SRC
**** Location of Files                                    :probablyignore:
:PROPERTIES:
:ID:       3180981a-a5fa-4fe8-a0f6-e560df27db5d
:END:
There are some files that it is useful to have a variable
for. If you use some other than my defaults, feel free to
edit them.

- The main directory for emacs configuration files in  [[elisp:(describe-variable   'user-emacs-config-directory)][`user-emacs-config-directory']]. We do this so we can redefine
  [[elisp:(describe-variable 'user-emacs-directory)][`user-emacs-directory']] later to store random local files
  in a place which doesn't clutter our configuration
  directory.
- Location of some extra snippets for the yasnippet package
  from Tuhdo in [[elisp:(describe-variable 'tuhdo-snippets-directory)][`tuhdo-snippets-directory']]. This is used
  later in [[*Yasnippet][Yasnippet]]. We also have our own in [[elisp:(describe-variable   'elib-snippets-directory)][`elib-snippets-directory']]

- The location of the configuration file (i.e. this file) in
  [[elisp:(describe-variable 'config-file-file-name)][`config-file-file-name']] (great name choice right?)
- The location of the scripts file in [[elisp:(describe-variable 'scripts-file-file-name)][`scripts-file-file-name']]
- The main directory for my various org files is found in
  [[elisp:(describe-variable 'user-org-directory)][`user-org-directory']].
- In [[*Capture][Capture]], we define some ways to capture quick thoughts
  and quotes. I use the two separate files for todo:s and
  quotes, [[elisp:(describe-variable 'user-org-quotes-file-name)][`user-org-quotes-file-name']] and
  [[elisp:(describe-variable 'user-org-todo-file-name)][`user-org-todo-file-name']]
- Later in [[*Abbrev][Abbrev]] we define some spell-checking tools. We
  have a big file of common spelling oopsies (e.g. owrk
  instead of work). The location of this file is defined in
  [[elisp:(describe-variable 'abbrev-location)][`abbrev-location']]
- Folder where all [[elisp:(describe-package 'org-gcal)][`org-gcal']]-calendars will be stored in
  [[elisp:(describe-variable 'org-gcal-calendar-location)][`org-gcal-calendar-location']] . I use three calendars and
  their individual files have a variable each, all of which
  can be found in `org-gcal-calendar-file-name-list'. These
  settings are used in [[*Calendar][Calendar]]
  - My main calendar in [[elisp:(describe-variable 'org-gcal-calendar-main-file-name)][`org-gcal-calendar-main-file-name']]
  - My information committee chairperson calendar in
    [[elisp:(describe-variable 'org-gcal-calendar-info-ordf-file-name)][`org-gcal-calendar-info-ordf-file-name']]
  - My student calendar in [[elisp:(describe-variable 'org-gcal-calendar-lu-file-name)][`org-gcal-calendar-lu-file-name']]
#+BEGIN_SRC emacs-lisp
(eval-when-compile
  (defcustom user-emacs-config-directory
    (file-name-as-directory (expand-file-name "~/.emacs.d"))
    "The emacs configuration directory."
    :type 'string
    :group :elib-file-paths)
  (defcustom tuhdo-snippets-directory
    (expand-file-name
     (concat user-emacs-config-directory
	     "tuhdosnippets"))
    "Location of extra yasnippet files from Tuhdo."
    :type 'string
    :group 'elib-file-paths)
  (defcustom elib-snippets-directory
    (expand-file-name
     (concat user-emacs-config-directory
	     "snippets"))
    "Location of custom yasnippet files."
    :type 'string
    :group 'elib-file-paths)

  (defcustom config-file-file-name
    (expand-file-name
     (concat
      user-emacs-config-directory
      "configuration.org"))
    "The filename of the user configuration file."
    :type 'string
    :group 'elib-file-paths
    :group 'elib-org)

  (defcustom script-file-file-name
    (expand-file-name
     (concat user-emacs-config-directory "scripts.org"))
    "The filename of the scripts file."
    :type 'string
    :group 'elib-file-paths
    :group 'elib-org)

  (defcustom user-org-directory
    (expand-file-name "~/nextcloud/org/")
    "Directory where most org files are stored."
    :type 'string
    :group 'elib-file-paths
    :group 'elib-org)

  (defcustom org-gcal-calendar-location
    (concat
     user-org-directory "cal/")
    "The directory where calendar files for `org-gcal' are
    stored."
    :group 'elib-calendar
    :group 'elib-file-paths
    :group 'elib-org
    :type 'string)
  (defcustom org-gcal-calendar-main-file-name
    (concat org-gcal-calendar-location "gmail.org")
    "Filename of the main calendar file."
    :type 'string
    :group 'elib-calendar
    :group 'elib-file-paths
    :group 'elib-org)
  (defcustom org-gcal-calendar-info-ordf-file-name
    (concat org-gcal-calendar-location "info-ordf.org")
    "Filename of the info-ordf calendar file."
    :type 'string
    :group 'elib-calendar
    :group 'elib-file-paths
    :group 'elib-org)
  (defcustom org-gcal-calendar-lu-file-name
    (concat org-gcal-calendar-location "lu.org")
    "Filename of my student account calendar file."
    :type 'string
    :group 'elib-calendar
    :group 'elib-file-paths
    :group 'elib-org)


  (defcustom org-gcal-calendar-file-name-list
    `(,org-gcal-calendar-main-file-name
      ,org-gcal-calendar-info-ordf-file-name
      ,org-gcal-calendar-lu-file-name)
    "List of all calendar file-names."
    :type '(repeat string)
    :group 'elib-calendar
    :group 'elib-file-paths
    :group 'elib-org)

  (defcustom user-org-todo-file-name
    (expand-file-name (concat user-emacs-config-directory
			      "../todo.org"))
    "The "
    :group 'elib-org
    :group 'elib-file-paths
    )
  (defcustom user-current-events-file
    (expand-file-name (concat user-emacs-config-directory "../current_events.org"))
    "")
  (defcustom user-org-quotes-file-name
    (expand-file-name
     (concat user-emacs-config-directory "../citatsamling.org"))
    ""
    :group 'elib-org
    :group 'elib-file-paths
    )
  (defcustom abbrev-location (expand-file-name ".abbrev_defs" user-emacs-config-directory)
    ""
    :group 'abbrev
    :group 'elib-file-paths
    ))
#+END_SRC


**** Load Paths                                           :probablyignore:
:PROPERTIES:
:ID:       95b1ec6e-d563-4d37-8246-a687d53b62eb
:END:
***** TODO Create the script to install all of the packages
:PROPERTIES:
:ID:       6b925028-0d50-4055-b938-2e7c723063f4
:END:
Most programs are installed using emacs package manager and
we do not need to tell it anything about where to find the
lisp-code for the package. Some packages might be installed
by your operating system (in my case, asymptote) or manually
(in my case, mu4e). If you use these packages you might need
to install them specially. I have written a script for
installing these packages which can check out if you want in
[[elisp:(describe-variable 'load-path-script-location)][`load-path-script-location']].

The load-paths are defined using the handy little function
[[elisp:(describe-function 'potential-load-paths)][`potential-load-paths']] which takes a list of potential paths
and returns the full file-name of the first one that exists
on the file-system.

The packages and their load-paths are:
- [[*Mu4e][Mu4e]] is an email-reader in emacs. I compile mu4e from
  source and have to add the load-path manually. The
  load-path variable is [[elisp:(describe-variable 'elib-mu4e-load-path)][`elib-mu4e-load-path']].
- In [[*Calendar][Calendar]], I use the package [[elisp:(describe-variable 'org-gcal)][`org-gcal']] to synchronise
  google calendar with my org-mode calendar files. Sadly,
  there is a bug which prevents you from using more than one
  calendar. There is a solution which someone has tried to
  get into the main package but at the moment it isn't
  there. I therefore use a patched version of the package
  which I have to install manually. The load-path variable
  is [[elisp:(describe-variable 'elib-org-gcal-load-path)][`elib-org-gcal-load-path']].
- [[*Rtags][Rtags]] is an incredibly powerful tool for handling code. I
  used to install this manually but since Fedora 28 (I
  think?) there is an operating system which provides
  it. The load-path is defined in [[elisp:(describe-variable 'elib-rtags-load-path)][`elib-rtags-load-path']].
- I often use the programming language [[https://en.wikipedia.org/wiki/Asymptote_(vector_graphics_language)][Asymptote]] to generate
  vector graphics for graphs. It comes with great
  integration into Emacs and is designed to be used with
  [[*LaTeX/AUCTeX][LaTeX]] and I install it together with the other AUCTeX
  features. I install asymptote through my operating system
  package manager and add the load-path for its lisp-code
  using the variable [[elisp:(describe-variable 'elib-asymptote-load-path)][`elib-asymptote-load-path']].

#+BEGIN_SRC emacs-lisp
(eval-when-compile
  (defvar load-path-script-location
    (expand-file-name (concat user-emacs-config-directory "special-packages.el")))
  (defvar elib-org-gcal-load-path (expand-file-name "~/src/org-gcal/"))
  (defvar elib-rtags-load-path
    (potential-load-paths
     `("/usr/share/emacs/site-lisp/rtags/"
       ,(concat user-emacs-config-directory
               "../src/rtags/src/"))))
  (defvar elib-mu4e-load-path
    (potential-load-paths
     '("~/.local/share/emacs/site-lisp/mu4e"
       "/usr/local/share/emacs/site-lisp/mu4e"
       "/usr/local/share/emacs/site-lisp/mu/mu4e"
       "~/.emacs.d/mu4e")))
  (defvar elib-asymptote-load-path
    (potential-load-paths '("/usr/share/asymptote/"))))
#+END_SRC
**** TeX Viewers                                                  :ignore:
:PROPERTIES:
:ID:       22070e13-f071-42a1-9db8-527c3e3e159d
:END:
AUCTeX is great but one weird thing about is that it only
allows you to chose one program to use for viewing your pdf:s
you create. I have created a little [[*Helm][Helm]]-program which lets
you switch between viewers.
The function is called [[elisp:(describe-function
'elib-helm-tex-choose-program)][`elib-helm-tex-choose-program']]
and in [[*LaTeX/AUCTeX][LaTeX/AUCTeX]] we bind it to "C-c v"
in [[elisp:(describe-function 'LaTeX-mode)][`LaTeX-mode']]. I used
this to learn a bit more about the customization features of
emacs so it is definitely more complicated than what is
strictly necessary.


You should not need to modify any of these variables but
feel free to study them and come with suggestions of how to
do it in a more proper way if you like. If you wish to add
some other program as a pdf-reader than the ones listed in
[[elisp:(describe-variable 'elib-helm-tex-alist)][`elib-helm-tex-alist']].

You can also customize my settings through the group [[elisp:(customize-group
 'elib-helm-tex)][`elib-helm-tex']].

#+BEGIN_SRC emacs-lisp
(eval-when-compile
  (require 'helm)
  (eval-after-load "tex"
    '(eval-after-load "helm"
       '(progn
#+END_SRC
***** Evince
:PROPERTIES:
:ID:       1cadd0e8-3eb1-4a53-88f5-8beac438cfc8
:END:
Here we define everything necessary for the evince
pdf-reader (i.e. the default pdf-reader for the GNOME
desktop environment).

The variables you can customize in the
[[elisp:(customize-group 'elib-helm-tex-evince)][`elib-helm-tex-evince']]-subgroup are
- [[elisp:(describe-variable 'elib-helm-tex-evince-human-readable)][`elib-helm-tex-evince-human-readable']]
- [[elisp:(describe-variable 'elib-helm-tex-evince)][`elib-helm-tex-evince']]

#+BEGIN_SRC emacs-lisp
(defcustom elib-helm-tex-evince-human-readable
  "Evince"
  "Human readable name for the Evince PDF viewer."
  :type 'string
  :group 'elib-helm-tex-evince)


(defcustom elib-helm-tex-evince
  `((output-pdf ,elib-helm-tex-evince-human-readable)
    (,elib-helm-tex-evince-human-readable
     TeX-evince-sync-view
     "evince"
     ))
  "Settings for the Evince viewer. Consists of two\
 lists:\n
The first list consisting of the symbol corresponding the
output type defined in `TeX-view-predicate-list' or
`TeX-view-predicate-list-builtin' (PDF) and a human readable
string. The format is for `tex-view-program-selection'
variable.\n

The second list consisting of a human readable string, and
one of the following:

- A string corresponding to a command line to be run as a
process
- An elisp function to execute through `TeX-command-master'
- An elisp function to execute through `TeX-command-master'
and a list of strings with arguments to the function (I
think?).

The format is for `TeX-view-program-list'. The format is
well non-well documented there."
  :type
  '(list
    (list symbol string)
    (list string
          (choice (repeat string)
                  function
                  (list function (repeat
                                  string))
                  (list string
                        (list symbol
                              (choice
                               string
                               (repeat string)
                               ))))
          sexp))
  :group 'elib-helm-tex-evince)

#+END_SRC
***** Okular
:PROPERTIES:
:ID:       b75d4538-2b24-4bd8-9d6a-e1c042c25a4c
:END:
Here we define everything necessary for the Okular
pdf-reader (i.e. the default pdf-reader for the KDE desktop
environment).

The variables you can customize in the
[[elisp:(customize-group 'elib-helm-tex-okular)][`elib-helm-tex-okular']]-subgroup are
- [[elisp:(describe-variable 'elib-helm-tex-okular-human-readable)][`elib-helm-tex-okular-human-readable']]
- [[elisp:(describe-variable 'elib-helm-tex-okular)][`elib-helm-tex-okular']]

#+BEGIN_SRC emacs-lisp
(defcustom elib-helm-tex-okular-human-readable
  "Okular"
  "Human readable name for the Okular PDF viewer."
  :type 'string
  :group 'elib-helm-tex-okular)

(defcustom elib-helm-tex-okular
  `((output-pdf ,elib-helm-tex-okular-human-readable)
    (,elib-helm-tex-okular-human-readable
     ("okular --unique %o"
      (mode-io-correlate "#src:%n%a"))
     "okular"))
  ;; elib-helm-tex-okular
  ;; TeX-view-program-list-builtin
  "Settings for the Okular viewer. Consists of two\
 lists:\n
The first list consisting of the symbol corresponding the
output type defined in `TeX-view-predicate-list' or
`TeX-view-predicate-list-builtin' (PDF) and a human readable
string. The format is for `tex-view-program-selection'
variable.\n

The second list consisting of a human readable string, and
one of the following:

- A string corresponding to a command line to be run as a
process
- An elisp function to execute through `TeX-command-master'
- An elisp function to execute through `TeX-command-master'
and a list of strings with arguments to the function (I
think?).

The format is for `TeX-view-program-list'. The format is
well non-well documented there."
  :type
  '(list
    (list symbol string)
    (list string
          (choice (repeat string)
                  function
                  (list function (repeat
                                  string))
                  (list string
                        (list symbol
                              (choice
                               string
                               (repeat string)
                               ))))
          sexp))
  :group 'elib-helm-tex-okular)



#+END_SRC
***** PDF-Tools
:PROPERTIES:
:ID:       f8e6e669-5391-4c1c-aaf7-6313500c2ed1
:END:
Here we define everything necessary for PDF-tools, the pdf
viewer that we install over in [[*PDF-Handling][PDF-Handling]]. Unlike evince
and okular, pdf-tools is displaying within emacs which means
you have access to all the powers that emacs entails.

The variables you can customize in the
[[elisp:(customize-group 'elib-helm-tex-pdf-tools)][`elib-helm-tex-pdf-tools']]-subgroup are
- [[elisp:(describe-variable 'elib-helm-tex-pdf-tools-human-readable)][`elib-helm-tex-pdf-tools-human-readable']]
- [[elisp:(describe-variable 'elib-helm-tex-pdf-tools)][`elib-helm-tex-pdf-tools']]

#+BEGIN_SRC emacs-lisp 
(defcustom elib-helm-tex-pdf-tools-human-readable
  "PDF-tools"
  "Human readable name for the PDF-tools PDF viewer."
  :type 'string
  :group 'elib-helm-tex-pdf-tools)

(defcustom elib-helm-tex-pdf-tools
  `((output-pdf ,elib-helm-tex-pdf-tools-human-readable)
    (,elib-helm-tex-pdf-tools-human-readable TeX-pdf-tools-sync-view))
  "Settings for the PDF-tools viewer. Consists of two\
 lists:\n
The first list consisting of the symbol corresponding the
output type defined in `TeX-view-predicate-list' or
`TeX-view-predicate-list-builtin' (PDF) and a human readable
string. The format is for `tex-view-program-selection'
variable.\n

The second list consisting of a human readable string, and
one of the following:

- A string corresponding to a command line to be run as a
process
- An elisp function to execute through `TeX-command-master'
- An elisp function to execute through `TeX-command-master'
and a list of strings with arguments to the function (I
think?).

The format is for `TeX-view-program-list'. The format is
well non-well documented there."
  :type
  '(list
    (list symbol string)
    (list string
          (choice (repeat string)
                  function
                  (list function (repeat
                                  string))
                  (list string
                        (list symbol
                              (choice
                               string
                               (repeat string)
                               ))))
          sexp))
  :group 'elib-helm-tex-pdf-tools)
#+END_SRC
***** Helm-TeX-View Selection
:PROPERTIES:
:ID:       a5d08609-09fa-4699-ad06-1565a2929276
:END:
#+BEGIN_SRC emacs-lisp
(defcustom elib-helm-tex-sources
  (helm-build-sync-source
      "TeX View Selection"
    :candidates 'elib-helm-tex-candidates
    :action 'elib-helm-tex-set-variables
    :persistent-action 'elib-helm-tex-set-variables)
  "A `helm-sync-source' for TeX View Selection. You
  probably don't need to modify this."
  :type 'helm-source-sync
  :group 'elib-helm-tex)

(defun elib-helm-tex-choose-program ()
  (interactive)
  (helm :sources elib-helm-tex-sources :buffer
	"*elib-helm-tex-view*"))

(defun elib-helm-tex-set-variables (choice)
  (setf (alist-get 'output-pdf TeX-view-program-selection)
	(cdr (cadr (assoc choice
                          elib-helm-tex-alist)))))

(defcustom elib-helm-tex-candidates
  `(,elib-helm-tex-pdf-tools-human-readable
    ,elib-helm-tex-evince-human-readable
    ,elib-helm-tex-okular-human-readable)
  "List of human readable names for all pdf viewers to\
 choose from."
  :type '(repeat string)
  :group 'elib-helm-tex)

(defvar elib-helm-tex-alist
  `((,elib-helm-tex-pdf-tools-human-readable
     . ,elib-helm-tex-pdf-tools)
    (,elib-helm-tex-evince-human-readable
     . ,elib-helm-tex-evince)
    (,elib-helm-tex-okular-human-readable
     . ,elib-helm-tex-okular)))

(defvar elib-helm-tex-program-list
  (let ((value))
    (dolist (x elib-helm-tex-alist value)
      (add-to-list 'value (caddr x)))))

(add-to-list-multi 'TeX-view-program-list
		   elib-helm-tex-program-list)
#+END_SRC
#+BEGIN_SRC emacs-lisp
))))
#+END_SRC
** Improve Basic Emacs Experience
:PROPERTIES:
:ID:       0c5f0b2e-abdf-41c3-90d1-fab40849003d
:END:
*** Configuration file
:PROPERTIES:
:ID:       03a6d1fd-eb0e-4df0-919b-640c5e9e9af0
:END:
Creates a function called [[elisp:(describe-function
 'configuration/gtd-file-or-restart-emacs)][`configuration/gtd-file-or-restart-emacs']] which by default
returns you to this file and binds it to "<f8>" globally. If
you give it one universal argument, it returns you to [[elisp:(describe-variable
 'user-org-gtd-inbox)][`user-org-gtd-inbox']], with two universal arguments to
#+BEGIN_SRC emacs-lisp
(defun configuration/gtd-file-or-restart-emacs (x)
  (interactive "p")
  (message "%s" current-prefix-arg)
  (cond ((equal current-prefix-arg '(4))
         (find-file user-org-gtd-inbox))
        ((equal current-prefix-arg '(16))
         (find-file user-org-directory))
        ((equal current-prefix-arg '(64))
         (restart-emacs))
        (t (find-file config-file-file-name))))

(global-set-key (kbd "<f8>") 'configuration/gtd-file-or-restart-emacs)
#+END_SRC
*** Additional Settings
:PROPERTIES:
:ID:       99d4c001-1607-49f3-a799-2297e4f500af
:END:
Change the default location of [[elisp:(describe-variable
'user-emacs-directory)][`user-emacs-directory']] so that it
does not clutter our configuration directory. Use
[[elisp:(describe-variable
'user-emacs-config-directory)][`user-emacs-config-directory']]
instead for the configuration directory.

#+BEGIN_SRC emacs-lisp
(setq user-emacs-directory
      (file-name-as-directory
       (expand-file-name
        (concat
         user-emacs-config-directory
         "machine-local-files"))))
#+END_SRC


Disable scroll bar and toolbar, disable the keys that hide
emacs (they are easy to hit on accident which is /really/
annoying). Also, show column and line number of the cursor
in the modeline.
#+BEGIN_SRC emacs-lisp
;; Does not make sense in a terminal
(when (display-graphic-p)
  (scroll-bar-mode -1)
  (tool-bar-mode -1))
;; Way too easy to hit by accident
(global-unset-key (kbd "C-x C-z"))
(global-unset-key (kbd "C-z"))
(setq column-number-mode t
      line-number-mode t)
#+END_SRC

Turn on word-wrapping in each buffer and make it so that
commands operate on visual lines rather than logical ones.
#+BEGIN_SRC emacs-lisp
(global-visual-line-mode t)
#+END_SRC

Highlight the current line
#+BEGIN_SRC emacs-lisp
(global-hl-line-mode t)
#+END_SRC

Flash the screen rather than making noise when complaining.
#+BEGIN_SRC emacs-lisp
(setq visible-bell t)
#+END_SRC
Show a clock!
#+BEGIN_SRC emacs-lisp
(display-time)
#+END_SRC
Always answer yes or no questions with just y or n, yes or no is
annoying to type. Emacs graphical pop-ups sometimes causes the program
to hang so I disable it.
#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
(setq use-dialog-box nil)
#+END_SRC
Enable syntax highlighting in all modes where it is possible!
#+BEGIN_SRC emacs-lisp
(global-font-lock-mode t)
#+END_SRC
If we are using an emacs with native line-numbering, use it!
Otherwise, use nlinum for line-numbering.
#+BEGIN_SRC emacs-lisp
(if (boundp 'display-line-numbers)
    (global-display-line-numbers-mode t)
  (use-package nlinum
    :defer 3
    :preface
    (defun disable-nlinum-mode-hook () (nlinum-mode -1))
    :config
    (global-nlinum-mode t)
    (add-hook 'pdf-view-mode-hook 'disable-nlinum-mode-hook)))
#+END_SRC

Other stuff which may or may not work...
#+BEGIN_SRC emacs-lisp
(use-package tramp
  :config
  (setq tramp-default-method "ssh"))
(setq backup-directory-alist `((".*" . ,temporary-file-directory))
      auto-save-file-name-transforms `((".*" ,temporary-file-directory t))
      backup-by-copying t    ;; Don't delink hard-links
      version-control t      ;; use version numbers on backups
      delete-old-versions t  ;; Automatically delete excess backups
      kept-new-versions 20   ;; how many of the newest versions to keep
      kept-old-versions 5    ;; and how many of the old
      )

(setq ;gc-cons-threshold 100000000
 inhibit-startup-message nil
 history-length t
 history-delete-duplicates t
 version-control t
 x-stretch-cursor nil)
(setq-default
 fill-column 60
 cursor-type 'hbar)
(setq mac-command-modifier 'meta)
#+END_SRC
*** Window Management
:PROPERTIES:
:ID:       3bdf2a82-7310-42a2-886d-5f49ac718167
:END:
Winner allows you to restore previous window configurations and jump
around in the window configuration history using C-c <left> and C-c
<right> (the arrow keys).

Try it out by typing C-x 3, C-x o, C-x b (choose some buffer) and then
C-c <left> twice to get back! Then try C-c <right> once and C-c <left
again to return!


#+BEGIN_SRC emacs-lisp
  (use-package winner
	       :bind (("C-c <left>" . winner-undo)
		      ("C-c <right>" . winner-redo))
	       :config
	       (winner-mode t))
			  ;; (use-package switch-window
			  ;;   :defer 2
			  ;;   :bind (("C-x o" . switch-window)))
			  ;;
#+END_SRC

**** Clipmon
:PROPERTIES:
:ID:       da180b8f-e514-4a17-a313-10c86c59023a
:END:
		Clipmon tries to help emacs synchronize copies and
		pastes between emacs and the rest of your operating
		system.
#+BEGIN_SRC emacs-lisp
(use-package clipmon
  :defer 1
  :config (setq clipmon-autoinsert-timeout nil
		clipmon-autoinsert-sound nil
		clipmon-autoinsert-color nil
		clipmon-transform-suffix nil)
  (clipmon-mode))
			#+END_SRC
****  Windmove
:PROPERTIES:
:ID:       fdd6346c-192c-4e63-b10a-a3e665812ffa
:END:
Windmove keybindings allows you to switch between your
windows with shift + arrow keys which can be handy when
you're tired.
			#+BEGIN_SRC emacs-lisp
(use-package windmove
  :after org
  :hook ((org-shiftup-final-hook . windmove-up)
         (org-shiftdown-final-hook . windmove-down)
         (org-shiftleft-final-hook . windmove-left)
         (org-shiftright-final-hook . windmove-right))
  :config
  (windmove-default-keybindings))


		 #+END_SRC
**** Zygospore
:PROPERTIES:
:ID:       d02288e4-e02c-4269-8653-eaa4f24b96d8
:END:
		 Zygospore replaces the default kill all other windows with
		 a version which lets you go back if you use it again.
		 #+BEGIN_SRC emacs-lisp

			 (use-package zygospore
	 :bind (("C-x 1" . zygospore-toggle-delete-other-windows)))
		 #+END_SRC
**** Help window management
:PROPERTIES:
:ID:       8652fd88-e184-46a9-ba72-25f6223c0994
:END:
		 By default help windows don't put you in them
		 immediately, I'd rather they did so they can be killed
		 quickly after reading.
		 #+BEGIN_SRC emacs-lisp
		 (setq help-window-select t)
		 #+END_SRC


*** Hydra
:PROPERTIES:
:ID:       245eb695-0abf-435d-aab8-eaf1e5a1f8de
:END:
Hydra is a package which allows fancy keyboard bindings. The
		only one which currently exists is C-M-o for
		window 	management.
#+BEGIN_SRC emacs-lisp
(use-package hydra
  :commands (hydra-add-font-lock
	     hydra-default-pre hydra-keyboard-quit
	     hydra--call-interactively-remap-maybe
	     hydra-show-hint hydra-set-transient-map)
  :config
  (hydra-add-font-lock)
  (use-package ace-window)
  (use-package transpose-frame)
  (use-package default-text-scale
    :config
    (default-text-scale-mode t))
  (defhydra hydra-window ()
    "Window management"
    ("a" windmove-left)
    ("s" windmove-down)
    ("d" windmove-right)
    ("w" windmove-up)
    ("3" (lambda ()
	   (interactive)
	   (split-window-right)
	   (windmove-right))
     "Vertical")
    ("2" (lambda ()
	   (interactive)
	   (split-window-below)
	   (windmove-down))
     "Horizontal")
    ("t" transpose-frame "'")
    ("1" delete-other-windows "Delete All" :color blue)
    ("A" ace-window "Ace")
    ("S" ace-swap-window "Swap")
    ("k" ace-delete-window "Kill")
    ("i" ace-delete-other-windows "Ace-max")
    ("b" helm-mini "Buffers")
    ("q" nil "cancel" :color blue)
    ("M-t" text-scale-decrease "Local Text Scale--")
    ("C-t" text-scale-increase
     "Local Text Scale++")
    ("C-f" default-text-scale-increase
     "Global Text Scale++")
    ("M-f" default-text-scale-decrease "Global Text Scale--"))

  (eval-after-load "flyspell"
    (defhydra hydra-spelling (:color blue)
      "
  ^
  ^Spelling^          ^Errors^            ^Checker^
  ^────────^──────────^──────^────────────^───────^───────
  _q_ quit            _<_ previous        _c_ correction
  ^^                  _>_ next            _d_ dictionary
  ^^                  _f_ check           _m_ mode
  ^^                  ^^                  ^^
  "
      ("q" nil)
      ("<" flyspell-correct-previous :color pink)
      (">" flyspell-correct-next :color pink)
      ("c" ispell)
      ("d" ispell-change-dictionary)
      ("f" flyspell-buffer)
      ("m" flyspell-mode)) )
  :bind (("C-M-o" . hydra-window/body)
         ("C-M-s" . hydra-spelling/body)))


#+END_SRC

*** Mac-specific stuff
:PROPERTIES:
:ID:       2a98cf18-bc88-4bd1-95d0-44473338cd63
:END:
Add latex, bash, and much more support because they are in
weird places on Mac OS systems.  Because why wouldn't they
be.
#+BEGIN_SRC emacs-lisp
(if (equal system-type 'darwin)
		(progn (add-to-list 'exec-path "/usr/local/bin/")
					 (add-to-list 'exec-path "/Library/TeX/texbin/pdflatex")
					 (setenv "PATH" (concat "/usr/local/bin:/Library/TeX/texbin/:" (getenv "PATH")))))
#+END_SRC
*** Restarting Emacs
:PROPERTIES:
:ID:       3d5b1d39-5979-4951-b3ff-044537807d60
:END:
#+BEGIN_SRC emacs-lisp
(defun restart-emacs-with-arguments ()
  (interactive)
  (let ((response
         (read-string "Arguments to new emacs: "
                      )))
    (restart-emacs '(response))))
(defun restart-emacs-debug ()
  (interactive)
  ""
  (restart-emacs '("--debug-init")))
(use-package restart-emacs
  :init

  (defun restart-emacs-quick ()
    (interactive)
    ""
    (restart-emacs '("-Q")))

  :config

  (define-key-after
    global-map
    [menu-bar restart-emacs-menu]
    (cons "Restart Emacs"
          (make-sparse-keymap
           "Restart-emacs-menu-keymap"))
    'tools)

  (define-key global-map
    [menu-bar restart-emacs-menu rs]
    '("Restart Emacs" . restart-emacs)
    )
  (define-key global-map
    [menu-bar restart-emacs-menu rs-d]
    '("Restart Emacs (Debug)" . restart-emacs-debug))
  (define-key global-map
    [menu-bar restart-emacs-menu rs-q]
    '("Restart Emacs (Quick)" . restart-emacs-quick))
  (define-key global-map
    [menu-bar restart-emacs-menu rs-args]
    '("Restart Emacs (Args...)" . restart-emacs-with-arguments))


  )
#+END_SRC
** Looks/Themes
:PROPERTIES:
:ID:       ce830bc7-3da6-432a-a723-1d7faf6cb31d
:END:
*** Basic Configuration
:PROPERTIES:
:ID:       644ee45f-f75a-4cbd-b3b1-57778fea1221
:END:
Adds colouring for variables in programming languages. Sets
the starting buffer to this file.
#+BEGIN_SRC emacs-lisp
;; (setq initial-buffer-choice config-file-file-name)

  (use-package color-identifiers-mode
    :diminish color-identifiers-mode
    :defer 4
    :config
    (global-color-identifiers-mode t))

#+END_SRC
*** Themes
**** Spaceline
#+BEGIN_SRC emacs-lisp
(use-package spaceline
  :defer 2
  :commands (spaceline-spacemacs-theme
	     spaceline-helm-mode spaceline-info-mode)
  :config
  (use-package spaceline-config
    :ensure nil
    :config
    (spaceline-spacemacs-theme)
    (spaceline-helm-mode t)
    (spaceline-info-mode t)
    ;; (use-package all-the-icons
    ;;   :config
    ;;   (use-package spaceline-all-the-icons
    ;;     :config
    ;;     (spaceline-all-the-icons-theme)))
    ))
#+END_SRC
**** Spacemacs
#+BEGIN_SRC emacs-lisp
(use-package spacemacs-common
	:ensure spacemacs-theme
	:config )
#+END_SRC
**** Doom-Themes

#+BEGIN_SRC emacs-lisp
(use-package doom-themes
  :config
  (setq doom-themes-enable-bold t doom-themes-enable-italic t)
  (doom-themes-neotree-config)
  (doom-themes-treemacs-config)
  (doom-themes-org-config))
#+END_SRC
*** Fonts
#+BEGIN_SRC emacs-lisp
(set-frame-font "Hack 13" nil t)
#+END_SRC

** Text Editing
:PROPERTIES:
:ID:       e88a991a-273f-4647-9f69-db4480e4f2c4
:END:
Everything in here is essentially from [[http://tuhdo.github.io][tuhdo]] and most of it
is sane by default. Check out the individual packages in his
C/C++ tutorial!
*** Basic
:PROPERTIES:
:ID:       ee87ba06-6f6d-4d2b-b85d-bcfe9ed0928a
:END:
#+BEGIN_SRC emacs-lisp
  (setq global-mark-ring-max 5000
	mark-ring-max 5000
	mode-require-final-newline t
	tab-width 2
	kill-ring-max 5000
	kill-whole-line t)
  (setq-default indent-tabs-mode nil
		indent-tabs-mode nil)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (set-language-environment "UTF-8")
  (prefer-coding-system 'utf-8)
  ;; Not sure if i want this feature, it causes you to delete
  ;; things in selection if you start writing much like on
  ;; most operating systems.
  ;; (delete-selection-mode t)

  ;; (add-hook 'sh-mode-hook (lambda ()
  ;;    k                      (setq
  ;;                          tab-width
  ;;                          4)))

  ;; (use-package simple
  ;;   :ensure nil
  ;;   :hook
  ;;   ((prog-mode)
  ;;    . auto-fill-mode))

  ;; (use-package refill :hook ((text-mode org-mode) ))





  (use-package
    whitespace
    :config (add-hook
	     'diff-mode-hook
	     (lambda ()
	       (setq-local
		whitespace-style
		'(face
		  tabs
		  tab-mark
		  spaces
		  space-mark
		  trailing
		  indentation::space
		  indentation::tab
		  newline
		  newline-mark))
	       (whitespace-mode 1)))
    (global-set-key
     (kbd "C-c w")
     'whitespace-mode))
  ;;(use-package diff-mode)
  ;;(add-hook 'prog-mode-hook (lambda () (interactive) (setq
  ;;                          show-trailing-whitespace 1)))

  ;; (add-hook 'text-mode-hook 'auto-fill-mode)
 #+END_SRC
*** Keybindings
:PROPERTIES:
:ID:       e2c8acc1-eb44-40a8-b854-a7f21334de9e
:END:
Disable certain keybindings that are often clicked by
mistake. Add keybinding for compilation (F5) and for
capitalising (M-c).

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "RET") 'newline-and-indent)
  (global-set-key (kbd "C-<down-mouse-1>") 'ignore)
  (global-set-key (kbd "C-<down-mouse-2>") 'ignore)
  (global-set-key (kbd "C-<down-mouse-3>") 'ignore)
  (global-set-key (kbd "C-<mouse-1>")
                  'ignore)

  (global-set-key (kbd "C-<mouse-2>") 'ignore)

  (global-set-key (kbd "C-<mouse-3>") 'ignore)

  (global-set-key (kbd "M-c") 'capitalize-dwim)

  (global-set-key (kbd "<f5>")
                  (lambda () (interactive)
                    (setq-local compilation-read-command nil)
                    (call-interactively 'compile)))
#+END_SRC
*** Packages
:PROPERTIES:
:ID:       833d7de4-405a-4879-8cb2-f8ff9b497cb9
:END:
**** Rainbow Delimiters
:PROPERTIES:
:ID:       7a40a382-9438-4c45-bec4-dedb955febd5
:END:
Rainbow delimiters highlights braces, brackets, and their
friends.

#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :hook (prog-mode . rainbow-delimiters-mode-enable))
#+END_SRC
**** Aggressive Indentation
:PROPERTIES:
:ID:       9963e877-08ae-4ddf-b709-df81df380927
:END:
Tries to keep your indentation in check by, being aggressive
about it. It is related to electric-indent-mode but is, more
aggressive.

#+BEGIN_SRC emacs-lisp
(use-package aggressive-indent
  :config
  (global-aggressive-indent-mode -1))
#+END_SRC
**** Which-key
:PROPERTIES:
:ID:       a94d0064-685f-4b20-b43d-6fc8021987c9
:END:
Which-key gives you suggestions if you have started a key
combination but stopped. Real handy.
#+BEGIN_SRC emacs-lisp
(use-package which-key
  :ensure t
  :diminish which-key-mode
  :hook (after-init . which-key-mode))
#+END_SRC
**** Volatile Highlights
:PROPERTIES:
:ID:       bf40c61d-c498-4754-920a-4a73936b7286
:END:
Briefly highlights changes to the buffer for things like
pasting.
#+BEGIN_SRC emacs-lisp
(use-package volatile-highlights
  :diminish volatile-highlights-mode
  :config
  (volatile-highlights-mode t))
#+END_SRC
**** Dtrt-Indent
:PROPERTIES:
:ID:       155f1c87-b5c8-4c8d-9da5-5ec273426ae6
:END:
Guess indentation for many newly opened files based on what
is already in them.
#+BEGIN_SRC emacs-lisp
(use-package dtrt-indent
  :defer 2
  :config
  (dtrt-indent-mode t)
  (setq dtrt-indent-verbosity 0))
#+END_SRC
**** Whitespace Butler
:PROPERTIES:
:ID:       18029dc2-51f4-4533-86b5-60fe5694f083
:END:
Whitespace butler kills useless whitespace when you aren't
doing anything else.
#+BEGIN_SRC emacs-lisp
(use-package ws-butler
  :hook ((prog-mode org-mode text-mode fundamental-mode) . ws-butler-mode)
  :diminish ws-butler-mode)
  #+END_SRC
**** Undo Tree
:PROPERTIES:
:ID:       d2fa8cc9-fec4-41f2-b331-8b1cb3c40a2a
:END:
Makes undoing really fancy with a tree. Try it with C-x u.
#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :diminish undo-tree-mode
  :bind (("C-x u" . undo-tree-visualize))
  :config
  (global-undo-tree-mode)
  (setq undo-tree-visualizer-timestamps nil
	undo-tree-visualizer-diff t))
#+END_SRC
**** Smartparens
:PROPERTIES:
:ID:       efa46fec-5f1e-49bd-9d49-afc32561af23
:END:
Smartparens makes working with pairs of things such as
parentheses simple. It keeps you from messing them up which
is neat.
#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :diminish smartparens-mode
  :defer 1
  :commands sp-pair
  :hook ((org-mode text-mode TeX-mode c-mode-common org-src-mode)
         . smartparens-mode)
  :config
  (setq sp-escape-quotes-after-insert nil)
  (require 'smartparens-config)
  (sp-pair "\\[" "\\]")
  (setq ;; sp-base-key-bindings 'paredit
   sp-autoskip-closing-pair 'always
   sp-hybrid-kill-entire-symbol nil)
  (smartparens-strict-mode)
  ;; (sp-use-paredit-bindings)
  ;; (smartparens-global-mode t)
  :bind (:map smartparens-mode-map (("M-<down>" . nil)
				    ("M-<up>" . nil))))
#+END_SRC
**** Comment-dwim-2
:PROPERTIES:
:ID:       cd4c7416-60e7-4b90-95c0-35de82183bfb
:END:
Lets you comment out stuff in more cleaver ways than
default. Dwim stands for do what i mean.
#+BEGIN_SRC emacs-lisp
(use-package comment-dwim-2
  :bind (("M-;" . comment-dwim-2)))
#+END_SRC
**** Anzu
:PROPERTIES:
:ID:       4bc566de-5f12-4aed-b39d-8d57b522fcb6
:END:
Anzu makes the regular query and replace function much more
useful.
#+BEGIN_SRC emacs-lisp
(use-package anzu
  :diminish anzu-mode
  :config
  (global-anzu-mode t)
  :bind (("M-%" . anzu-query-replace)
	 ("C-M-%" . anzu-query-replace-regexp)))
#+END_SRC
**** Iedit
:PROPERTIES:
:ID:       5a77dfde-4a06-4502-99ac-77c360b9ba13
:END:
This is really cool. Mark a section and edit all occurrences
of the section.
#+BEGIN_SRC emacs-lisp
(use-package iedit
  :config
  (setq iedit-toggle-key-default nil)
  :bind (("C-M-;" . iedit-mode)))
#+END_SRC
**** Customized Functions (Mainly From Prelude)
:PROPERTIES:
:ID:       884d3d75-7357-4ac4-b50a-4cbc8b8401ab
:END:
#+BEGIN_SRC emacs-lisp
(defun prelude-move-beginning-of-line (arg)
  "Move point back to indentation of beginning of line. Move
  point to the first non-whitespace character on this line. If
  point is already there, move to the beginning of the
  line. Effectively toggle between the first non-whitespace
  character and the beginning of the line.

If ARG is not nil or 1, move forward ARG - 1 lines first. If
point reaches the beginning or end of the buffer, stop
there."


  (interactive "^p")
  (setq arg (or arg 1))
  ;; Move lines first
  (when (/= arg 1)
    (let ((line-move-visual nil))
      (forward-line (1- arg))))
  (let ((orig-point (point)))
    (back-to-indentation)
    (when (= orig-point (point))
      (move-beginning-of-line 1))))

(global-set-key (kbd "C-a") 'prelude-move-beginning-of-line)
(defadvice kill-ring-save (before slick-copy activate compile)
  "When called interactively with no active region, copy a
single line instead."
  (interactive
   (if mark-active (list (region-beginning) (region-end))
     (message "Copied line")
     (list (line-beginning-position)
           (line-beginning-position 2)))))

(defadvice kill-region (before slick-cut activate compile)
  "When called interactively with no active region, kill a
  single line instead."
  (interactive
   (if mark-active (list (region-beginning) (region-end))
     (list (line-beginning-position)
           (line-beginning-position 2)))))
;; kill a line, including whitespace characters until next non-whitespace character
;; of next line
(defadvice kill-line (before check-position activate)
  (if (member major-mode
              '(emacs-lisp-mode scheme-mode lisp-mode
                                c-mode c++-mode objc-mode
                                latex-mode plain-tex-mode))
      (if (and (eolp) (not (bolp)))
          (progn (forward-char 1)
                 (just-one-space 0)
                 (backward-char 1)))))
;; taken from prelude-editor.el
;; automatically indenting yanked text if in programming-modes
(defvar yank-indent-modes
  '(LaTeX-mode TeX-mode)
  "Modes in which to indent regions that are yanked (or
  yank-popped). Only modes that don't derive from
  `prog-mode' should be listed here.")

(defvar yank-indent-blacklisted-modes
  '(python-mode slim-mode haml-mode)
  "Modes for which auto-indenting is suppressed.")

(defvar yank-advised-indent-threshold 1000
  "Threshold (# chars) over which indentation does not
  automatically occur.")

(defun yank-advised-indent-function (beg end)
  "Do indentation, as long as the region isn't too large."
  (if (<= (- end beg) yank-advised-indent-threshold)
      (indent-region beg end nil)))

(defadvice yank (after yank-indent activate)
  "If current mode is one of 'yank-indent-modes, indent
yanked text (with prefix arg don't indent)."

  (if (and (not (ad-get-arg 0))
           (not (member major-mode
                        yank-indent-blacklisted-modes))
           (or (derived-mode-p 'prog-mode)
               (member major-mode yank-indent-modes)))
      (let ((transient-mark-mode nil))
        (yank-advised-indent-function (region-beginning)
                                      (region-end)))))


(defadvice yank-pop (after yank-pop-indent activate)
  "If current mode is one of `yank-indent-modes', indent
yanked text (with prefix arg don't indent)."
  (when (and (not (ad-get-arg 0))
             (not (member major-mode
                          yank-indent-blacklisted-modes))
             (or (derived-mode-p 'prog-mode)
                 (member major-mode yank-indent-modes)))
    (let ((transient-mark-mode nil))
      (yank-advised-indent-function (region-beginning)
                                    (region-end)))))
;; prelude-core.el
(defun indent-buffer ()
  "Indent the currently visited buffer."
  (interactive)
  (indent-region (point-min) (point-max)))


;; prelude-editing.el
(defcustom prelude-indent-sensitive-modes
  '(coffee-mode python-mode slim-mode haml-mode yaml-mode)
  "Modes for which auto-indenting is suppressed."
  :type 'list
  :group 'prelude)

(defun indent-region-or-buffer ()
  "Indent a region if selected, otherwise the whole buffer."
  (interactive)
  (unless (member major-mode prelude-indent-sensitive-modes)
    (save-excursion
      (if (region-active-p)
          (progn
            (indent-region (region-beginning) (region-end))
            (message "Indented selected region."))
        (progn
          (indent-buffer)
          (message "Indented buffer.")))
      (whitespace-cleanup))))

(global-set-key (kbd "C-c i") 'indent-region-or-buffer)

;; add duplicate line function from Prelude
;; taken from prelude-core.el
(defun prelude-get-positions-of-line-or-region ()
  "Return positions (beg . end) of the current line or
region."
  (let (beg end)
    (if (and mark-active (> (point) (mark)))
        (exchange-point-and-mark))
    (setq beg (line-beginning-position))
    (if mark-active
        (exchange-point-and-mark))
    (setq end (line-end-position))
    (cons beg end)))

;; smart openline
(defun prelude-smart-open-line (arg)
  "Insert an empty line after the current line. Position the
cursor at its beginning, according to the current mode. With
a prefix ARG open line above the current line."
  (interactive "P")
  (if arg
      (prelude-smart-open-line-above)
    (progn
      (move-end-of-line nil)
      (newline-and-indent))))

(defun prelude-smart-open-line-above ()
  "Insert an empty line above the current line. Position the
cursor at it's beginning, according to the current mode."
  (interactive)
  (move-beginning-of-line nil)
  (newline-and-indent)
  (forward-line -1)
  (indent-according-to-mode))
(global-set-key (kbd "M-o") 'prelude-smart-open-line)
#+END_SRC

**** Avy
:PROPERTIES:
:ID:       3ba766e4-840c-4647-b3e3-7497c7dcf21d
:END:
Avy provides an interesting way to find things in text. It
is the kind of thing that you definitely would be useful if
you got started but which I haven't really gotten started
with.
#+BEGIN_SRC emacs-lisp
(use-package avy
  :config
  (setq avy-all-windows nil)
  (use-package avy-zap
    :defer t)
  :bind (("C-:" . avy-goto-char)
	 ("C-;" . avy-goto-word-1)))
#+END_SRC
**** Dumb-Jump
:PROPERTIES:
:ID:       965b25ec-745c-4c97-aaeb-df9dd5c22d3b
:END:
Dumb jump tries to find variables and functions by simply
searching for the word in as many files as possible.
#+BEGIN_SRC emacs-lisp
(use-package dumb-jump
  :defer 2
  :diminish dumb-jump-mode
  :bind (("C-M-g" . dumb-jump-go)
	 ("C-M-p" . dumb-jump-back)
	 ("C-M-q" . dumb-jump-quick-look))
  :config
  (dumb-jump-mode t))
#+END_SRC

** PDF-Handling
:PROPERTIES:
:ID:       77b2a7a3-3ab5-4862-9f1a-78495d8011d2
:END:
The basic emacs pdf viewing utility, docview, is kind of
wonky. This installs a different utility, pdf-tools
which is wonderful! It does require some things
installed on your system to work (development version of
all of them)
- libpng
- libpoppler-glib, libpoppler-private
- imagemagick
- libz
- gcc, g++
- make
- automake
- autoconf

It is currently only enabled on linux, mac, and cygwin.
#+BEGIN_SRC emacs-lisp
  (use-package pdf-tools
    :mode ("\\.pdf\\'" . pdf-view-mode)
    :when (or (eq system-type 'gnu/linux)
              (eq system-type 'cygwin)
              (eq system-type 'darwin))
    :defer 2
    :config

    (setq-default pdf-view-display-size 'fit-page))
#+END_SRC

** Emacs-dashboard
Dashboard sets up a nice startup instead of the default
startup. It shows you files you've opened recently and your
agenda items.
#+BEGIN_SRC emacs-lisp
(use-package dashboard
  :defer nil
  :config
  (setq initial-buffer-choice (lambda () (get-buffer "*dashboard*")))
  (dashboard-setup-startup-hook)
  (add-to-list 'dashboard-items '(agenda) t)
  (setq show-week-agenda-p t))
#+END_SRC
** Neotree
Neotree is a nice little file browser. I have it bound to f1.
#+BEGIN_SRC emacs-lisp
(use-package neotree
  :defer 1
  :config
  (setq neo-theme (if (display-graphic-p) 'icons 'arrow))
  (setq neo-smart-open t)

  :bind ("<f1>" . neotree-toggle ))
#+END_SRC
** EVIL/Tutor
If you are a vim-user, you will love Evil-mode. It is an
implementation of the good stuff from vim in Emacs (this
might be somewhat contentious). I have it on so I can mess
around with vim from time to time but I set the default
state of each buffer to the standard Emacs mode.

There is an implementation of the vim tutor available for
Evil-mode.

[[https://www.youtube.com/watch?v=JWD1Fpdd4Pc][There is a great talk about Evil-mode for vim users
available by Aaron Bieber]]

Ironically, this talk is the reason I got started... with Emacs.

#+BEGIN_SRC emacs-lisp
(use-package evil
  :defer 2
  :config
  (setq evil-default-state 'emacs)
  (use-package org-evil)
  (use-package evil-tutor)
  (evil-mode t))
#+END_SRC
* Development/Writing
:PROPERTIES:
:ID:       cb1005df-4514-4726-b68b-1373343100d4
:END:
Again, visit [[http://tuhdo.github.io][tuhdo]] but check out the stuff about helm specifically!
** Project Management
:PROPERTIES:
:ID:       94034714-fb8d-42ea-8956-e84cf7849cb8
:END:
*** Projectile
:PROPERTIES:
:ID:       37e27ecb-6374-429d-81ac-3ddc0968e9aa
:END:
#+BEGIN_SRC emacs-lisp
(use-package projectile
  :hook (prog-mode . projectile-mode)
  :init
  (setq projectile-keymap-prefix (kbd "C-c p"))
  :config

  (projectile-global-mode)
  (setq projectile-enable-caching t)
  :diminish projectile-mode)
#+END_SRC
*** Magit
:PROPERTIES:
:ID:       10086449-5e80-4ed3-96e5-0439180ec58a
:END:
#+BEGIN_SRC emacs-lisp
(when (not (string= system-type "windows-nt"))
  (use-package magit
    :commands magit-status
    :bind ("C-x g" . magit-status)
    :config)
  )
#+END_SRC
** Helm
:PROPERTIES:
:ID:       319b55eb-ac6a-4658-bb7c-23a7b86ea768
:END:
Helm makes emacs a lot better.
*** Helm Gtags
:PROPERTIES:
:ID:       34bc616f-cb89-4937-921a-ca59340051c0
:END:
#+BEGIN_SRC emacs-lisp
(use-package helm-gtags
  :when (executable-find "gtags")
  :hook ((dired-mode eshell-mode c-mode c++-mode java-mode asm-mode) . helm-gtags-mode)
  :config
  (setq
   helm-gtags-ignore-case t
   helm-gtags-auto-update t
   helm-gtags-use-input-at-cursor t
   helm-gtags-pulse-at-cursor t
   helm-gtags-prefix-key "\C-cg")
  (setq helm-gtags-prefix-key "\C-cg"))
#+END_SRC
*** Basic Configuration
:PROPERTIES:
:ID:       4ef254df-450b-4522-9849-4f790b9a8a72
:END:
#+BEGIN_SRC emacs-lisp
(use-package helm
  :functions helm-find-files
  :commands
  (helm-mode helm-M-x helm-show-kill-ring helm-mini
             helm-find helm-all-mark-rings
             helm-apropos helm-info-Emacs
             helm-locate-library helm-minibuffer-history
             helm-occur helm-wikipedia-suggest helm-register
             helm-etags-select helm-buffers-list helm-google
             helm-yas-complete helm-ag helm-grep-ag
             helm-elisp-show-help helm-command-prefix
             helm-locate helm-man-woman helm-autoresize-mode
             helm-descbinds-mode helm-themes helm-dash
             helm-multi-swoop-all
             helm-swoop-without-pre-input
             helm-swoop-from-isearch  helm-projectile
             helm-semantic helm-info-semantic)
  :diminish helm-mode
  :bind (("M-x" . helm-M-x)
	 ("M-y" . helm-show-kill-ring)
	 ("C-x b" . helm-mini)
	 ("C-x C-f" . helm-find-files)
	 ("C-h SPC" . helm-all-mark-rings)
	 :map help-map
	 ("C-f" . helm-apropos)
	 ("r" . helm-info-emacs)
	 ("C-l" . helm-locate-library)
	 :map minibuffer-local-map
	 ("M-p" . helm-minibuffer-history)
	 ("M-n" . helm-minibuffer-history)
	 :map helm-grep-mode-map
	 ("<return>" . helm-grep-mode-jump-other-window)
	 ("n" . helm-grep-mode-jump-other-window-forward)
	 ("p" . helm-grep-mode-jump-other-window-backward))
  :config
  (use-package helm-config
    :ensure nil)
  (helm-mode t)
  (use-package helm-files
    :ensure nil)
  (use-package helm-find
    :ensure nil)
  (use-package helm-command :ensure nil
    :config
    (setq helm-M-x-requires-pattern nil)
    (setq helm-M-x-fuzzy-match t))
  (use-package helm-grep
    :ensure nil)
  (global-set-key (kbd "C-c h") 'helm-command-prefix)
  (global-unset-key (kbd "C-x c"))
  (bind-key "C-c h o" #'helm-occur)
  (bind-key "C-c h C-c w" #'helm-wikipedia-suggest)
  (bind-key "C-c h x" #'helm-register)
  (define-key global-map [remap find-tag] 'helm-etags-select)
  (define-key global-map [remap list-buffers] 'helm-buffers-list)

  (use-package helm-google
    :config
    (when (executable-find "curl")
      (setq helm-net-prefer-curl t)))
  (use-package helm-c-yasnippet
    :after yasnippet
    :config
    (setq helm-yas-display-key-on-candidate t))
  (use-package helm-ag)
  (use-package helm-elisp
    :ensure nil
    :config
    (setq helm-apropos-fuzzy-match t))

  (use-package helm-locate
    :ensure nil
    :config
    (setq helm-locate-fuzzy-match t))
  (use-package helm-files
    :ensure nil
    :config
    (setq helm-ff-search-library-in-sexp t
	  helm-ff-file-name-history-use-recentf t
	  helm-ff-skip-boring-files t))
  (use-package helm-for-files
    :ensure nil)
  (setq helm-scroll-amount 4
	helm-split-window-inside-p t
	helm-input-idle-delay 0.01
	helm-candidate-number-limit 500
	helm-move-to-line-cycle-in-source t
	helm-buffers-fuzzy-matching t
        helm-recentf-fuzzy-match t)
  (add-to-list 'helm-sources-using-default-as-input 'helm-source-man-pages)
  ;; (add-hook 'eshell-mode-hook
  ;;           #'(lambda ()
  ;;               (define-key eshell-mode-map (kbd "M-l")  'helm-eshell-history)))
  (add-hook 'helm-goto-line-before-hook 'helm-save-current-pos-to-mark-ring)
  (helm-autoresize-mode t)
  (use-package helm-descbinds
    :config
    (helm-descbinds-mode t))
  (use-package helm-themes
    :commands helm-themes
    :bind (("<f10>" . helm-themes)))
  (use-package helm-dash)

  (use-package helm-swoop
    :bind
    (("C-c s" . helm-multi-swoop-all)
     ("C-s" . helm-swoop-without-pre-input)
     ("C-r" . helm-swoop-without-pre-input)
     :map isearch-mode-map
     ("M-i" . helm-swoop-from-isearch))
    :commands
    (helm-swoop
     helm-multi-swoop
     helm-swoop-from-isearch
     helm-multi-swoop-all-from-helm-swoop)
    :config
    (global-set-key (kbd "C-c h s") 'helm-swoop)
    (define-key helm-swoop-map (kbd "M-i")
      'helm-multi-swoop-all-from-helm-swoop)
    (setq helm-multi-swoop-edit-save t
	  helm-swoop-split-with-multiple-windows t
	  helm-swoop-split-direction 'split-window-vertically
	  helm-swoop-speed-or-color t))
  (use-package helm-projectile
    :after (projectile)
    :config
    (helm-projectile-on)
    (setq projectile-completion-system 'helm)
    (setq projectile-indexing-method 'alien)))
#+END_SRC
** Elglot
:PROPERTIES:
:ID:       03d6f2fd-2956-473e-b654-4a2766edad38
:END:
An emacs language server protocol client. Kind of new.
Hopefully it gets useful in the future.
#+BEGIN_SRC emacs-lisp
(use-package eglot)
#+END_SRC
** Yasnippet
:PROPERTIES:
:ID:       42e5a0f0-74a7-485a-a909-471bffa936a5
:END:
#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :defer 1
  :init
  (defun start-yasnippet ()
    (interactive)
    (yas-minor-mode t))
  (defun elib-org-latex-yas ()
    (yas-activate-extra-mode  'latex-mode))
  ;; :commands yas-minor-mode
  ;; :hook (((prog-mode TeX-mode) . start-yasnippet))
  :config
  (use-package yasnippet-snippets)
  (set 'yas-verbosity 1)
  (add-to-list 'yas-snippet-dirs tuhdo-snippets-directory )
  (add-to-list 'yas-snippet-dirs elib-snippets-directory )
  (yas-global-mode t)
  (add-hook 'org-mode-hook #'elib-org-latex-yas))
#+END_SRC

** Terminal Usage
:PROPERTIES:
:ID:       9828326a-0250-455b-ac08-e349e5121ea2
:END:
Create and use multiple terminals with multi-term. It is
pretty nifty.
#+BEGIN_SRC emacs-lisp
(use-package multi-term
  :bind (("<f6>" . multi-term-next)
	 ("C-<f6>" . multi-term)
	 :map term-raw-map
	 ("C-c C-j" . term-line-mode))
  :config
  (if (file-exists-p "/usr/bin/fish")
      (setq multi-term-program "/usr/bin/fish"))
  (when (require 'term nil t) ;; only if term can be loaded..
    (setq
     term-bind-key-alist
     (list
      (cons "C-c C-c" 'term-interrupt-subjob)
      (cons "C-p" 'previous-line)
      (cons "C-n" 'next-line)
      (cons "M-f" 'term-send-forward-word)
      (cons "M-b" 'term-send-backward-word)
      (cons "C-c C-j" 'term-line-mode)
      (cons "C-c C-k" 'term-char-mode)
      (cons "M-DEL" 'term-send-backward-kill-word)
      (cons "M-d" 'term-send-forward-kill-word)
      (cons "<C-left>" 'term-send-backward-word)
      (cons "<C-right>" 'term-send-forward-word)
      (cons "C-r" 'term-send-reverse-search-history)
      (cons "M-p" 'term-send-raw-meta)
      (cons "M-y" 'term-send-raw-meta)
      (cons "C-y" 'term-send-raw)))))
	 #+END_SRC
** LaTeX/AUCTeX
:PROPERTIES:
:ID:       1b9bd876-1078-4366-9bde-9db814381c77
:END:
#+BEGIN_SRC emacs-lisp
(use-package tex
  :ensure auctex
  :mode (("\\.tex$" . TeX-mode))
  :defines TeX-run-TeX
  :bind (:map TeX-mode-map
	      ("C-c v" . elib-helm-tex-choose-program))


  :commands
  (TeX-revert-document-buffer
   TeX-command TeX-master-file)
  :config
  ;; (setq TeX-source-correlate-start-server t)
  (add-hook 'LaTeX-mode-hook #'TeX-source-correlate-mode)
  (add-hook 'TeX-after-compilation-finished-functions #'TeX-revert-document-buffer)
  ;; (define-key TeX-mode-map (kbd "TAB") 'company-complete)
  ;; (define-key TeX-mode-map (kbd "TAB") 'company-complete)
  (use-package tex-buf :ensure nil)
  (use-package latex-preview-pane
    :config
    (setq TeX-save-query nil)
    (latex-preview-pane-enable))
  (setq doc-view-continuous t)
  (use-package preview-latex
    :disabled t
    :defer 1)
  (use-package asy-mode
    :after (tex tex-buf)
    :when (executable-find "asy")
    :ensure nil
    :load-path elib-asymptote-load-path
    :mode ("\\.asy\\'" . asy-mode)
    :init
    (autoload 'asy-mode "asy-mode.el" "Asymptote Major Mode" t)
    (autoload 'lasy-mode "asy-mode.el" "Hybrid Asymptote/LaTeX Major Mode" t)
    (autoload 'asy-insinuate-latex "asy-mode.el" "Asymptote Insinuate LaTeX" t)
    :config
    (defun run-asy-in-tex ()
      (interactive "")
      (TeX-command TeX-run-TeX (TeX-master-file nil nil nil) t)
      (save-window-excursion (compile "asy *.asy"))
      (TeX-command TeX-run-TeX (TeX-master-file nil nil nil) t)
      )
    (add-to-list 'TeX-command-list
		 '("Asymptote" "asy *.asy" TeX-run-TeX nil t :help "Run Asymptote")))
  (setq TeX-auto-save t)
  (setq TeX-parse-self t)
  (setq-default TeX-master nil))
	 #+END_SRC
** Company
:PROPERTIES:
:ID:       1e97f178-f9db-4633-8c7e-fd5aa9a72bc5
:END:
 	#+BEGIN_SRC emacs-lisp
(use-package company
  :diminish company-mode
  :config
  (global-company-mode t)

  (setq company-idle-delay 0.01
	company-tooltip-idle-delay 0.01)
;;; Back-ends
;;; C/C++
  (use-package company-clang :ensure nil
    :config
    (setq
     company-clang-arguments
     (list "-std=c++1z" "-Wall" "-Werror"
	   "-Wpedantic -I./ -I./include/ -I../include/ -I../")))
  (use-package company-c-headers
    :after cc-mode
    :config
    ;; (define-key c-mode-map  [(tab)] 'company-complete)
    ;; (define-key c++-mode-map  [(tab)] 'company-complete)
    ;; (define-key c-mode-map (kbd "TAB") 'company-complete)
    ;; (define-key c++-mode-map (kbd "TAB") 'company-complete)
    (use-package semantic
      :commands semantic-gcc-setup
      :functions semantic-gcc-get-include-paths
      :config
      (semantic-gcc-setup)
      (dolist (name (semantic-gcc-get-include-paths "c++"))
	(add-to-list 'company-c-headers-path-system name)))
    (add-to-list 'company-backends 'company-c-headers))
  (use-package company-irony
    :after irony
    :hook (irony-mode . company-irony-setup-begin-commands)
    :config
    (use-package company-irony-c-headers
      :after company-c-headers
      :config
      (add-to-list-multi 'company-backends '(company-irony-c-headers company-irony))))

  ;; TeX
  (use-package company-auctex
    :after tex
    :config
    (company-auctex-init))
  ;; Yasnippet
  (use-package company-yasnippet
    :ensure nil
    :after yasnippet
    :config
    (global-set-key (kbd "C-c y") 'company-yasnippet)
    (add-to-list 'company-backends 'company-yasnippet t))
;;; Elisp
  ;; (define-key emacs-lisp-mode-map (kbd "TAB") 'company-complete)
;;; Generic
  ;; (define-key prog-mode-map (kbd "TAB") 'company-complete)
;;; Config

  (when company-backends
    (progn
      (delete 'company-semantic company-backends))))
  #+END_SRC
** Flycheck
:PROPERTIES:
:ID:       84781c34-923c-43a6-8df9-4b6a1366d4db
:END:
	 #+BEGIN_SRC emacs-lisp
(use-package flycheck
  :init
  (defun disable-flycheck-temporarily ()
    "Disables flycheck in current buffer."
    (interactive)
    (flycheck-mode -1))
  :config
  (setq flycheck-idle-change-delay 0.1)
  (add-hook 'org-src-mode-hook
            'disable-flycheck-temporarily)

  (global-flycheck-mode t))

	 #+END_SRC
** Web Development
:PROPERTIES:
:ID:       3c853127-d141-4de4-9f48-fd5dd4602930
:END:
	 #+BEGIN_SRC emacs-lisp
(use-package web-mode
	:defer 2)
	 #+END_SRC
** C/C++
:PROPERTIES:
:ID:       142a6210-ba13-4bfc-96d5-5034b7ed22c1
:END:
*** Basic Settings
:PROPERTIES:
:ID:       770bdc8e-7d22-488c-9e52-f44e75e60659
:END:
#+BEGIN_SRC emacs-lisp
(use-package cc-mode
  :mode (("\\.c\\'" . c-mode)
         ("\\.h\\'" . c++-mode)
         ("\\.hpp\\'" . c++-mode)
         ("\\.hxx\\'" . c++-mode)
         ("\\.ii\\'" . c++-mode)
         ("\\.C\\'" . c++-mode)
         ("\\.cpp\\'" . c++-mode)
         ("\\.CPP\\'" . c++-mode)
         ("\\.c++\\'" . c++-mode)
         ("\\.cxx\\'" . c++-mode)
         ("\\.cc\\'" . c++-mode)
         ("\\.CC\\'" . c++-mode))
  :hook (c-mode-common . hs-minor-mode)
  :bind (:map c-mode-base-map
              ("C-c o" . ff-find-other-file))
  :config
  (setq c-default-style "stroustrup"))
		#+END_SRC
*** Debugging
:PROPERTIES:
:ID:       035337e0-f10b-4bf8-a862-a14e8804eecc
:END:
		This is really cool. Try it with M-x gdb and choose the
		binary you want to debug.
		#+BEGIN_SRC emacs-lisp
(use-package gdb-mi
	:config
	(setq gdb-many-windows t
				gdb-show-main t))
		#+END_SRC
*** Packages
:PROPERTIES:
:ID:       94f26649-6cec-4874-816a-ed192e52b7be
:END:
**** Irony Mode
Irony provides auto completion for C++ which is helpful. It
uses a server program that has to be compiled before you can
use it. After installation, simply call [[elisp:(describe-function 'irony-install-server)][irony-install-server]]
:PROPERTIES:
:ID:       2e68a23b-3d71-4e76-af1f-4c36b383815d
:END:
		 #+BEGIN_SRC emacs-lisp
(use-package irony
  :after cc-mode
  :hook ((irony-mode . irony-cdb-autosetup-compile-options)
         (c-mode-common . irony-mode)))
		 #+END_SRC
**** Rtags
:PROPERTIES:
:ID:       dacd9601-b4cb-49f3-b1bd-fe0adb0b546b
:END:
		 #+BEGIN_SRC emacs-lisp
(use-package rtags
  :after cc-mode
  :when (executable-find "rdm")
  :commands rtags-diagnostics
  :load-path elib-rtags-load-path
  :ensure nil
  :bind (:map c-mode-base-map
              ("M-." . rtags-find-symbol-at-point)
              ("M-," . rtags-location-stack-back)
              ("C-x ." . rtags-find-symbol))
  :hook (c-mode-common . rtags-start-process-unless-running)
  :config
  (rtags-start-process-unless-running)
  (setq rtags-completions-enabled t)
  (setq rtags-autostart-diagnostics t)
  (rtags-diagnostics)
(use-package flycheck-rtags
    :after flycheck
    :load-path elib-rtags-load-path
    :ensure nil
    :hook (c-mode-common . another-flycheck-rtags-setup)
    :init
    (defun another-flycheck-rtags-setup ()
      (interactive)
      (flycheck-select-checker 'rtags)
      (setq-local flycheck-highlighting-mode nil)
      (setq-local flycheck-check-syntax-automatically nil)
      (rtags-enable-standard-keybindings))
    :config
    (require 'flycheck-rtags))
  (use-package company-rtags
    :after company
    :load-path elib-rtags-load-path
    :ensure nil
    :when (executable-find "rdm")
    :config
    (setq rtags-completions-enabled t)
    (add-to-list 'company-backends 'company-rtags))
  (use-package helm-rtags
    :after helm
    :load-path elib-rtags-load-path
    :ensure nil
    :config
    (setq rtags-display-result-backend 'helm)))
		 #+END_SRC

                 #+RESULTS:
                 : rtags-find-symbol

**** Clang Format
:PROPERTIES:
:ID:       6ca50e64-9ca9-42ca-8e64-279694d0d944
:END:
		 #+BEGIN_SRC emacs-lisp
(use-package clang-format
  :after cc-mode
  :bind (:map
	 c-mode-map
	 ("C-c f" . clang-format-region)
	 ("C-c C-f" . clang-format-buffer)
	 :map c++-mode-map
	 ("C-c f" . clang-format-region)
	 ("C-c C-f" . clang-format-buffer)))
		 #+END_SRC

**** Cmake
:PROPERTIES:
:ID:       c231c0a1-c165-4a46-a64c-d0d6da27f0c7
:END:
		 #+BEGIN_SRC emacs-lisp
(use-package cmake-mode
  :defer t
  :config
  (use-package cmake-font-lock
    :defer t
    :hook (cmake-mode . cmake-font-lock-activate)
    :config
    (autoload 'cmake-font-lock-activate "cmake-font-lock" nil t)))
		 #+END_SRC
**** Meson
:PROPERTIES:
:ID:       abbc6ce6-c892-494d-9dc5-821e063340f7
:END:

		 #+BEGIN_SRC emacs-lisp
(use-package meson-mode)
		 #+END_SRC
**** Cmake-ide
:PROPERTIES:
:ID:       e4b9cf20-4250-4756-82af-12a3f0ff09d0
:END:
		 #+BEGIN_SRC emacs-lisp
(use-package cmake-ide
	:after rtags
	:config
	(cmake-ide-setup))
		 #+END_SRC
** Emacs Lisp
:PROPERTIES:
:ID:       078eee9e-e320-40f5-a4b5-a9b75c5c6358
:END:
*** Eldoc
:PROPERTIES:
:ID:       403daf79-5206-41d5-8c8f-7d67cf471f9b
:END:
		#+BEGIN_SRC emacs-lisp
(defun turn-off-eldoc ()
	"Temporarily turn off eldoc-mode."
	(eldoc-mode -1))
(use-package "eldoc"
  :diminish eldoc-mode
  :defer 2
  :init
  (progn
    (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
    (add-hook 'lisp-interaction-mode-hook 'turn-on-eldoc-mode)
    (add-hook 'ielm-mode-hook 'turn-on-eldoc-mode)))
		#+END_SRC
*** Lispy
Lispy is an intersting package. At the moment, I don't use it.
**** Keybinding Cheat Sheet
 Key-bindings are
- Movement
  - j lispy-down
  - k lispy-up
  - h lispy-left
  - l lipsy-right
  - b special-lispy-back
    - Moves back in history for above commands
  - s special-lispy-move-down
  - w special-lispy-move-up
- Moving code around
  - > lispy-slurp
  - < lispy-barf
  - r lispy-raise
  - C lispy-convolute
- Function help
  - C-1 show function
  - C-2 show arguments
- Evaluation
  - e  evals
  - E evals and inserts
- Code exploration
  - F/M-. jumps to symbol
  - D/M-, jumps back
  - c clone
- Prettifying and transforming code
  - i prettify code
  - xi cond -> if
  - xc if -> cond
  - xf flatten function or macro
  - xr eval and replace
  - xl defun -> lambda
  - xd lambda -> defun
  - O make code one-line
  - M make code multi-line
**** Code
#+BEGIN_SRC emacs-lisp
(use-package
  lispy
  :hook ((inferior-emacs-lisp-mode
          ielm-mode
          lisp-mode
          lisp-interaction-mode
          emacs-lisp-mode) . lispy-mode))
#+END_SRC


* Org Mode
:PROPERTIES:
:ID:       bb4a983b-23e4-4f42-be11-7a7c062bcc9b
:END:
** Basic Setup
:PROPERTIES:
:ID:       bb4db413-5085-44e5-9606-f29c20891f43
:END:
	 #+BEGIN_SRC emacs-lisp
(use-package org
  :commands (org-mode org-babel-load-file org-babel-tangle-file)
  :preface
  (fset 'org-call-export-to-pdf
        (lambda (&optional arg) "Keyboard macro."
          (interactive "p")
          (kmacro-exec-ring-item '("lp" 0 "%d") arg)))
  (fset 'org-call-export-to-beamer
        (lambda (&optional arg) "Keyboard macro."
          (interactive "p")
          (kmacro-exec-ring-item
           (quote ("lP" 0
	           "%d")) arg)))
  :init
  (setq-default major-mode 'org-mode)
  (setq initial-major-mode 'org-mode)

  ;; Pressing enter on an org link follows the link
  (setq org-return-follows-link t)


  :config
  (add-hook 'org-mode-hook 'variable-pitch-mode)

  (use-package org-bullets
    :config
    (add-hook 'org-mode-hook (lambda () (org-bullets-mode t))))
  (defvar user-org-todo-key-sequences
    '((sequence "TODO(t)" "NEXT(n)" "WAITING(w)" "|"   "DONE(d)" "DELEGATED(D)" "CANCELLED(c)")))

  (setq org-todo-keywords user-org-todo-key-sequences)

  (setq org-pretty-entities t)
  (setq org-pretty-entities-include-sub-superscripts nil)
  (setq org-hide-emphasis-markers t)
  (setq org-startup-indented t)
  (setq org-export-async-init-file
        (expand-file-name
         (concat user-emacs-config-directory
                 "orginit.el"))
        org-export-in-background t
        org-export-async-debug nil)




  (use-package ob
    :ensure nil
    :bind (:map org-mode-map
                  ("C-c d" . elib-ob-execute-next-block)
                  ("C-c M-d" . elib-ob-reset-and-run-all-blocks-in-buffer))
    :preface
    (defun elib-ob-execute-next-block ()
      (interactive)
      (org-babel-next-src-block)
      (org-babel-execute-src-block))
    (defun elib-ob-reset-and-run-all-blocks-in-buffer ()
      (interactive)
      (when (ob-ipython--running-p)
        (ob-ipython-kill-kernel (car (ob-ipython--choose-kernel))))
      (beginning-of-buffer)
      (while (re-search-forward org-babel-src-block-regexp nil t)
        (org-babel-execute-src-block)))
    :config
    (use-package ox-latex
      :ensure nil
      :config
      (setq org-startup-with-latex-preview nil)
      (unless (getenv "TEXMFHOME")
        (setenv "TEXMFHOME" (concat (getenv "HOME") "/texmf")))
      (setq org-preview-latex-default-process 'imagemagick)
      ;; Format is ("options" "package)
      (add-to-list 'org-latex-packages-alist '("" "eetex"))
      (add-to-list 'org-latex-packages-alist '("" "tikz"))
)
    (use-package ox-twbs)
    (use-package ob-asymptote
      :ensure org)
    (use-package ob-ipython
      :when (or (file-exists-p "/usr/bin/jupyter")
                (file-exists-p (concat (getenv "HOME") "/.local/bin/jupyter")))

      :preface


      :config
      (defun ob-ipython--collect-json ()
        ;; hacks here
        (when (re-search-forward "{" nil t)
          (backward-char))
        ;; hacks end
        (let ((json-array-type 'list))
          (let (acc)
            (while (not (= (point) (point-max)))
              (setq acc (cons (json-read) acc))
              (forward-line))
            (nreverse acc))))
      (setq ob-ipython-command "jupyter")
      (add-hook 'org-babel-after-execute-hook 'org-display-inline-images 'append)
      (add-to-list 'org-latex-minted-langs '(ipython "python")))
    (use-package ox-ipynb
      :load-path user-emacs-config-directory
      :ensure nil)
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((C . t) (emacs-lisp . t) (python . t) (ipython . t) (asymptote . t)
                                        ;(sh . t)
       (gnuplot . t)))
    (setq org-confirm-babel-evaluate nil))


  (setq org-src-preserve-indentation t)
  (setq org-src-tab-acts-natively t)
  (plist-put org-format-latex-options :scale 1.5)

  (setq org-default-notes-file user-org-todo-file-name
        org-use-fast-todo-selection t
        org-src-window-setup 'current-window)

  :bind (("\C-cl" . org-store-link)
         ("\C-cb" . org-iswitchb)
         :map org-mode-map
         ("C-c C-p" . org-previous-visible-heading)
         ("C-c M-o" . org-toggle-link-display)
         ("S-<f5>" . org-call-export-to-pdf)
         ;;("<f5>" . org-call-export-to-beamer)
         ("C-c ." . org-time-stamp)
         ("\M-\C-g" . org-plot/gnuplot)))

	 #+END_SRC
** Capture
:PROPERTIES:
:ID:       284aed85-1e89-4404-833c-9fee55c367f0
:END:

#+BEGIN_SRC emacs-lisp
(defvar org-gtd-inbox (expand-file-name "~/nextcloud/org/inbox.org"))
(defvar user-org-gtd-inbox
  (expand-file-name
   (concat "~/nextcloud/org/inbox@"
           (replace-regexp-in-string
            "\n$" ""
            (shell-command-to-string "uname -n") )".org"  )))
(defvar user-org-gtd-file (expand-file-name "~/nextcloud/org/main-gtd.org"))
(defvar user-org-shopping-file (expand-file-name "~/nextcloud/org/shopping.org"))
(defvar user-org-tickler-file (expand-file-name "~/nextcloud/org/tickler.org"))
(defvar user-org-someday-file (expand-file-name "~/nextcloud/org/someday.org"))

(defvar org-capture-quote-tempalate
  `("q" "Quote " entry (file ,user-org-quotes-file-name)
    "* %?\n%U\n   "
    :empty-lines 1 :prepend t
    :kill-buffer t))

(defvar org-capture-event-template
  `("e" "Event" entry (file ,user-org-gtd-inbox)
    "* EVENT %i%? :event:\n"
    :empty-lines 1 :prepend t
    :kill-buffer t))



(defvar org-capture-tickler-template
  `("T" "Tickler" entry
    (file user-org-tickler-file)
    "* %i%? \n %U"
    :kill-buffer t :prepend t))

(defvar org-capture-stuff-to-buy-template
  `("b" "Buy" entry
    (file+headline
     ,user-org-shopping-file
     "Shopping")
    "* TODO Buy %i%? :shopping:"
    :empty-lines 1 :prepend t
    :kill-buffer t))

(defvar org-capture-todo-template
  `("t" "Todo [inbox]" entry
    (file ,user-org-gtd-inbox )
    "* TODO %i%?\n"
    :empty-lines 1 :kill-buffer t :prepend t))



(setq org-capture-templates nil)
(add-to-list-multi 'org-capture-templates
                   `(,org-capture-stuff-to-buy-template
                     ,org-capture-todo-template
                     ,org-capture-tickler-template
                     ,org-capture-quote-tempalate
                     ,org-capture-event-template
                     ))


(use-package org-capture
  :ensure nil
  :after org
  :commands org-capture
  :bind	 (("C-c c"  . org-capture))
  :config
  )
#+END_SRC
** Agenda
:PROPERTIES:
:ID:       5132d5c7-4885-4fed-a77f-1421c6684ae9
:END:
#+BEGIN_SRC emacs-lisp
(use-package org-agenda
  :ensure org
  :commands org-agenda
  :bind (("\C-ca" . org-agenda))
  :after org
  :init
  (defun org-current-is-todo ()
    (string= "TODO" (org-get-todo-state)))
  (defun org-current-is-next ()
    (string= "NEXT" (org-get-todo-state)))
  (defun org-current-is-actionable ()
    (or (org-current-is-todo)
        (org-current-is-next)))
  (defun my-org-agenda-skip-all-siblings-but-first ()
    "Skip all but the first non-done entry."
    (let (should-skip-entry)
      (unless (org-current-is-actionable)
        (setq should-skip-entry t))
      (save-excursion
        (while (and (not should-skip-entry) (org-goto-sibling t))
          (when (org-current-is-actionable)
            (setq should-skip-entry t))))
      (when should-skip-entry
        (or (outline-next-heading)
            (goto-char (point-max))))))
  (defun my-org-agenda-skip-all-siblings-but-first--next-only ()
    "Skip all but the first NEXT entry."
    (let (should-skip-entry)
      (unless (org-current-is-next)
        (setq should-skip-entry t))
      (save-excursion
        (while (and (not should-skip-entry) (org-goto-sibling t))
          (when (org-current-is-next)
            (setq should-skip-entry t))))
      (when should-skip-entry
        (or (outline-next-heading)
            (goto-char (point-max))))))

  :config
  (setq org-agenda-dim-blocked-tasks nil)
  (setq org-agenda-compact-blocks t)
  (setq org-agenda-files (list
                          user-current-events-file
                          config-file-file-name
                          user-org-todo-file-name
                          user-org-gtd-file
                          user-org-gtd-inbox
                          user-org-shopping-file
                          user-org-tickler-file
                          ))
  ;; Luna related contexts
  (defvar user-org-luna-context
    '("l" . "Luna Contexts"))
  (defvar user-org-luna-agenda
    '("lt" "Luna " tags-todo "@luna"
      ((org-agenda-overriding-header "Luna")
       (org-agenda-skip-function #'my-org-agenda-skip-all-siblings-but-first))))
  (defvar user-org-luna-agenda-next-only
    '("ln" "Luna --- Next Only " tags-todo "@luna"
      ((org-agenda-overriding-header "Luna")
       (org-agenda-skip-function #'my-org-agenda-skip-all-siblings-but-first--next-only))))
  (defvar user-org-luna-agenda-next-all
    '("la"
      "Luna --- All Next"
      ((tags-todo "@luna"))
      ((org-agenda-skip-function
        '(org-agenda-skip-entry-if
          'todo
          '("TODO" "WAITING")))
       (org-agenda-overriding-header
        "Luna"))))

  ;; Emacs related context
  (defvar user-org-emacs-context '("E" . "Emacs Contexts"))
  (defvar user-org-emacs-agenda '("Et" "Emacs " tags-todo "@emacs"
                                  ((org-agenda-overriding-header "Emacs")
                                   (org-agenda-skip-function #'my-org-agenda-skip-all-siblings-but-first))))

  (defvar user-org-emacs-agenda-next-only
    '("En" "Emacs --- Next Only " tags-todo "@emacs"
      ((org-agenda-overriding-header "Emacs")
       (org-agenda-skip-function #'my-org-agenda-skip-all-siblings-but-first--next-only))))


  (defvar user-org-emacs-agenda-all-next
    '("Ea"
      "Emacs --- All Next"
      ((tags-todo "@emacs"))
      ((org-agenda-skip-function
        '(org-agenda-skip-entry-if
          'todo
          '("TODO" "WAITING")))
       (org-agenda-overriding-header
        "Emacs"))))

  ;; Studies/Physics related context

  (defvar user-org-physics-context '("p" . "Physics Contexts"))
  (defvar user-org-physics-agenda '("pt" "Physics " tags-todo "@studies"
                                    ((org-agenda-overriding-header "Studies")
                                     (org-agenda-skip-function #'my-org-agenda-skip-all-siblings-but-first))))

  (defvar user-org-physics-agenda-next-only
    '("pn" "Physics --- Next Only " tags-todo "@studies"
      ((org-agenda-overriding-header "Studies")
       (org-agenda-skip-function #'my-org-agenda-skip-all-siblings-but-first--next-only))))


  (defvar user-org-physics-agenda-all-next
    '("pa"
      "Physics --- All Next"
      ((tags-todo "@studies"))
      ((org-agenda-skip-function
        '(org-agenda-skip-entry-if
          'todo
          '("TODO" "WAITING")))
       (org-agenda-overriding-header
        "Studies"))))



  ;; Home context
  (defvar user-org-home-context '("h" . "Home Contexts"))
  (defvar user-org-home-agenda '("ht" "Home " tags-todo "@home"
                                 ((org-agenda-overriding-header "Home")
                                  (org-agenda-skip-function #'my-org-agenda-skip-all-siblings-but-first))))

  (defvar user-org-home-agenda-next-only
    '("hn" "Home --- Next Only " tags-todo "@home"
      ((org-agenda-overriding-header "Home")
       (org-agenda-skip-function #'my-org-agenda-skip-all-siblings-but-first--next-only))))


  (defvar user-org-home-agenda-all-next
    '("ha"
      "Home --- All Next"
      ((tags-todo "@home"))
      ((org-agenda-skip-function
        '(org-agenda-skip-entry-if
          'todo
          '("TODO" "WAITING")))
       (org-agenda-overriding-header
        "Home"))))
  ;; Generic

  (defvar user-org-generic-context '("n" . "All Contexts"))
  (defvar user-org-generic-agenda-next-only
    '("nn"
      "All --- Next Only "
      ((todo))
      ((org-agenda-skip-function
        #'my-org-agenda-skip-all-siblings-but-first--next-only))))
  (defvar user-org-generic-agenda-all-next
    '("na"
      "All --- All Next"
      ((todo))
      ((org-agenda-skip-function '(org-agenda-skip-entry-if
                                   'todo '("TODO" "WAITING"))))))
  ;; Finally
  (setq org-agenda-custom-commands
        (list
         user-org-luna-context
         user-org-luna-agenda
         user-org-luna-agenda-next-only
         user-org-luna-agenda-next-all
         user-org-emacs-context
         user-org-emacs-agenda
         user-org-emacs-agenda-next-only
         user-org-emacs-agenda-all-next
         user-org-physics-context
         user-org-physics-agenda
         user-org-physics-agenda-next-only
         user-org-physics-agenda-all-next
         user-org-home-context
         user-org-home-agenda
         user-org-home-agenda-next-only
         user-org-home-agenda-all-next
         user-org-generic-context
         user-org-generic-agenda-next-only
         user-org-generic-agenda-all-next)))
#+END_SRC


** Refile
:PROPERTIES:
:ID:       d6e57986-c359-4249-93bd-85ec765f1373
:END:
We cannot use use-package here because the refile things are
defined in the same file as the regular
org-functionality. We instead do a hand-made version by
telling emacs to run some code either once it loads [[elisp:(describe-function
 'org-agenda)][`org-agenda']] or, if [[elisp:(describe-function 'org-agenda)][`org-agenda']] is already loaded just load
it immediately. This is done by the [[elisp:(describe-function 'eval-after-load)][`eval-after-load']]
functionality of Emacs.
#+BEGIN_SRC emacs-lisp
(eval-after-load
    "org-agenda"
  '(progn
     (setq org-refile-targets
           '((nil :maxlevel . 3)
             (user-org-gtd-file
              :maxlevel . 3)
             (org-gtd-inbox :level . 1)
             (user-org-gtd-inbox :level . 1)
             (config-file-file-name
              :maxlevel . 3)
             (user-org-tickler-file
              :maxlevel . 2)))))
#+END_SRC
** Calendar
:PROPERTIES:
:ID:       84501e67-62f7-4d9b-9af8-37fdd13d20f3
:END:
 #+BEGIN_SRC emacs-lisp
(use-package calfw
  :when (file-exists-p
         (expand-file-name "~/nextcloud/org/orgsettings.el"))
  :config
  (defun elib-open-calendar-template ()
    (interactive)
    (cfw:open-calendar-buffer
     :date nil :buffer nil :custom-map nil :view nil
     :sorter nil
     :annotation-sources nil
     :contents-sources
     (list
      (cfw:ical-create-source
       "Gmail" "calendar-address"
       "Blue")
      (cfw:ical-create-source
       "Info"     "calendar-address"
       "Purple")
      (cfw:ical-create-source
       "lu"     "calendar-address"
       "Red")
      (cfw:org-create-source "Red")
      )))
  (use-package calfw-org)
  (use-package calfw-ical)
  ;; (use-package calfw-org)
  ;; (use-package calfw-gcal)
  (use-package org-gcal
    :disabled t
    :after org
    :ensure nil
    :commands (org-gcal
               org-gcal-sync org-gcal-fetch
               org-gcal-refresh-token)
    :hook ((org-agenda-mode . org-gcal-fetch)
           (org-capture-after-finalize . org-gcal-fetch))
    :load-path elib-org-gcal-load-path
    :config

    )
  (load-file (expand-file-name "~/nextcloud/org/orgsettings.el"))
  (bind-key "C-c q" 'elib-open-calendar)
  ;; (setq cfw:org-agenda-schedule-args '(:timestamp))
  (setq cfw:org-overwrite-default-keybinding t)
  (setq calendar-week-start-day 1) ;; 1 = Monday, 0 = Sunday

  )

(defvar org-caldavsettings-file (concat org-gcal-calendar-location "caldavsettings.el"))


(load-file org-caldavsettings-file)

(use-package org-caldav
  :after org
  :config
  ;; this hook saves an ics file once an org-buffer is saved
  (use-package oauth2)
  (setq plstore-cache-passphrase-for-symmetric-encryption t)
  (defun my-icalendar-agenda-export()
    (if (member (buffer-file-name) org-agenda-files)
        (org-icalendar-combine-agenda-files)))
  ;; (add-hook 'after-save-hook 'my-icalendar-agenda-export
  ;; )
  ;; (run-with-idle-timer  1200 t  'org-caldav-sync)
  ;; (org-caldav-sync)

  )
(setq org-icalendar-alarm-time 1440)
(setq org-icalendar-combined-name "Org Mode Calendar")
(setq org-icalendar-combined-description "Calendar exported from Org-mode")
(setq org-icalendar-exclude-tags nil)
(setq org-icalendar-combined-agenda-file (expand-file-name "~/nextcloud/org/cal/combined.ics"))
(setq org-icalendar-include-todo 'all)
(setq org-icalendar-use-deadline '(event-if-todo event-if-not-todo))
(setq org-icalendar-use-scheduled '(event-if-todo event-if-not-todo))
(setq org-icalendar-store-UID t)
	 #+END_SRC
** Table of Content Generation
:PROPERTIES:
:ID:       e4967c66-567f-4fd9-a13c-e41e8b0ad444
:END:
#+BEGIN_SRC emacs-lisp
(use-package toc-org
  :hook ((org-mode . toc-org-enable)))
#+END_SRC
* Communication
:PROPERTIES:
:ID:       891ec807-5600-43e3-a82d-876ca19fc80b
:END:
** Email
:PROPERTIES:
:ID:       85c9e3ba-bb40-4ac8-93cb-bfd7c1f942b1
:END:
*** Misc
:PROPERTIES:
:ID:       e7f4c7a0-4f14-4a73-8b89-608b1a009cc0
:END:
		#+BEGIN_SRC emacs-lisp
(require 'gnus-dired)
(require 'smtpmail)

;; make the `gnus-dired-mail-buffers' function also work on
;; message-mode derived modes, such as mu4e-compose-mode
(bind-keys* :map dired-mode-map ("a" . gnus-dired-attach))

(defun gnus-dired-mail-buffers ()
  "Return a list of active message buffers."
  (let (buffers)
    (save-current-buffer
      (dolist (buffer (buffer-list t))
	(set-buffer buffer)
	(when (and (derived-mode-p 'message-mode)
		   (null message-sent-message-via))
	  (push (buffer-name buffer) buffers))))
    (nreverse buffers)))
(setq gnus-dired-mail-mode 'mu4e-user-agent)
(add-hook 'dired-mode-hook 'turn-on-gnus-dired-mode)
		#+END_SRC
*** Mu4e
:PROPERTIES:
:ID:       6c9d56eb-6703-49d1-8386-fb44a3db1ee9
:END:
#+BEGIN_SRC emacs-lisp
(defun get-string-from-file (filePath)
  "Return filePath's file content."
  (with-temp-buffer
    (insert-file-contents filePath)
    (buffer-string)))
(defvar elib-info-signature-file (potential-load-paths '("~/.emacs.d/files/info-signature.org")) )


(defun my-mu4e-choose-signature ()
  "Insert one of a number of sigs"
  (interactive)
  (let
      ((message-signature
        (mu4e-read-option
         "Signature:"
         `(("info" .
            ,(get-string-from-file elib-info-signature-file))
           ("swan" .
            "Einar Elén
Secretary of the steering group (SWAN)
")))))
    (message-insert-signature)
(org-mime-htmlize)
))

(defvar mu4e-previous-attachment-directory "~/Downloads")
(defvar mu4e-attachment-dired-buffer nil)
(defvar mu4e-attachment-dired-buffer-name "*mu4e-dired-for-attach*")



(bind-keys*
 :map dired-mode-map
 ("Q" . mu4e-attachment-quit))

(defun start-mu4e-attachment-dired ()
  (interactive)
  ;; (unless (bufferp mu4e-attachment-dired-buffer)
  ;;   (setq mu4e-attachment-dired-buffer
  ;;         (get-buffer-create
  ;;          mu4e-attachment-dired-buffer-name)))
  (dired mu4e-previous-attachment-directory)
  (let ((previous-dired dired-directory))
    (if (y-or-n-p-with-timeout (format "Use previous attachment
  directory, %s? " previous-dired) 4 t)
        (progn (quit-window)
               (dired mu4e-previous-attachment-directory))
      (progn (quit-window)
             (call-interactively 'dired)))))
(defun mu4e-attachment-quit ()
  (interactive)
  (if (equal major-mode 'dired-mode)
      (setq mu4e-previous-attachment-directory
            dired-directory))
  (quit-window))
(defun mu4e-attach-advice (&rest ignored)
  (mu4e-attachment-quit))
(advice-add 'gnus-dired-attach :after #'mu4e-attach-advice)

(when elib-mu4e-load-path
  (use-package mu4e
    :ensure nil
    :bind (("<f12>" . mu4e)
           :map mu4e-compose-mode-map
           ("C-c d" . start-mu4e-attachment-dired)
           )
    :when (executable-find "mu")
    :init
    (defun choose-msmtp-account ()
      (if (message-mail-p)
          (save-excursion
            (let*
                ((from (save-restriction
                         (message-narrow-to-headers)
                         (message-fetch-field "from")))
                 (case-fold-search t)
                 (account
                  (cond
                   ((string-match "gmail.com" from) "gmail")
                   ((string-match "student.lu.se" from) "lu")
                   ((string-match "luna.lu.se" from) "info"))))
              (setq message-sendmail-extra-arguments (list '"-a" account))))))
    (defun my-mu4e-set-account ()
      "Set the account for composing a message."
      (let* ((account
              (if mu4e-compose-parent-message
                  (let ((maildir (mu4e-message-field mu4e-compose-parent-message :maildir)))
                    (string-match "/\\(.*?\\)/" maildir)
                    (match-string 1 maildir))
                (completing-read (format "Compose with account: (%s) "
                                         (mapconcat #'(lambda (var) (car var))
                                                    my-mu4e-account-alist "/"))
                                 (mapcar #'(lambda (var) (car var)) my-mu4e-account-alist)
                                 nil t nil nil (caar my-mu4e-account-alist))))
             (account-vars (cdr (assoc account my-mu4e-account-alist))))
        (if account-vars
            (mapc #'(lambda (var)
                      (set (car var) (cadr var)))
                  account-vars)
          (error "No email account found"))))
    :load-path elib-mu4e-load-path
    :hook ((mu4e-compose-mode . (lambda ()
                                  (local-set-key
                                   (kbd "C-c C-w")
                                   #'my-mu4e-choose-signature)))
           (message-send-mail . choose-msmtp-account)
           (mu4e-compose-pre . my-mu4e-set-account))
    :config
    (use-package helm-mu
      :after helm
      :bind (:map mu4e-main-mode-map
                  ("s" . helm-mu)
                  ("c" . helm-mu-contacts)
                  :map mu4e-headers-mode-map
                  ("s" . helm-mu)
                  ("c" . helm-mu-contacts)
                  :map mu4e-view-mode-map
                  ("s" . helm-mu))
      :config
      (setq helm-mu-contacts-after "01-Jan-2017 00:00:00"))
    (use-package mu4e-contrib
      :ensure nil
      :load-path elib-mu4e-load-path)
    (use-package org-mu4e
      :load-path elib-mu4e-load-path
      :ensure nil
      :after org
      :config
      (setq org-mu4e-link-query-in-headers-mode nil))
    (use-package mu4e-alert)
    (use-package mu4e-jump-to-list)
    (use-package mu4e-conversation)
    (use-package mu4e-maildirs-extension)
    (setq mu4e-maildir "~/Maildir"
          mu4e-sent-messages-behavior 'delete
          mu4e-use-fancy-chars t
          mu4e-attachment-dir "~/Downloads/"
          mu4e-view-show-images t
          mu4e-get-mail-command "mbsync -a"
          mu4e-update-interval 3600)
    (setq mu4e-sent-folder "/gmail/sent-mail"
          mu4e-drafts-folder "/gmail/drafts"
          mu4e-trash-folder "/gmail/trash"
          user-mail-address "einar.elen@gmail.com"
          smtpmail-default-smtp-server "smtp.gmail.com"
          ;;smtpmail-local-domain "account1.example.com"
          smtpmail-smtp-server "smtp.gmail.com"
          smtpmail-stream-type 'starttls
          smtpmail-smtp-service 587)


    (defvar my-mu4e-account-alist
      '(("gmail"
         (mu4e-sent-folder "/gmail/sent-mail")
         (mu4e-drafts-folder "/gmail/drafts")
         (mu4e-trash-folder "/gmail/trash")
         (user-full-name "Einar Elén")
         (user-mail-address "einar.elen@gmail.com")
         (smtpmail-default-smtp-server "smtp.gmail.com")
         ;;smtpmail-local-domain "account1.example.com"
         (smtpmail-smtp-server "smtp.gmail.com")
         (smtpmail-stream-type 'starttls)
         (smtpmail-smtp-service 587)
         )
        ("lu"
         (mu4e-sent-folder "/lu/sent-mail")
         (mu4e-drafts-folder "/lu/drafts")
         (mu4e-trash-folder "/lu/trash")
         (user-mail-address "nat13eel@student.lu.se")
         (user-full-name "Einar Elén")
         (smtpmail-default-smtp-server "smtp.gmail.com")
         ;;(smtpmail-local-domain "")
         (smtpmail-smtp-user "nat13eel")
         (smtpmail-smtp-server "smtp.gmail.com")
         (smtpmail-stream-type starttls)
         (smtpmail-smtp-service 465))
        ("info"
         (mu4e-sent-folder "/info/sent-mail")
         (mu4e-drafts-folder "/info/drafts")
         (mu4e-trash-folder "/info/trash")
         (user-mail-address "info-ordf@luna.lu.se")
         (user-full-name "Chairperson, Information Committee (LUNA)")
         (smtpmail-default-smtp-server "smtp.gmail.com")
         ;;(smtpmail-local-domain "")
         (smtpmail-smtp-user "info-ordf")
         (smtpmail-smtp-server "smtp.gmail.com")
         (smtpmail-stream-type starttls)
         (smtpmail-smtp-service 587))
        ))

    (setq message-send-mail-function 'message-send-mail-with-sendmail
          sendmail-program "/usr/bin/msmtp"
          user-full-name "Einar Elén")
    ;; Borrowed from http://ionrock.org/emacs-email-and-mu.html
    ;; Choose account label to feed msmtp -a option based on From header
    ;; in Message buffer; This function must be added to
    ;; message-send-mail-hook for on-the-fly change of From address before
    ;; sending message since message-send-mail-hook is processed right
    ;; before sending message.

    (setq message-sendmail-envelope-from 'header)
    (add-to-list-multi
     'mu4e-bookmarks
     `(,(make-mu4e-bookmark
         :name "All New Inbox Mail"
         :query "maildir:/gmail/Inbox OR \
maildir:/lu/Inbox OR maildir:/info/Inbox and flag:unread"
         :key ?z)
       ,(make-mu4e-bookmark
         :name "All Sent Mail"
         :query
         "\"maildir:/gmail/[Gmail]/Sent Mail\" OR \
\"maildir:/lu/[Gmail]/Sent Mail\" OR \
maildir:/info/[Gmail]/Skickat"
         :key ?s)
       ,(make-mu4e-bookmark
         :name "With PDF Files"
         :query "mime:application/pdf"
         :key ?P)))
    (setq mu4e-view-prefer-html t)

    (setq mu4e-maildir-shortcuts
          '(("/gmail/Inbox" . ?g)
            ("/gmail/[Gmail]/Sent Mail" . ?G)
            ("/lu/Inbox" . ?l)
            ("/lu/[Gmail]/Sent Mail" . ?L)
            ("/info/Inbox" . ?i)
            ("/info/[Gmail]/Skickat" . ?I)
            ("/gmail/[Gmail]/Trash" . ?t)
            ))
    ;; (add-to-list 'mu4e-bookmarks
    ;;              '("maildir:/Gmail/gitorious-ml flag:unread" "Unread on the mailing list" ?m))

    ;; Needed with mbsync, apparently
    (setq mu4e-change-filenames-when-moving t)
    (setq mu4e-html2text-command 'mu4e-shr2text)
    ;; (setq mu4e-html2text-command "w3m -T text/html")
    (setq shr-color-visible-luminance-min 80)

    ;; Experimental
    (setq mu4e-compose-format-flowed t)

    ))

(use-package org-mime
  :init
  (defun org-mime-org-buffer-htmlize ()
    "Create an email buffer containing the current org-mode file
  exported to html and encoded in both html and in org formats as
  mime alternatives."
    (interactive)
    (org-mime-send-buffer 'html)
    (message-goto-to))
  (defun mu4e-compose-org-mail ()
    (interactive)
    (mu4e-compose-new)
    (org-mu4e-compose-org-mode))
  ;; this is stolen from John but it didn't work for me until I
  ;; made those changes to mu4e-compose.el
  (defun htmlize-and-send ()
    "When in an org-mu4e-compose-org-mode message, htmlize and send it."
    (interactive)
    (when (member 'org~mu4e-mime-switch-headers-or-body post-command-hook)
      (org-mime-htmlize)
      (org-mu4e-compose-org-mode)
      (mu4e-compose-mode)
      (message-send-and-exit)))

  :config
  ;; This overloads the amazing C-c C-c commands in org-mode with one more function
  ;; namely the htmlize-and-send, above.
  (add-hook 'org-ctrl-c-ctrl-c-hook 'htmlize-and-send t)

  ;; Originally, I set the `mu4e-compose-mode-hook' here, but
  ;; this new hook works much, much better for me.
  (add-hook 'mu4e-compose-post-hook
            (defun do-compose-stuff ()
              "My settings for message composition."
              (org-mu4e-compose-org-mode)))


  )

#+END_SRC

** Web Browsing
:PROPERTIES:
:ID:       d26d51a3-2894-4a4b-abf3-a47859d99fd3
:END:
#+BEGIN_SRC emacs-lisp
(use-package w3m-load
  :when (and (executable-find "w3m") (file-exists-p
                                      "/usr/share/emacs/site-lisp/w3m"))
  :load-path "/usr/share/emacs/site-lisp/w3m/"
  :ensure nil
  )
#+END_SRC
* Utilities
:PROPERTIES:
:ID:       d3f405a0-845a-4217-8767-9ac286ce1107
:END:
** Spell Checking
:PROPERTIES:
:ID:       59f29b06-a01d-4073-a3cd-02ec9d5ec7b8
:END:
*** Abbrev
:PROPERTIES:
:ID:       e06b732b-55ae-45d2-914e-924681806857
:END:
#+BEGIN_SRC emacs-lisp
(use-package abbrev
  :disabled t
  :ensure nil
  :defer t
  :custom
  (abbrev-file-name abbrev-location)
  (abbrev-mode t)
  :config
  (if (file-exists-p abbrev-file-name)
      (quietly-read-abbrev-file))
  )
#+END_SRC
*** Flyspell
:PROPERTIES:
:ID:       8a3113a7-f058-4209-8332-49520dc98a0f
:END:
#+BEGIN_SRC emacs-lisp
(use-package flyspell
  :defer 1
  :disabled t
  :custom
  (flyspell-abbrev-p t)
  (flyspell-issue-message-flag nil)
  (flyspell-issue-welcome-flag nil)
  (flyspell-mode 1)
  :config
  (use-package helm-flyspell
    :bind (("C-c ;" . helm-flyspell-correct))))
#+END_SRC
** Google Translate
:PROPERTIES:
:ID:       c39596fe-1f9e-41ac-82e6-588bbedd90b2
:END:
	 #+BEGIN_SRC emacs-lisp
(use-package google-translate
  :config
  (use-package google-translate-smooth-ui
    :ensure nil
    :bind (("C-c t" . 'google-translate-smooth-translate))
    :config
    (setq google-translate-translation-directions-alist
	  '(("sv" . "en") ("en" . "sv")))))
	 #+END_SRC
** Lastpass
:PROPERTIES:
:ID:       6bc5ecbf-e884-43b4-858a-cc59853b1a71
:END:
	 #+BEGIN_SRC emacs-lisp
(defun lp-login (login-name)
  "Testing"
  (interactive "sLastpass account: ")
  (shell-command (concat "lpass login " login-name)))
(defun lp-ls
    (&optional args output-buffer error-buffer)
  "Derp"
  (interactive "s(Optional) Group name:
	 s(Optional) Output buffer: ")
  (if (string= output-buffer "")
      (shell-command (concat "lpass ls " args))
    (shell-command (concat "lpass ls " args) output-buffer error-buffer)))

(defun lp-show (name &optional output-buffer error-buffer)
  "darp"
  (interactive "sName: ")
  (if (string= output-buffer "") (shell-command (concat "lpass show" name))(shell-command (concat "lpass show " name) output-buffer error-buffer)))

(defun lp-insert-show (name)
  "dlarp"
  (interactive "sName: ") (lp-show name t))
(defun lp-insert-ls (&optional args)
  "Derp"
  (interactive "s(Optional) Group name:") (lp-ls args t))
(defun lp-get-password (name &optional output-buffer error-buffer)
  (interactive "sName: ")
  (lp-show (concat name "| grep password | grep -v sudo | cut -d\" \" -f2 ") output-buffer error-buffer))

(defun lp-insert-password (name)
  (interactive "sName: ")
  (lp-get-password name t))
	 #+END_SRC
** Presentations
:PROPERTIES:
:ID:       194829a7-5352-480e-9835-3c20d1e608a3
:END:
	 #+BEGIN_SRC emacs-lisp
(use-package demo-it
	:config)

(use-package
  ox-reveal
  :after org
  :config
  (use-package htmlize)
  (setq org-reveal-root "https://cdn.jsdelivr.net/reveal.js/3.0.0/")
  )
;(demo-it-create (demo-it-presentation "./configuration.org"))

;(demo-it-start)
	 #+END_SRC

* Experimental
:PROPERTIES:
:ID:       ce0fc4de-8b3b-4cb3-b1f5-796b2a1d1524
:END:
** Emacs Lisp
:PROPERTIES:
:ID:       b5e75921-2a62-41e7-b76c-9aaf7085cb7b
:END:
	 #+BEGIN_SRC emacs-lisp
;(semantic-mode -1)
(use-package org-notes
	:when (file-exists-p "~/ownCloud/projects/elisp/")
	:disabled t
	:load-path "~/ownCloud/projects/elisp/"
	:ensure nil
	:commands (org-notes-mode
						 toggle-org-latex-export-on-save
						 org-notes-cpp-help
						 org-notes-latex-help
						 org-notes-math-help))
(use-package meson-ide
	:when (file-exists-p (expand-file-name "~/meson-ide"))
	:after org-mode
	:disabled t
	:load-path "~/meson-ide"
	:ensure nil
	:defer 3
	:preface
	(defun compile-meson-ide ()
		(when nil (let ((default-directory "~/.emacs.d/org-notes-mode/meson-ide/"))
							(org-babel-tangle-file "meson-ide.org"))))
	(compile-meson-ide)
	:config
	(meson-ide-setup))

(use-package ert
	:commands (ert-deftest ert))
	 #+END_SRC
* To be integrated
** Python
#+BEGIN_SRC emacs-lisp
(use-package python-mode
  :config
  (setq py-python-command "python3"


        )
  (defun python (&optional argprompt buffer fast exception-buffer split switch)
  "Start an Python interpreter.

Optional ARG \\[universal-argument] prompts for path to the interpreter."
  (interactive "P")
  (py-shell argprompt nil "python3" buffer fast exception-buffer split switch)))
(use-package elpy
  :config
  :disabled t
  (setq python-shell-interpreter "jupyter"
        python-shell-interpreter-args "console --simple-prompt"
        )
  (setq python-shell-interpreter "jupyter"
        python-shell-interpreter-args "console --simple-prompt"
        python-shell-prompt-detect-failure-warning nil)
  (add-to-list 'python-shell-completion-native-disabled-interpreters
               "jupyter")

  (elpy-enable)
  (setq elpy-modules (delq 'elpy-module-flymake elpy-modules))
  (add-hook 'elpy-mode-hook 'flycheck-mode)
  (use-package py-autopep8
    :config
    (add-hook 'elpy-mode-hook 'py-autopep8-enable-on-save))


  ;; (elpy-use-ipython)
  (setq elpy-rpc-python-command "python3"))
(use-package ein
    :config
    (setq ein:jupyter-default-server-command "jupyter")
    (use-package ein-company
      :ensure nil
      :config
      (require 'ein-company)
      )
    )
#+END_SRC
** ?
:PROPERTIES:
:ID:       9dafe517-3d1c-4cd5-9a12-5550abed6e44
:END:
There is only darkness here. Flee.
	#+BEGIN_SRC emacs-lisp
(use-package lorem-ipsum)
(defun rgr/toggle-context-help ()
  "Turn on or off the context help.
Note that if ON and you hide the help buffer then you need to
manually reshow it. A double toggle will make it reappear"
  (interactive)
  (with-current-buffer (help-buffer)
    (unless (local-variable-p 'context-help)
      (set (make-local-variable 'context-help) t))
    (if (setq context-help (not context-help))
	(progn
	  (if (not (get-buffer-window (help-buffer)))
	      (display-buffer (help-buffer)))))
    (message "Context help %s" (if context-help "ON" "OFF"))))

(defun rgr/context-help ()
  "Display function or variable at point in *Help* buffer if visible.
Default behaviour can be turned off by setting the buffer local
context-help to false"
  (interactive)
  (let ((rgr-symbol (symbol-at-point))
        (help-window-select)
        ) ; symbol-at-point http://www.emacswiki.org/cgi-bin/wiki/thingatpt%2B.el
    (with-current-buffer (help-buffer)
      (unless (local-variable-p 'context-help)
        (set (make-local-variable 'context-help) t))
      (if (and context-help (get-buffer-window (help-buffer))
               rgr-symbol)
          (if (fboundp  rgr-symbol)
              (describe-function rgr-symbol)
	    (if (boundp  rgr-symbol) (describe-variable rgr-symbol)))))))

(defadvice eldoc-print-current-symbol-info
    (around eldoc-show-c-tag activate)
  (cond
   ((eq major-mode 'emacs-lisp-mode) (rgr/context-help) ad-do-it)
   ((eq major-mode 'lisp-interaction-mode) (rgr/context-help) ad-do-it)
   ((eq major-mode 'apropos-mode) (rgr/context-help) ad-do-it)
   (t ad-do-it)))

(global-set-key (kbd "C-c C-h") 'rgr/toggle-context-help)

;; (define-minor-mode my-contextual-help-mode
;;   "Displays help for the current symbol whenever the *Help* buffer is visible.

;; Advises `eldoc-print-current-symbol-info'."
;;   :lighter " C-h"
;;   :global t
;;   (require 'help-mode) ;; for `help-xref-interned'
;;   (message "Contextual help is %s" (if my-contextual-help-mode "on" "off"))
;;   (and my-contextual-help-mode
;;        (eldoc-mode 1)
;;        (eldoc-current-symbol)
;;        (my-contextual-help :force)))

;; (defadvice eldoc-print-current-symbol-info (before my-contextual-help activate)
;;   "Triggers contextual elisp *Help*. Enabled by `my-contextual-help-mode'."
;;   (and my-contextual-help-mode
;;        (derived-mode-p 'emacs-lisp-mode)
;;        (my-contextual-help)))

;; (defun my-contextual-help (&optional force)
;;   "Display function or variable at point in *Help* buffer, if visible."
;;   (when (or force (get-buffer-window (help-buffer)))
;;     (let ((sym (eldoc-current-symbol)))
;;       ;; If something else changes the help buffer contents, ensure we
;;       ;; don't immediately revert back to the current symbol's help.
;;       (and sym
;;            (not (keywordp sym))
;;            (not (eq sym (get 'my-contextual-help 'last-sym)))
;;            (put 'my-contextual-help 'last-sym sym)
;;            (save-selected-window
;;              (help-xref-interned sym))))))

;; (my-contextual-help-mode 1)


(use-package nameless
  :after (lisp-mode org-mode)
  :hook ((emacs-lisp-mode org-mode) . nameless-mode))

(use-package xah-replace-pairs
	:commands xah-replace-pairs-region
	:preface
	(defvar multireplace-list nil "Nah.")
	(defvar multireplace-pair-first nil "nah.")
	(defvar multireplace-pair-second nil "nah.")
	(defun multireplace (first second)
		(interactive "r")
		(while (yes-or-no-p "More pairs?")
			(print "1")
			(setq multireplace-pair-first (read-from-minibuffer "First:"))
			(print multireplace-pair-first)
			(setq multireplace-pair-second (read-from-minibuffer "Second:"))
			(print multireplace-pair-second)
			(setq multireplace-list (cons (list multireplace-pair-first multireplace-pair-second) multireplace-list))
			(setq multireplace-pair-first nil multireplace-pair-second nil))
		(xah-replace-pairs-region first second multireplace-list)
		(setq multireplace-list nil multireplace-pair-first nil
					multireplace-pair-second nil))
	:defer t)


(use-package multiple-cursors
  :bind (("C-M-." . mc/mark-next-like-this))
  )


	#+END_SRC
	#+BEGIN_SRC emacs-lisp
(global-prettify-symbols-mode t)
(defun eshell-here ()
		"Opens up a new shell in the directory associated with the
current buffer's file. The eshell is renamed to match that
directory to make multiple eshell windows easier."
		(interactive)
		(let* ((parent (if (buffer-file-name)
											 (file-name-directory (buffer-file-name))
										 default-directory))
					 (height (/ (window-total-height) 3))
					 (name   (car (last (split-string parent "/" t))))
					 (_eshell-name (concat "*eshell: " name "*"))
					 (already-existing (get-buffer _eshell-name)))
			(split-window-vertically (- height))
			(other-window 1)
			(if already-existing
					(switch-to-buffer _eshell-name)
					(eshell "new")
					(rename-buffer _eshell-name))
			(insert (concat "ls"))
			(eshell-send-input)))
(defun scratch-here (&optional region-begin region-end)
	"Opens a new scratch-buffer associated with the current buffer to the side of
the current buffer.

If region is active, or REGION-BEGIN and REGION-END are set, insert content of
region into scratch buffer. If associated scratch buffer already exists, open it
and insert region contents at top."
	(interactive (if (use-region-p)
									 (list (region-beginning) (region-end))
								 (list nil nil)))
	(let* ((curr-buffer-name (buffer-name (current-buffer)))
				 (scratch-buffer-name (concat "*scratch " curr-buffer-name "*"))
				 (scratch-buffer (get-buffer-create scratch-buffer-name))
				 (region-string (if (and region-begin region-end)
														(buffer-substring-no-properties region-begin
																														region-end) nil))
				 (scratch-window-open (get-buffer-window scratch-buffer)))
		(if scratch-window-open
				(select-window scratch-window-open)
			(split-window-horizontally)
			(other-window 1)
			(switch-to-buffer scratch-buffer))
		(emacs-lisp-mode)
		(when region-string (insert region-string)))
	(goto-char (point-min)))

(bind-key "<f7>" 'scratch-here)
(use-package "eshell"
	:ensure nil
	:commands (eshell-here eshell eshell-send-input)
	:init
	(bind-key "<f9>" 'eshell-here)
	:config
	(use-package "em-smart"
		:ensure nil
		:config
		(setq eshell-where-to-jump 'begin)
		(setq eshell-review-quick-commands nil)
		(setq eshell-smart-space-goes-to-end t))
	(defun eshell/x ()
		(insert "exit")
		(eshell-send-input)
		(delete-window))
	)

(use-package expand-region
	:defer t
	:config
	(global-set-key (kbd "C-=") 'er/expand-region)
	)
	#+END_SRC
	#+BEGIN_SRC emacs-lisp
(defun xah-change-bracket-pairs ( *fromType *toType *begin *end)
  "Change bracket pairs from one type to another on current line or selection.
					For example, change all parenthesis () to square brackets [].

					When called in lisp program, *begin *end are region begin/end position, *fromType or *toType is a string of a bracket pair. \u2056 \"()\",  \"[]\", etc.
					URL `http://ergoemacs.org/emacs/elisp_change_brackets.html'
					Version 2016-11-04"
  (interactive
   (let ((-bracketsList
	  '("() paren"
	    "{} braces" "[] square"
	    "<> greater"
	    "\u201c\u201d curly quote"
	    "\u2018\u2019 single"
	    "\u2039\u203a french"
	    "«» double french"
	    "\u300c\u300d corner"
	    "\u300e\u300f double corner"
	    "\u3010\u3011 LENTICULAR"
	    "\u3016\u3017 white LENTICULAR"
	    "\u300a\u300b double angle"
	    "\u3008\u3009 angle "
	    "\u3014\u3015 TORTOISE"
	    "\u2985\u2986 white paren"
	    "\u301a\u301b white square"
	    "\u2983\u2984 white braces"
	    "\u2329\u232a"
	    "\u2991\u2992"
	    "\u29fc\u29fd"
	    "\u27e6\u27e7 math square"
	    "\u27e8\u27e9 math angle"
	    "\u27ea\u27eb"
	    "\u27ee\u27ef"
	    "\u27ec\u27ed"
	    "\u275b\u275c"
	    "\u275d\u275e"
	    "\u2768\u2769"
	    "\u276a\u276b"
	    "\u2774\u2775"
	    "\u276c\u276d"
	    "\u276e\u276f"
	    "\u2770\u2771"
	    "   none"
	    )))
     (list
      (helm-comp-read "Replace this:" -bracketsList )
      (helm-comp-read "To:" -bracketsList )
      (if (use-region-p) (region-beginning) nil)
      (if (use-region-p) (region-end) nil))))
  (save-excursion
    (save-restriction
      (when (null *begin)
	(setq *begin (line-beginning-position))
	(setq *end (line-end-position)))
      (narrow-to-region *begin *end)
      (let ( (case-fold-search nil)
	     (-fromLeft (substring *fromType 0 1))
	     (-toLeft (if (string-equal (substring *toType 0 1) " ")
			  (progn "")
			(substring *toType 0 1)))
	     (-fromRight (substring *fromType 1 2))
	     (-toRight (if (string-equal (substring *toType 1 2) " ")
			   (progn "")
			 (substring *toType 1 2))))
	(progn
	  (goto-char (point-min))
	  (while (search-forward -fromLeft nil t)
	    (overlay-put (make-overlay (match-beginning 0) (match-end 0)) 'face 'highlight)
	    (replace-match -toLeft 'FIXEDCASE 'LITERAL)))
	(progn
	  (goto-char (point-min))
	  (while (search-forward -fromRight nil t)
	    (overlay-put (make-overlay (match-beginning 0) (match-end 0)) 'face 'highlight)
	    (replace-match -toRight 'FIXEDCASE 'LITERAL)))))))

(use-package server
  :commands (server-running-p server-start)
  :config
  (unless (server-running-p)
    (server-start)
    ))
;; (unless (get-buffer "*Standalone Eshell*")
;;   (save-window-excursion
;;     (eshell)
;;     (rename-buffer "*Standalone Eshell*")))
;; (defun goto-standalone-eshell ()
;;   (interactive)
;;   (switch-to-buffer "*Standalone Eshell*"))
(use-package macrostep
	:after lisp-mode
	)

;; (use-package spacemacs-theme
;; :ensure t
;; :defer nil
;; )
;;  (load-theme 'spacemacs-dark t)
	#+END_SRC

** ESUP
:PROPERTIES:
:ID:       08422b75-c0c1-488d-98a5-ca9ea3007865
:END:
	 #+BEGIN_SRC emacs-lisp
(use-package f
	:defer t
	)
(use-package esup
	:after f
	:preface
	)
(defun esup-without-byte-compiler ()
	(interactive)
	(let ((esupfile (make-temp-file "esup")))
		(save-window-excursion
			(find-file (expand-file-name esupfile))
			(insert "(require 'package)
	(setq package-enable-at-startup nil)
	(add-to-list 'package-archives
							 '(\"melpa\" . \"http://melpa.org/packages/\") t)
	(add-to-list 'package-archives
							 '(\"org\" . \"http://orgmode.org/elpa/\") t)
	(require 'use-package)
	(unless (package-installed-p 'use-package)
		(package-refresh-contents)
		(package-install 'use-package))
	;(eval-when-compile (require 'use-package))
	(setq use-package-debug nil)
																				;(setq use-package-verbose 'debug)
	(setq use-package-verbose nil)

	(setq use-package-always-ensure t)\n")
			(insert-file-contents "~/.emacs.d/configuration.el")
			(save-buffer)
			(esup (expand-file-name esupfile))
			)))
(defvar generate-init-file-name
	"configuration-debug.el")
(defun generate-init-file ()
	(interactive)
	(org-babel-tangle-file "~/.emacs.d/configuration.org")
	(save-window-excursion
		(let ((to-delete (find-file generate-init-file-name)))
			(erase-buffer)
			(goto-char (point-max))
			(insert-file-contents "~/.emacs.d/configuration.el")
			(goto-char (point-max))
		 (insert "\n")
		 (save-buffer)
		 )))

	 #+END_SRC
** Disabled Stuff
:PROPERTIES:
:ID:       eba4b8c9-1906-4da1-bdbb-a392ba6b0f2e
:END:

*** Language Tool
:PROPERTIES:
:ID:       77de540d-80d0-4d49-ad45-374160838bdc
:END:
	 #+BEGIN_SRC emacs-lisp
(defun locate-langtool ()
  (or (executable-find "languagetool")
      (executable-find "langtool")))
(use-package langtool
  :disabled t
  :when (locate-langtool)
  :config
  (setq langtool-bin (locate-langtool))
  (setq langtool-language-tool-jar (locate-langtool))
  (setq langtool-default-language "en-GB"))
;(langtool-check-buffer)
	 #+END_SRC

* EXWM
Emacs has a complete window manager implemented in it. This
is both crazy and great. I use it some of the time when I
work. My startup script calls emacs with the argument
"--exwm" so we enable exwm only when it is called that way.

** Config
#+BEGIN_SRC emacs-lisp
(defun elib-toggle-kbd-language ()
  (interactive)
  (shell-command "xkb-switch -n" t))

(defun elib-exwm-launch  (command)
                        (interactive (list (read-shell-command "$ ")))
                        (start-process-shell-command command nil command))

(defvar elib-exwm-workspace-window-assignments
  '(("Google-chrome")))
(defun elib-exwm-init-buffers ()
  (interactive)
  (save-excursion
    (exwm-workspace-switch-create 2)
    (elib-exwm-launch "google-chrome")

    (exwm-workspace-switch-create 3)
    (elib-exwm-launch "gnome-control-center bluetooth")
    (split-window-horizontally)
    (other-window 1)
    (elib-exwm-launch "pavucontrol")
    (split-window)
    (other-window 1)
    (elib-exwm-launch "blueman-manager")
    )
  )


(defun elib-exwm-config ()
  (setq mouse-autoselect-window t)
  (setq focus-follows-mouse t)
  (setq exwm-workspace-number 4)
  (setq exwm-systemtray-height 24)
  (define-key exwm-mode-map (kbd "C-c C-j") 'exwm-input-grab-keyboard)
  ;; Make class name the buffer name

  (add-hook 'exwm-update-class-hook
            (lambda ()
              (exwm-workspace-rename-buffer exwm-class-name)))
  (exwm-input-set-key (kbd "s-<return>") #'dmenu)
  ;; 's-r': Reset
  (exwm-input-set-key (kbd "s-r") #'exwm-reset)
  (exwm-input-set-key (kbd "s-C-r") #'exwm-restart)
  ;; 's-w': Switch workspace
  (exwm-input-set-key (kbd "s-w") #'exwm-workspace-switch)
  (exwm-input-set-key (kbd "s-SPC") #'elib-toggle-kbd-language)
  ;; 's-N': Switch to certain workspace
  (dotimes (i 10)
    (exwm-input-set-key (kbd (format "s-%d" i))
                        `(lambda ()
                           (interactive)
                           (exwm-workspace-switch-create ,i))))
  ;; 's-&': Launch application
  (exwm-input-set-key (kbd "s-&") #'elib-exwm-launch
                      )
  (exwm-input-set-key (kbd "s-o") #'other-window)
  (exwm-input-set-key (kbd "s-j") #'exwm-input-grab-keyboard)

  (setq exwm-input-simulation-keys
        '(
          ;; movement
          ([?\C-b] . [left])
          ([?\M-b] . [C-left])
          ([?\C-f] . [right])
          ([?\M-f] . [C-right])
          ([?\C-p] . [up])
          ([?\C-n] . [down])
          ([?\C-a] . [home])
          ([?\C-e] . [end])
          ([?\M-v] . [prior])
          ([?\C-v] . [next])
          ([?\C-d] . [delete])
          ([?\C-k] . [S-end delete])
          ;; cut/paste.
          ([?\C-w] . [?\C-x])
          ([?\M-w] . [?\C-c])
          ([?\C-y] . [?\C-v])
          ;; search
          ([?\C-s] . [?\C-f])))
  (menu-bar-mode 1)
  (tool-bar-mode -1)
  (exwm-enable)
  (use-package dmenu
    :config
    (exwm-input-set-key (kbd "C-s-SPC") #'dmenu)
    )
  )





#+END_SRC


** Setup
:PROPERTIES:
:ID:       aa1694a9-e7c5-41ac-88ca-bc1474edc5ae
:END:
#+BEGIN_SRC emacs-lisp
(if (member "--exwm" command-line-args)
    (use-package exwm
      :config
      (require 'exwm-systemtray)
      (exwm-systemtray-enable)
      (add-to-list 'helm-source-names-using-follow "EXWM buffers")
      (use-package helm-exwm)
      (elib-exwm-config)
      (exwm-enable)
      (helm-themes))
  (load-theme 'spacemacs-dark))
#+END_SRC

* Enable Custom Keybindings
